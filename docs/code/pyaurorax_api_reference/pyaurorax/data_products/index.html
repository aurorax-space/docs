<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyaurorax.data_products API documentation</title>
<meta name="description" content="The data_products module is used to search and upload data
product records within AuroraX. One example of a data product
is a keogram …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.data_products</code></h1>
</header>
<section id="section-intro">
<p>The data_products module is used to search and upload data
product records within AuroraX. One example of a data product
is a keogram.</p>
<p>Note that all functions and classes from submodules are all imported
at this level of the data_products module. They can be referenced from
here instead of digging in deeper to the submodules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The data_products module is used to search and upload data
product records within AuroraX. One example of a data product
is a keogram.

Note that all functions and classes from submodules are all imported
at this level of the data_products module. They can be referenced from
here instead of digging in deeper to the submodules.
&#34;&#34;&#34;

# keogram data product type
DATA_PRODUCT_TYPE_KEOGRAM = &#34;keogram&#34;
&#34;&#34;&#34;
Data product type for keograms. Keograms are a 2-D
representation of a series of images, and are one of
the most popular data products that auroral science
uses. More information can be found at
https://docs.aurorax.space/about_the_data/standards/#keograms.
&#34;&#34;&#34;

# montage data product type
DATA_PRODUCT_TYPE_MONTAGE = &#34;montage&#34;
&#34;&#34;&#34;
Data product type for montages. Like keograms, montages are
another representation of a series of images. However, montages
are not a 2D representation but rather a collage of thumnbail
images for the period of time. An example can be found at
https://data.phys.ucalgary.ca/sort_by_project/THEMIS/asi/stream2/2021/12/28/gill_themis19/20211228__gill_themis19_full-montage.pgm.jpg
&#34;&#34;&#34;

# movie data product type
DATA_PRODUCT_TYPE_MOVIE = &#34;movie&#34;
&#34;&#34;&#34;
Data product type for movies. Movies are timelapse video
files of auroral data, usually as MP4 or MPEG. They can
consist of frames for a whole night, or an hour, and can
be at any cadence that is most appropriate.
&#34;&#34;&#34;

# summary plot data product type
DATA_PRODUCT_TYPE_SUMMARY_PLOT = &#34;summary_plot&#34;
&#34;&#34;&#34;
Data product type for summary plots. A summary plot can be any type
of plot that shows auroral data in a summary format, for example a
background-subtracted meridian scanning photometer plot showing
counts in Rayleighs.
&#34;&#34;&#34;

# data availability data product type
DATA_PRODUCT_TYPE_DATA_AVAILABILITY = &#34;data_availability&#34;
&#34;&#34;&#34;
Data product type for data availability. The AuroraX data availability
system does not account for times when data was not expected to be
collected, such as summer shutdowns due to inadequate night hours. This
data product type for &#39;data availbility&#39; is meant to be used as a smarter
data availability mechanism for Aurora.
&#34;&#34;&#34;

# function and class imports
from .data_products import (search,
                            upload,
                            delete_urls,
                            delete,
                            describe,
                            get_request_url)
from .classes.data_product import DataProduct
from .classes.search import Search

# pdoc imports and exports
from .data_products import __pdoc__ as __data_products_pdoc__
from .classes.data_product import __pdoc__ as __classes_data_product_pdoc__
from .classes.search import __pdoc__ as __classes_search_pdoc__
__pdoc__ = __data_products_pdoc__
__pdoc__ = dict(__pdoc__, **__classes_data_product_pdoc__)
__pdoc__ = dict(__pdoc__, **__classes_search_pdoc__)
__all__ = [
    &#34;DATA_PRODUCT_TYPE_KEOGRAM&#34;,
    &#34;DATA_PRODUCT_TYPE_MONTAGE&#34;,
    &#34;DATA_PRODUCT_TYPE_MOVIE&#34;,
    &#34;DATA_PRODUCT_TYPE_SUMMARY_PLOT&#34;,
    &#34;DATA_PRODUCT_TYPE_DATA_AVAILABILITY&#34;,
    &#34;search&#34;,
    &#34;upload&#34;,
    &#34;delete_urls&#34;,
    &#34;delete&#34;,
    &#34;describe&#34;,
    &#34;get_request_url&#34;,
    &#34;DataProduct&#34;,
    &#34;Search&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyaurorax.data_products.classes" href="classes/index.html">pyaurorax.data_products.classes</a></code></dt>
<dd>
<div class="desc"><p>Separted classes and functions used by the data_products module …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.data_products.data_products" href="data_products.html">pyaurorax.data_products.data_products</a></code></dt>
<dd>
<div class="desc"><p>Functions for performing data product searches</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pyaurorax.data_products.DATA_PRODUCT_TYPE_DATA_AVAILABILITY"><code class="name">var <span class="ident">DATA_PRODUCT_TYPE_DATA_AVAILABILITY</span></code></dt>
<dd>
<div class="desc"><p>Data product type for data availability. The AuroraX data availability
system does not account for times when data was not expected to be
collected, such as summer shutdowns due to inadequate night hours. This
data product type for 'data availbility' is meant to be used as a smarter
data availability mechanism for Aurora.</p></div>
</dd>
<dt id="pyaurorax.data_products.DATA_PRODUCT_TYPE_KEOGRAM"><code class="name">var <span class="ident">DATA_PRODUCT_TYPE_KEOGRAM</span></code></dt>
<dd>
<div class="desc"><p>Data product type for keograms. Keograms are a 2-D
representation of a series of images, and are one of
the most popular data products that auroral science
uses. More information can be found at
<a href="https://docs.aurorax.space/about_the_data/standards/#keograms.">https://docs.aurorax.space/about_the_data/standards/#keograms.</a></p></div>
</dd>
<dt id="pyaurorax.data_products.DATA_PRODUCT_TYPE_MONTAGE"><code class="name">var <span class="ident">DATA_PRODUCT_TYPE_MONTAGE</span></code></dt>
<dd>
<div class="desc"><p>Data product type for montages. Like keograms, montages are
another representation of a series of images. However, montages
are not a 2D representation but rather a collage of thumnbail
images for the period of time. An example can be found at
<a href="https://data.phys.ucalgary.ca/sort_by_project/THEMIS/asi/stream2/2021/12/28/gill_themis19/20211228__gill_themis19_full-montage.pgm.jpg">https://data.phys.ucalgary.ca/sort_by_project/THEMIS/asi/stream2/2021/12/28/gill_themis19/20211228__gill_themis19_full-montage.pgm.jpg</a></p></div>
</dd>
<dt id="pyaurorax.data_products.DATA_PRODUCT_TYPE_MOVIE"><code class="name">var <span class="ident">DATA_PRODUCT_TYPE_MOVIE</span></code></dt>
<dd>
<div class="desc"><p>Data product type for movies. Movies are timelapse video
files of auroral data, usually as MP4 or MPEG. They can
consist of frames for a whole night, or an hour, and can
be at any cadence that is most appropriate.</p></div>
</dd>
<dt id="pyaurorax.data_products.DATA_PRODUCT_TYPE_SUMMARY_PLOT"><code class="name">var <span class="ident">DATA_PRODUCT_TYPE_SUMMARY_PLOT</span></code></dt>
<dd>
<div class="desc"><p>Data product type for summary plots. A summary plot can be any type
of plot that shows auroral data in a summary format, for example a
background-subtracted meridian scanning photometer plot showing
counts in Rayleighs.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyaurorax.data_products.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>data_source: <a title="pyaurorax.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.sources.classes.data_source.DataSource">DataSource</a>, start: datetime.datetime, end: datetime.datetime, data_product_types: Optional[List[str]] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete data products associated with a data source within a date range.</p>
<p>The API processes this request asynchronously, so this method will return
immediately whether or not the data has already been deleted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_source</code></strong></dt>
<dd>data source associated with the data product records (note that
identifier, program, platform, and instrument_type are required)</dd>
<dt><strong><code>start</code></strong></dt>
<dd>timestamp marking beginning of range to delete records for, inclusive</dd>
<dt><strong><code>end</code></strong></dt>
<dd>timestamp marking end of range to delete records for, inclusive</dd>
<dt><strong><code>data_product_types</code></strong></dt>
<dd>specific types of data product to delete, e.g.
["keogram", "movie"]. If omitted, all data product types will be deleted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXMaxRetriesException" href="../exceptions.html#pyaurorax.exceptions.AuroraXMaxRetriesException">AuroraXMaxRetriesException</a></code></dt>
<dd>max retry error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXNotFoundException" href="../exceptions.html#pyaurorax.exceptions.AuroraXNotFoundException">AuroraXNotFoundException</a></code></dt>
<dd>source not found</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedException">AuroraXUnauthorizedException</a></code></dt>
<dd>invalid API key for this operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(data_source: DataSource,
           start: datetime.datetime,
           end: datetime.datetime,
           data_product_types: Optional[List[str]] = None) -&gt; int:
    &#34;&#34;&#34;
    Delete data products associated with a data source within a date range.

    The API processes this request asynchronously, so this method will return
    immediately whether or not the data has already been deleted.

    Args:
        data_source: data source associated with the data product records (note that
            identifier, program, platform, and instrument_type are required)
        start: timestamp marking beginning of range to delete records for, inclusive
        end: timestamp marking end of range to delete records for, inclusive
        data_product_types: specific types of data product to delete, e.g.
            [&#34;keogram&#34;, &#34;movie&#34;]. If omitted, all data product types will be deleted.

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
        pyaurorax.exceptions.AuroraXNotFoundException: source not found
        pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
    &#34;&#34;&#34;
    # check to make sure the identifier, program, platform, and instrument type are all set in the data source
    if not all([data_source.identifier, data_source.program, data_source.platform, data_source.instrument_type]):
        raise AuroraXBadParametersException(&#34;One or more required data source parameters &#34;
                                            &#34;are missing, delete operation aborted&#34;)

    # do request to get all data products between start and end datetimes
    try:
        s = search(start,
                   end,
                   programs=[data_source.program],
                   platforms=[data_source.platform],
                   instrument_types=[data_source.instrument_type],
                   data_product_types=[] if not data_product_types else data_product_types)
    except Exception as e:
        raise AuroraXException(e)

    # collect URLs from search result
    urls = []
    for dp in s.data:
        urls.append(dp.url)  # type: ignore

    # do delete request
    return delete_urls(data_source, urls)</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.delete_urls"><code class="name flex">
<span>def <span class="ident">delete_urls</span></span>(<span>data_source: <a title="pyaurorax.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.sources.classes.data_source.DataSource">DataSource</a>, urls: List[str]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete data products by URL.</p>
<p>The API processes this request asynchronously, so this method will return
immediately whether or not the data has already been deleted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_source</code></strong></dt>
<dd>data source associated with the data product records (note that
identifier, program, platform, and instrument_type are required)</dd>
<dt><strong><code>urls</code></strong></dt>
<dd>URLs of data product records to delete</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXMaxRetriesException" href="../exceptions.html#pyaurorax.exceptions.AuroraXMaxRetriesException">AuroraXMaxRetriesException</a></code></dt>
<dd>max retry error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>invalid parameters entered</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedException">AuroraXUnauthorizedException</a></code></dt>
<dd>invalid API key for this operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_urls(data_source: DataSource,
                urls: List[str]) -&gt; int:
    &#34;&#34;&#34;
    Delete data products by URL.

    The API processes this request asynchronously, so this method will return
    immediately whether or not the data has already been deleted.

    Args:
        data_source: data source associated with the data product records (note that
            identifier, program, platform, and instrument_type are required)
        urls: URLs of data product records to delete

    Returns:
        0 on success

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
        pyaurorax.exceptions.AuroraXBadParametersException: invalid parameters entered
        pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
    &#34;&#34;&#34;
    # check to make sure the identifier, program, platform, and instrument type are all set in the data source
    if not all([data_source.identifier, data_source.program, data_source.platform, data_source.instrument_type]):
        raise AuroraXBadParametersException(&#34;One or more required data source parameters &#34;
                                            &#34;are missing, delete operation aborted&#34;)

    # do request
    url = api_urls.data_products_upload_url.format(data_source.identifier)
    params = {
        &#34;program&#34;: data_source.program,
        &#34;platform&#34;: data_source.platform,
        &#34;instrument_type&#34;: data_source.instrument_type,
        &#34;urls&#34;: urls
    }
    delete_req = AuroraXRequest(method=&#34;delete&#34;,
                                url=url,
                                body=params,
                                null_response=True)
    res = delete_req.execute()

    # evaluate response
    if (res.status_code == 400):
        if type(res.data) is list:
            raise AuroraXBadParametersException(&#34;%s - %s&#34; % (res.status_code,
                                                             res.data[0][&#34;message&#34;]))
        raise AuroraXBadParametersException(&#34;%s - %s&#34; % (res.status_code,
                                                         res.data[&#34;message&#34;]))

    # return
    return 0</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>search_obj: <a title="pyaurorax.data_products.classes.search.Search" href="classes/search.html#pyaurorax.data_products.classes.search.Search">Search</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Describe a data product search as an "SQL-like" string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>search_obj</code></strong></dt>
<dd>the data product search object to describe</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the "SQL-like" string describing the data product search object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(search_obj: Search) -&gt; str:
    &#34;&#34;&#34;
    Describe a data product search as an &#34;SQL-like&#34; string

    Args:
        search_obj: the data product search object to describe

    Returns:
        the &#34;SQL-like&#34; string describing the data product search object
    &#34;&#34;&#34;
    # make request
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=api_urls.describe_data_products_query_url,
                         body=search_obj.query)
    res = req.execute()

    # return
    return res.data</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.get_request_url"><code class="name flex">
<span>def <span class="ident">get_request_url</span></span>(<span>request_id: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the data product search request URL for a given
request ID. This URL can be used for subsequent
pyaurorax.requests function calls. Primarily this method
facilitates delving into details about a set of already-submitted
data product searches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_id</code></strong></dt>
<dd>the request identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the request URL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_request_url(request_id: str) -&gt; str:
    &#34;&#34;&#34;
    Get the data product search request URL for a given
    request ID. This URL can be used for subsequent
    pyaurorax.requests function calls. Primarily this method
    facilitates delving into details about a set of already-submitted
    data product searches.

    Args:
        request_id: the request identifier

    Returns:
        the request URL
    &#34;&#34;&#34;
    url = api_urls.data_products_request_url.format(request_id)
    return url</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>start: datetime.datetime, end: datetime.datetime, programs: Optional[List[str]] = None, platforms: Optional[List[str]] = None, instrument_types: Optional[List[str]] = None, data_product_types: Optional[List[str]] = None, metadata_filters: Optional[List[Dict[~KT, ~VT]]] = None, metadata_filters_logical_operator: Optional[str] = None, response_format: Optional[Dict[~KT, ~VT]] = None, poll_interval: Optional[float] = 1.0, return_immediately: Optional[bool] = False, verbose: Optional[bool] = False) ‑> <a title="pyaurorax.data_products.classes.search.Search" href="classes/search.html#pyaurorax.data_products.classes.search.Search">Search</a></span>
</code></dt>
<dd>
<div class="desc"><p>Search for data product records</p>
<p>By default, this function will block and wait until the request completes and
all data is downloaded. If you don't want to wait, set the 'return_immediately`
value to True. The Search object will be returned right after the search has been
started, and you can use the helper functions as part of that object to get the
data when it's done.</p>
<p>Note: At least one search criteria from programs, platforms, or
instrument_types, must be specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong></dt>
<dd>list of programs to search through, defaults to None</dd>
<dt><strong><code>platforms</code></strong></dt>
<dd>list of platforms to search through, defaults to None</dd>
<dt><strong><code>instrument_types</code></strong></dt>
<dd>list of instrument types to search through, defaults to None</dd>
<dt><strong><code>data_product_types</code></strong></dt>
<dd>list of dictionaries describing data product
types to filter on e.g. "keogram", defaults to None. Options are in the
pyaurorax.data_products module, or at the top level using the
pyaurorax.DATA_PRODUCT_TYPE* variables.</dd>
<dt><strong><code>metadata_filters</code></strong></dt>
<dd>
<p>list of dictionaries describing metadata keys and
values to filter on, defaults to None</p>
<p>Example:</p>
<pre><code>[{
    "key": "nbtrace_region",
    "operator": "in",
    "values": ["north polar cap"]
}]
</code></pre>
</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong></dt>
<dd>the logical operator to use when
evaluating metadata filters (either 'AND' or 'OR'), defaults
to "AND"</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts, defaults
to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>return_immediately</code></strong></dt>
<dd>initiate the search and return without waiting for data to
be received, defaults to False</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a pyaurorax.data_products.Search object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(start: datetime.datetime,
           end: datetime.datetime,
           programs: Optional[List[str]] = None,
           platforms: Optional[List[str]] = None,
           instrument_types: Optional[List[str]] = None,
           data_product_types: Optional[List[str]] = None,
           metadata_filters: Optional[List[Dict]] = None,
           metadata_filters_logical_operator: Optional[str] = None,
           response_format: Optional[Dict] = None,
           poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
           return_immediately: Optional[bool] = False,
           verbose: Optional[bool] = False) -&gt; Search:
    &#34;&#34;&#34;
    Search for data product records

    By default, this function will block and wait until the request completes and
    all data is downloaded. If you don&#39;t want to wait, set the &#39;return_immediately`
    value to True. The Search object will be returned right after the search has been
    started, and you can use the helper functions as part of that object to get the
    data when it&#39;s done.

    Note: At least one search criteria from programs, platforms, or
    instrument_types, must be specified.

    Args:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of programs to search through, defaults to None
        platforms: list of platforms to search through, defaults to None
        instrument_types: list of instrument types to search through, defaults to None
        data_product_types: list of dictionaries describing data product
            types to filter on e.g. &#34;keogram&#34;, defaults to None. Options are in the
            pyaurorax.data_products module, or at the top level using the
            pyaurorax.DATA_PRODUCT_TYPE* variables.
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            Example:

                [{
                    &#34;key&#34;: &#34;nbtrace_region&#34;,
                    &#34;operator&#34;: &#34;in&#34;,
                    &#34;values&#34;: [&#34;north polar cap&#34;]
                }]
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format
        poll_interval: time in seconds to wait between polling attempts, defaults
            to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
        return_immediately: initiate the search and return without waiting for data to
            be received, defaults to False
        verbose: output poll times and other progress messages, defaults to False

    Returns:
        a pyaurorax.data_products.Search object
    &#34;&#34;&#34;
    # create a Search() object
    s = Search(start,
               end,
               programs=programs,
               platforms=platforms,
               instrument_types=instrument_types,
               data_product_types=data_product_types,
               metadata_filters=metadata_filters,
               metadata_filters_logical_operator=metadata_filters_logical_operator,
               response_format=response_format)
    if (verbose is True):
        print(&#34;[%s] Search object created&#34; % (datetime.datetime.now()))

    # execute the search
    s.execute()
    if (verbose is True):
        print(&#34;[%s] Request submitted&#34; % (datetime.datetime.now()))
        print(&#34;[%s] Request ID: %s&#34; % (datetime.datetime.now(), s.request_id))
        print(&#34;[%s] Request details available at: %s&#34; % (datetime.datetime.now(),
                                                         s.request_url))

    # return immediately if we wanted to
    if (return_immediately is True):
        return s

    # wait for data
    if (verbose is True):
        print(&#34;[%s] Waiting for data ...&#34; % (datetime.datetime.now()))
    s.wait(poll_interval=poll_interval, verbose=verbose)

    # check if error condition encountered
    if (s.status[&#34;search_result&#34;][&#34;error_condition&#34;] is True):
        # error encountered
        raise AuroraXSearchException(s.logs[-1][&#34;summary&#34;])

    # get the data
    if (verbose is True):
        print(&#34;[%s] Retrieving data ...&#34; % (datetime.datetime.now()))
    s.get_data()

    # return response with the data
    if (verbose is True):
        print(&#34;[%s] Retrieved %s of data containing %d records&#34; % (datetime.datetime.now(),
                                                                   humanize.filesize.naturalsize(
                                                                       s.status[&#34;search_result&#34;][&#34;file_size&#34;]),
                                                                   s.status[&#34;search_result&#34;][&#34;result_count&#34;]))
    return s</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>identifier: int, records: List[<a title="pyaurorax.data_products.classes.data_product.DataProduct" href="classes/data_product.html#pyaurorax.data_products.classes.data_product.DataProduct">DataProduct</a>], validate_source: Optional[bool] = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Upload data product records to AuroraX</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifier</code></strong></dt>
<dd>the AuroraX data source ID</dd>
<dt><strong><code>records</code></strong></dt>
<dd>data product records to upload</dd>
<dt><strong><code>validate_source</code></strong></dt>
<dd>validate all records before uploading, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 for success, raises exception on error</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXMaxRetriesException" href="../exceptions.html#pyaurorax.exceptions.AuroraXMaxRetriesException">AuroraXMaxRetriesException</a></code></dt>
<dd>max retry error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected content error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUploadException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUploadException">AuroraXUploadException</a></code></dt>
<dd>upload error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXValidationException" href="../exceptions.html#pyaurorax.exceptions.AuroraXValidationException">AuroraXValidationException</a></code></dt>
<dd>data source validation error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(identifier: int,
           records: List[DataProduct],
           validate_source: Optional[bool] = False) -&gt; int:
    &#34;&#34;&#34;
    Upload data product records to AuroraX

    Args:
        identifier: the AuroraX data source ID
        records: data product records to upload
        validate_source: validate all records before uploading, defaults to False

    Returns:
        0 for success, raises exception on error

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected content error
        pyaurorax.exceptions.AuroraXUploadException: upload error
        pyaurorax.exceptions.AuroraXValidationException: data source validation error
    &#34;&#34;&#34;
    # validate record sources if the flag is set
    if validate_source:
        validation_error = __validate_data_source(identifier, records)
        if validation_error:
            raise AuroraXValidationException(f&#34;Unable to validate data source &#34;
                                             &#34;found in record: {validation_error}&#34;)

    # translate each data product record to a request-friendly
    # dict (ie. convert datetimes to strings, etc.)
    for i, _ in enumerate(records):
        if (type(records[i]) is DataProduct):
            records[i] = records[i].to_json_serializable()  # type: ignore

    # make request
    url = api_urls.data_products_upload_url.format(identifier)
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=url,
                         body=records,
                         null_response=True)
    res = req.execute()

    # evaluate response
    if (res.status_code == 400):
        if type(res.data) is list:
            raise AuroraXUploadException(&#34;%s - %s&#34; % (res.status_code,
                                                      res.data[0][&#34;error_message&#34;]))

        raise AuroraXUploadException(&#34;%s - %s&#34; % (res.status_code,
                                                  res.data[&#34;error_message&#34;]))

    # return
    return 0</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.data_products.DataProduct"><code class="flex name class">
<span>class <span class="ident">DataProduct</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Data product object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_source</code></strong></dt>
<dd>data source that the ephemeris record is associated with</dd>
<dt><strong><code>data_product_type</code></strong></dt>
<dd>data product type ("keogram", "movie", "summary_plot")</dd>
<dt><strong><code>start</code></strong></dt>
<dd>starting timestamp for the record (assumed it is in UTC), inclusive</dd>
<dt><strong><code>end</code></strong></dt>
<dd>ending timestamp for the record (assumed it is in UTC), inclusive</dd>
<dt><strong><code>url</code></strong></dt>
<dd>the URL of data product</dd>
<dt><strong><code>metdata</code></strong></dt>
<dd>metadata for this record (arbitrary keys and values)</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataProduct(BaseModel):
    &#34;&#34;&#34;
    Data product object

    Attributes:
        data_source: data source that the ephemeris record is associated with
        data_product_type: data product type (&#34;keogram&#34;, &#34;movie&#34;, &#34;summary_plot&#34;)
        start: starting timestamp for the record (assumed it is in UTC), inclusive
        end: ending timestamp for the record (assumed it is in UTC), inclusive
        url: the URL of data product
        metdata: metadata for this record (arbitrary keys and values)
    &#34;&#34;&#34;
    data_source: DataSource
    data_product_type: str
    start: datetime.datetime
    end: datetime.datetime
    url: str
    metadata: Dict

    def to_json_serializable(self) -&gt; Dict:
        &#34;&#34;&#34;
        Convert object to a JSON-serializable object (ie. translate
        datetime objects to strings)

        Returns:
            a dictionary object that is JSON-serializable
        &#34;&#34;&#34;
        # init
        d = self.__dict__

        # format epoch as str
        if (type(d[&#34;start&#34;]) is datetime.datetime):
            d[&#34;start&#34;] = d[&#34;start&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)
        if (type(d[&#34;end&#34;]) is datetime.datetime):
            d[&#34;end&#34;] = d[&#34;end&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)

        # format metadata
        if (type(self.metadata) is dict):
            for key, value in self.metadata.items():
                if (type(value) is datetime.datetime or type(value) is datetime.date):
                    self.metadata[key] = self.metadata[key].strftime(
                        &#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
        if (type(self.metadata) is list):
            self.metadata = {}

        # format data source fields for query
        d[&#34;program&#34;] = self.data_source.program
        d[&#34;platform&#34;] = self.data_source.platform
        d[&#34;instrument_type&#34;] = self.data_source.instrument_type
        del d[&#34;data_source&#34;]

        # return
        return d

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        String method

        Returns:
            string format of DataProduct object
        &#34;&#34;&#34;
        return self.__repr__()

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Object representation

        Returns:
            object representation of DataProduct object
        &#34;&#34;&#34;
        # shorten the metadata and url
        max_len = 20
        attr_metadata = f&#34;{self.metadata}&#34;
        if (len(attr_metadata) &gt; max_len):
            attr_metadata = attr_metadata[0:max_len] + &#34;...}&#34;
        attr_url = f&#34;{self.url}&#34;
        if (len(attr_url) &gt; max_len):
            attr_url = attr_url[0:max_len] + &#34;...&#34;

        # return formatted representation
        return f&#34;DataProduct(data_source={repr(self.data_source)}, start={repr(self.start)}, &#34; \
            f&#34;end={repr(self.end)}, data_product_type=&#39;{self.data_product_type}&#39;, url=&#39;{attr_url}&#39;, &#34; \
            f&#34;metadata={attr_metadata})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.data_products.DataProduct.data_product_type"><code class="name">var <span class="ident">data_product_type</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.data_products.DataProduct.data_source"><code class="name">var <span class="ident">data_source</span> : <a title="pyaurorax.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.sources.classes.data_source.DataSource">DataSource</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.data_products.DataProduct.end"><code class="name">var <span class="ident">end</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.data_products.DataProduct.metadata"><code class="name">var <span class="ident">metadata</span> : Dict[~KT, ~VT]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.data_products.DataProduct.start"><code class="name">var <span class="ident">start</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.data_products.DataProduct.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.data_products.DataProduct.to_json_serializable"><code class="name flex">
<span>def <span class="ident">to_json_serializable</span></span>(<span>self) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert object to a JSON-serializable object (ie. translate
datetime objects to strings)</p>
<h2 id="returns">Returns</h2>
<p>a dictionary object that is JSON-serializable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json_serializable(self) -&gt; Dict:
    &#34;&#34;&#34;
    Convert object to a JSON-serializable object (ie. translate
    datetime objects to strings)

    Returns:
        a dictionary object that is JSON-serializable
    &#34;&#34;&#34;
    # init
    d = self.__dict__

    # format epoch as str
    if (type(d[&#34;start&#34;]) is datetime.datetime):
        d[&#34;start&#34;] = d[&#34;start&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)
    if (type(d[&#34;end&#34;]) is datetime.datetime):
        d[&#34;end&#34;] = d[&#34;end&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)

    # format metadata
    if (type(self.metadata) is dict):
        for key, value in self.metadata.items():
            if (type(value) is datetime.datetime or type(value) is datetime.date):
                self.metadata[key] = self.metadata[key].strftime(
                    &#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
    if (type(self.metadata) is list):
        self.metadata = {}

    # format data source fields for query
    d[&#34;program&#34;] = self.data_source.program
    d[&#34;platform&#34;] = self.data_source.platform
    d[&#34;instrument_type&#34;] = self.data_source.instrument_type
    del d[&#34;data_source&#34;]

    # return
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyaurorax.data_products.Search"><code class="flex name class">
<span>class <span class="ident">Search</span></span>
<span>(</span><span>start: datetime.datetime, end: datetime.datetime, programs: Optional[List[str]] = None, platforms: Optional[List[str]] = None, instrument_types: Optional[List[str]] = None, data_product_types: Optional[List[str]] = None, metadata_filters: Optional[List[Dict[~KT, ~VT]]] = None, metadata_filters_logical_operator: Optional[str] = 'AND', response_format: Optional[Dict[~KT, ~VT]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a data product search</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong></dt>
<dd>list of program names to search</dd>
<dt><strong><code>platforms</code></strong></dt>
<dd>list of platform names to search</dd>
<dt><strong><code>instrument_types</code></strong></dt>
<dd>list of instrument types to search</dd>
<dt><strong><code>data_product_types</code></strong></dt>
<dd>list of dictionaries describing data product
types to filter on e.g. "keogram", defaults to None. Options are in the
pyaurorax.data_products module, or at the top level using the
pyaurorax.DATA_PRODUCT_TYPE* variables.</dd>
<dt><strong><code>metadata_filters</code></strong></dt>
<dd>
<p>list of dictionaries describing metadata keys and
values to filter on, defaults to None</p>
<p>Example:</p>
<pre><code>[{
    "key": "nbtrace_region",
    "operator": "in",
    "values": ["north polar cap"]
}]
</code></pre>
</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong></dt>
<dd>the logical operator to use when
evaluating metadata filters (either 'AND' or 'OR'), defaults
to "AND"</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong></dt>
<dd>unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong></dt>
<dd>unique URL assigned to the request by the AuroraX API</dd>
<dt><strong><code>executed</code></strong></dt>
<dd>indicates if the search has been executed/started</dd>
<dt><strong><code>completed</code></strong></dt>
<dd>indicates if the search has finished</dd>
<dt><strong><code>data_url</code></strong></dt>
<dd>the URL where data is accessed</dd>
<dt><strong><code>query</code></strong></dt>
<dd>the query for this request as JSON</dd>
<dt><strong><code>status</code></strong></dt>
<dd>the status of the query</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the data product records found</dd>
<dt><strong><code>logs</code></strong></dt>
<dd>all log messages outputed by the AuroraX API for this request</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Search():
    &#34;&#34;&#34;
    Class representing a data product search

    Attributes:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of program names to search
        platforms: list of platform names to search
        instrument_types: list of instrument types to search
        data_product_types: list of dictionaries describing data product
            types to filter on e.g. &#34;keogram&#34;, defaults to None. Options are in the
            pyaurorax.data_products module, or at the top level using the
            pyaurorax.DATA_PRODUCT_TYPE* variables.
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            Example:

                [{
                    &#34;key&#34;: &#34;nbtrace_region&#34;,
                    &#34;operator&#34;: &#34;in&#34;,
                    &#34;values&#34;: [&#34;north polar cap&#34;]
                }]
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format
        request: AuroraXResponse object returned when the search is executed
        request_id: unique ID assigned to the request by the AuroraX API
        request_url: unique URL assigned to the request by the AuroraX API
        executed: indicates if the search has been executed/started
        completed: indicates if the search has finished
        data_url: the URL where data is accessed
        query: the query for this request as JSON
        status: the status of the query
        data: the data product records found
        logs: all log messages outputed by the AuroraX API for this request
    &#34;&#34;&#34;

    def __init__(self,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 programs: Optional[List[str]] = None,
                 platforms: Optional[List[str]] = None,
                 instrument_types: Optional[List[str]] = None,
                 data_product_types: Optional[List[str]] = None,
                 metadata_filters: Optional[List[Dict]] = None,
                 metadata_filters_logical_operator: Optional[str] = &#34;AND&#34;,
                 response_format: Optional[Dict] = None) -&gt; None:

        # set variables using passed in args
        self.start = start
        self.end = end
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.data_product_types = data_product_types
        self.metadata_filters = metadata_filters
        self.metadata_filters_logical_operator = metadata_filters_logical_operator
        self.response_format = response_format

        # initialize additional variables
        self.request: AuroraXResponse = None
        self.request_id: str = &#34;&#34;
        self.request_url: str = &#34;&#34;
        self.executed: bool = False
        self.completed: bool = False
        self.data_url: str = &#34;&#34;
        self.query: Dict = {}
        self.status: Dict = {}
        self.data: List[Union[DataProduct, Dict]] = []
        self.logs: List[Dict] = []

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        String method

        Returns:
            string format of DataProduct Search object
        &#34;&#34;&#34;
        return self.__repr__()

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Object representation

        Returns:
            object representation of DataProduct Search object
        &#34;&#34;&#34;
        return f&#34;DataProductsSearch(executed={self.executed}, &#34; \
            f&#34;completed={self.completed}, request_id=&#39;{self.request_id}&#39;)&#34;

    @property
    def query(self):
        &#34;&#34;&#34;
        Property for the query value
        &#34;&#34;&#34;
        self._query = {
            &#34;data_sources&#34;: {
                &#34;programs&#34;: [] if not self.programs else self.programs,
                &#34;platforms&#34;: [] if not self.platforms else self.platforms,
                &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
                &#34;data_product_metadata_filters&#34;: {} if not self.metadata_filters
                else {
                    &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
                    &#34;expressions&#34;: self.metadata_filters
                },
            },
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;data_product_type_filters&#34;: [] if not self.data_product_types else self.data_product_types,
        }
        return self._query

    @query.setter
    def query(self, query):
        self._query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate a data product search request
        &#34;&#34;&#34;
        # do request
        url = urls.data_products_search_url
        req = AuroraXRequest(method=&#34;post&#34;,
                             url=url,
                             body=self.query,
                             null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if (res.status_code == 202):
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this data product search request

        Args:
            status: the previously-retrieved status of this request (include
                to avoid requesting it from the API again), defaults to None
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.request_url)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s%s&#34; % (urls.base_url,
                                      status[&#34;search_result&#34;][&#34;data_uri&#34;])

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this data product
        search request

        Returns:
            True if data is available, else False
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this data product search request
        &#34;&#34;&#34;
        # check if it&#39;s completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.data_url, response_format=self.response_format)

        # set data variable
        if self.response_format is not None:
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_source&#34;] = ds

            # cast data product objects
            self.data = [DataProduct(**dp) for dp in raw_data]

    def wait(self,
             poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
             verbose: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait for the request to complete and data is available
        for retrieval

        Args:
            poll_interval: time in seconds to wait between polling attempts,
                defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
            verbose: output poll times and other progress messages, defaults
                to False
        &#34;&#34;&#34;
        url = urls.data_products_request_url.format(self.request_id)
        self.update_status(requests_wait_for_data(url,
                                                  poll_interval=poll_interval,
                                                  verbose=verbose))

    def cancel(self,
               wait: Optional[bool] = False,
               poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
               verbose: Optional[bool] = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the data product search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait: wait until the cancellation request has been
                completed (may wait for several minutes)
            poll_interval: seconds to wait between polling
                calls, defaults to STANDARD_POLLING_SLEEP_TIME.
            verbose: output poll times and other progress messages, defaults
                to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
            pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
        &#34;&#34;&#34;
        url = urls.data_products_request_url.format(self.request_id)
        return requests_cancel(url, wait=wait, poll_interval=poll_interval, verbose=verbose)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.data_products.Search.query"><code class="name">var <span class="ident">query</span></code></dt>
<dd>
<div class="desc"><p>Property for the query value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self):
    &#34;&#34;&#34;
    Property for the query value
    &#34;&#34;&#34;
    self._query = {
        &#34;data_sources&#34;: {
            &#34;programs&#34;: [] if not self.programs else self.programs,
            &#34;platforms&#34;: [] if not self.platforms else self.platforms,
            &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
            &#34;data_product_metadata_filters&#34;: {} if not self.metadata_filters
            else {
                &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
                &#34;expressions&#34;: self.metadata_filters
            },
        },
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;data_product_type_filters&#34;: [] if not self.data_product_types else self.data_product_types,
    }
    return self._query</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.data_products.Search.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: Optional[bool] = False, poll_interval: Optional[float] = 1.0, verbose: Optional[bool] = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel the data product search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong></dt>
<dd>wait until the cancellation request has been
completed (may wait for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>seconds to wait between polling
calls, defaults to STANDARD_POLLING_SLEEP_TIME.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedException">AuroraXUnauthorizedException</a></code></dt>
<dd>invalid API key for this operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self,
           wait: Optional[bool] = False,
           poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
           verbose: Optional[bool] = False) -&gt; int:
    &#34;&#34;&#34;
    Cancel the data product search request

    This method returns immediately by default since the API processes
    this request asynchronously. If you would prefer to wait for it
    to be completed, set the &#39;wait&#39; parameter to True. You can adjust
    the polling time using the &#39;poll_interval&#39; parameter.

    Args:
        wait: wait until the cancellation request has been
            completed (may wait for several minutes)
        poll_interval: seconds to wait between polling
            calls, defaults to STANDARD_POLLING_SLEEP_TIME.
        verbose: output poll times and other progress messages, defaults
            to False

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
        pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
    &#34;&#34;&#34;
    url = urls.data_products_request_url.format(self.request_id)
    return requests_cancel(url, wait=wait, poll_interval=poll_interval, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.Search.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to see if data is available for this data product
search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Check to see if data is available for this data product
    search request

    Returns:
        True if data is available, else False
    &#34;&#34;&#34;
    self.update_status()
    return self.completed</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.Search.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a data product search request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; None:
    &#34;&#34;&#34;
    Initiate a data product search request
    &#34;&#34;&#34;
    # do request
    url = urls.data_products_search_url
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=url,
                         body=self.query,
                         null_response=True)
    res = req.execute()

    # set request ID, request_url, executed
    self.executed = True
    if (res.status_code == 202):
        # request successfully dispatched
        self.executed = True
        self.request_url = res.request.headers[&#34;location&#34;]
        self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

    # set request variable
    self.request = res</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.Search.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the data available for this data product search request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; None:
    &#34;&#34;&#34;
    Retrieve the data available for this data product search request
    &#34;&#34;&#34;
    # check if it&#39;s completed yet
    if (self.completed is False):
        print(&#34;No data available, update status or check for data first&#34;)
        return

    # get data
    raw_data = requests_get_data(self.data_url, response_format=self.response_format)

    # set data variable
    if self.response_format is not None:
        self.data = raw_data
    else:
        # cast data source objects
        for i in range(0, len(raw_data)):
            ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
            raw_data[i][&#34;data_source&#34;] = ds

        # cast data product objects
        self.data = [DataProduct(**dp) for dp in raw_data]</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.Search.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict[~KT, ~VT]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of this data product search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong></dt>
<dd>the previously-retrieved status of this request (include
to avoid requesting it from the API again), defaults to None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self, status: Optional[Dict] = None) -&gt; None:
    &#34;&#34;&#34;
    Update the status of this data product search request

    Args:
        status: the previously-retrieved status of this request (include
            to avoid requesting it from the API again), defaults to None
    &#34;&#34;&#34;
    # get the status if it isn&#39;t passed in
    if (status is None):
        status = requests_get_status(self.request_url)

    # update request status by checking if data URI is set
    if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
        self.completed = True
        self.data_url = &#34;%s%s&#34; % (urls.base_url,
                                  status[&#34;search_result&#34;][&#34;data_uri&#34;])

    # set class variable &#34;status&#34; and &#34;logs&#34;
    self.status = status
    self.logs = status[&#34;logs&#34;]</code></pre>
</details>
</dd>
<dt id="pyaurorax.data_products.Search.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: Optional[float] = 1.0, verbose: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Block and wait for the request to complete and data is available
for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts,
defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self,
         poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
         verbose: Optional[bool] = False) -&gt; None:
    &#34;&#34;&#34;
    Block and wait for the request to complete and data is available
    for retrieval

    Args:
        poll_interval: time in seconds to wait between polling attempts,
            defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
        verbose: output poll times and other progress messages, defaults
            to False
    &#34;&#34;&#34;
    url = urls.data_products_request_url.format(self.request_id)
    self.update_status(requests_wait_for_data(url,
                                              poll_interval=poll_interval,
                                              verbose=verbose))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax" href="../index.html">pyaurorax</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyaurorax.data_products.classes" href="classes/index.html">pyaurorax.data_products.classes</a></code></li>
<li><code><a title="pyaurorax.data_products.data_products" href="data_products.html">pyaurorax.data_products.data_products</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pyaurorax.data_products.DATA_PRODUCT_TYPE_DATA_AVAILABILITY" href="#pyaurorax.data_products.DATA_PRODUCT_TYPE_DATA_AVAILABILITY">DATA_PRODUCT_TYPE_DATA_AVAILABILITY</a></code></li>
<li><code><a title="pyaurorax.data_products.DATA_PRODUCT_TYPE_KEOGRAM" href="#pyaurorax.data_products.DATA_PRODUCT_TYPE_KEOGRAM">DATA_PRODUCT_TYPE_KEOGRAM</a></code></li>
<li><code><a title="pyaurorax.data_products.DATA_PRODUCT_TYPE_MONTAGE" href="#pyaurorax.data_products.DATA_PRODUCT_TYPE_MONTAGE">DATA_PRODUCT_TYPE_MONTAGE</a></code></li>
<li><code><a title="pyaurorax.data_products.DATA_PRODUCT_TYPE_MOVIE" href="#pyaurorax.data_products.DATA_PRODUCT_TYPE_MOVIE">DATA_PRODUCT_TYPE_MOVIE</a></code></li>
<li><code><a title="pyaurorax.data_products.DATA_PRODUCT_TYPE_SUMMARY_PLOT" href="#pyaurorax.data_products.DATA_PRODUCT_TYPE_SUMMARY_PLOT">DATA_PRODUCT_TYPE_SUMMARY_PLOT</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pyaurorax.data_products.delete" href="#pyaurorax.data_products.delete">delete</a></code></li>
<li><code><a title="pyaurorax.data_products.delete_urls" href="#pyaurorax.data_products.delete_urls">delete_urls</a></code></li>
<li><code><a title="pyaurorax.data_products.describe" href="#pyaurorax.data_products.describe">describe</a></code></li>
<li><code><a title="pyaurorax.data_products.get_request_url" href="#pyaurorax.data_products.get_request_url">get_request_url</a></code></li>
<li><code><a title="pyaurorax.data_products.search" href="#pyaurorax.data_products.search">search</a></code></li>
<li><code><a title="pyaurorax.data_products.upload" href="#pyaurorax.data_products.upload">upload</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.data_products.DataProduct" href="#pyaurorax.data_products.DataProduct">DataProduct</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.data_products.DataProduct.data_product_type" href="#pyaurorax.data_products.DataProduct.data_product_type">data_product_type</a></code></li>
<li><code><a title="pyaurorax.data_products.DataProduct.data_source" href="#pyaurorax.data_products.DataProduct.data_source">data_source</a></code></li>
<li><code><a title="pyaurorax.data_products.DataProduct.end" href="#pyaurorax.data_products.DataProduct.end">end</a></code></li>
<li><code><a title="pyaurorax.data_products.DataProduct.metadata" href="#pyaurorax.data_products.DataProduct.metadata">metadata</a></code></li>
<li><code><a title="pyaurorax.data_products.DataProduct.start" href="#pyaurorax.data_products.DataProduct.start">start</a></code></li>
<li><code><a title="pyaurorax.data_products.DataProduct.to_json_serializable" href="#pyaurorax.data_products.DataProduct.to_json_serializable">to_json_serializable</a></code></li>
<li><code><a title="pyaurorax.data_products.DataProduct.url" href="#pyaurorax.data_products.DataProduct.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.data_products.Search" href="#pyaurorax.data_products.Search">Search</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.data_products.Search.cancel" href="#pyaurorax.data_products.Search.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.data_products.Search.check_for_data" href="#pyaurorax.data_products.Search.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.data_products.Search.execute" href="#pyaurorax.data_products.Search.execute">execute</a></code></li>
<li><code><a title="pyaurorax.data_products.Search.get_data" href="#pyaurorax.data_products.Search.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.data_products.Search.query" href="#pyaurorax.data_products.Search.query">query</a></code></li>
<li><code><a title="pyaurorax.data_products.Search.update_status" href="#pyaurorax.data_products.Search.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.data_products.Search.wait" href="#pyaurorax.data_products.Search.wait">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
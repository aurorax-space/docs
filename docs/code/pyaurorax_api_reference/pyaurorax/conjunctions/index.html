<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyaurorax.conjunctions API documentation</title>
<meta name="description" content="The conjunction module is used for finding conjunctions between
groupings of data sources …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.conjunctions</code></h1>
</header>
<section id="section-intro">
<p>The conjunction module is used for finding conjunctions between
groupings of data sources.</p>
<p>Note that all functions and classes from submodules are all imported
at this level of the conjunctions module. They can be referenced from
here instead of digging in deeper to the submodules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The conjunction module is used for finding conjunctions between
groupings of data sources.

Note that all functions and classes from submodules are all imported
at this level of the conjunctions module. They can be referenced from
here instead of digging in deeper to the submodules.
&#34;&#34;&#34;

# conjunction type - north b-trace
CONJUNCTION_TYPE_NBTRACE: str = &#34;nbtrace&#34;
&#34;&#34;&#34;
Conjunction search &#39;conjunction_type&#39; category for
finding conjunctions using the north B-trace data
&#34;&#34;&#34;

# conjunction type - south b-trace
CONJUNCTION_TYPE_SBTRACE: str = &#34;sbtrace&#34;
&#34;&#34;&#34;
Conjunction search &#39;conjunction_type&#39; category for
finding conjunctions using the south B-trace data
&#34;&#34;&#34;

# function and class imports
from .conjunctions import (search,
                           describe,
                           get_request_url)
from .swarmaurora import __all__ as swarmaurora_all
from .classes.conjunction import Conjunction
from .classes.search import Search

# pdoc imports and exports
from .conjunctions import __pdoc__ as __conjunctions_pdoc__
from .classes.conjunction import __pdoc__ as __classes_conjunctions_pdoc__
from .classes.search import __pdoc__ as __classes_search_pdoc__
__pdoc__ = __conjunctions_pdoc__
__pdoc__ = dict(__pdoc__, **__classes_conjunctions_pdoc__)
__pdoc__ = dict(__pdoc__, **__classes_search_pdoc__)
__all__ = [
    &#34;CONJUNCTION_TYPE_NBTRACE&#34;,
    &#34;CONJUNCTION_TYPE_SBTRACE&#34;,
    &#34;search&#34;,
    &#34;describe&#34;,
    &#34;get_request_url&#34;,
    &#34;Conjunction&#34;,
    &#34;Search&#34;,
    &#34;swarmaurora_all&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyaurorax.conjunctions.classes" href="classes/index.html">pyaurorax.conjunctions.classes</a></code></dt>
<dd>
<div class="desc"><p>Separted classes and functions used by the conjunctions module …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.conjunctions.conjunctions" href="conjunctions.html">pyaurorax.conjunctions.conjunctions</a></code></dt>
<dd>
<div class="desc"><p>Functions for performing conjunction searches</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.conjunctions.swarmaurora" href="swarmaurora/index.html">pyaurorax.conjunctions.swarmaurora</a></code></dt>
<dd>
<div class="desc"><p>Interact with Swarm-Aurora using conjunction searches from AuroraX</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pyaurorax.conjunctions.CONJUNCTION_TYPE_NBTRACE"><code class="name">var <span class="ident">CONJUNCTION_TYPE_NBTRACE</span> : str</code></dt>
<dd>
<div class="desc"><p>Conjunction search 'conjunction_type' category for
finding conjunctions using the north B-trace data</p></div>
</dd>
<dt id="pyaurorax.conjunctions.CONJUNCTION_TYPE_SBTRACE"><code class="name">var <span class="ident">CONJUNCTION_TYPE_SBTRACE</span> : str</code></dt>
<dd>
<div class="desc"><p>Conjunction search 'conjunction_type' category for
finding conjunctions using the south B-trace data</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyaurorax.conjunctions.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>search_obj: <a title="pyaurorax.conjunctions.classes.search.Search" href="classes/search.html#pyaurorax.conjunctions.classes.search.Search">Search</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Describe a conjunction search as an "SQL-like" string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>search_obj</code></strong></dt>
<dd>the conjunction search to describe</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the "SQL-like" string describing the conjunction search object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(search_obj: Search) -&gt; str:
    &#34;&#34;&#34;
    Describe a conjunction search as an &#34;SQL-like&#34; string

    Args:
        search_obj: the conjunction search to describe

    Returns:
        the &#34;SQL-like&#34; string describing the conjunction search object
    &#34;&#34;&#34;
    # make request
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=urls.describe_conjunction_query_url,
                         body=search_obj.query)
    res = req.execute()

    # return
    return res.data</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.get_request_url"><code class="name flex">
<span>def <span class="ident">get_request_url</span></span>(<span>request_id: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the conjunction search request URL for a given
request ID. This URL can be used for subsequent
pyaurorax.requests function calls. Primarily this method
facilitates delving into details about a set of already-submitted
conjunction searches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_id</code></strong></dt>
<dd>the request identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the request URL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_request_url(request_id: str) -&gt; str:
    &#34;&#34;&#34;
    Get the conjunction search request URL for a given
    request ID. This URL can be used for subsequent
    pyaurorax.requests function calls. Primarily this method
    facilitates delving into details about a set of already-submitted
    conjunction searches.

    Args:
        request_id: the request identifier

    Returns:
        the request URL
    &#34;&#34;&#34;
    url = urls.conjunction_request_url.format(request_id)
    return url</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>start: datetime.datetime, end: datetime.datetime, distance: Union[int, float, Dict[str, Union[int, float]]], ground: Optional[List[Dict[str, str]]] = [], space: Optional[List[Dict[str, str]]] = [], events: Optional[List[Dict[str, str]]] = [], conjunction_types: Optional[List[str]] = [], epoch_search_precision: Optional[int] = 60, response_format: Optional[Dict[str, bool]] = None, poll_interval: Optional[float] = 1.0, return_immediately: Optional[bool] = False, verbose: Optional[bool] = False) ‑> <a title="pyaurorax.conjunctions.classes.search.Search" href="classes/search.html#pyaurorax.conjunctions.classes.search.Search">Search</a></span>
</code></dt>
<dd>
<div class="desc"><p>Search for conjunctions between data sources</p>
<p>By default, this function will block and wait until the request completes and
all data is downloaded. If you don't want to wait, set the 'return_immediately`
value to True. The Search object will be returned right after the search has been
started, and you can use the helper functions as part of that object to get the
data when it's done.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>the maximum distance allowed between data sources when searching for
conjunctions. This can either be a number (int or float), or a dictionary
modified from the output of the "get_advanced_distances_combos()" function.</dd>
<dt><strong><code>ground</code></strong></dt>
<dd>
<p>list of ground instrument search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": ["themis-asi"],
    "platforms": ["gillam", "rabbit lake"],
    "instrument_types": ["RGB"],
    "ephemeris_metadata_filters": {
        "logical_operator": "AND",
        "expressions": [
            {
                "key": "calgary_apa_ml_v1",
                "operator": "in",
                "values": [ "classified as APA" ]
            }
        ]
    }
}]
</code></pre>
</dd>
<dt><strong><code>space</code></strong></dt>
<dd>
<p>list of one or more space instrument search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": ["themis-asi", "swarm"],
    "platforms": ["themisa", "swarma"],
    "instrument_types": ["footprint"],
    "ephemeris_metadata_filters": {
        "logical_operator": "AND",
        "expressions": [
            {
                "key": "nbtrace_region",
                "operator": "in",
                "values": [ "north auroral oval" ]
            }
        ]
    },
    "hemisphere": [
        "northern"
    ]
}]
</code></pre>
</dd>
<dt><strong><code>events</code></strong></dt>
<dd>
<p>list of one or more events search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": [ "events" ],
    "instrument_types": [ "substorm onsets" ]
}]
</code></pre>
</dd>
<dt><strong><code>conjunction_types</code></strong></dt>
<dd>list of conjunction types, defaults to [] (meaning all conjunction
types). Options are in the pyaurorax.conjunctions module, or at the top level using
the pyaurorax.CONJUNCTION_TYPE_* variables.</dd>
<dt><strong><code>epoch_search_precision</code></strong></dt>
<dd>the time precision to which conjunctions are calculated. Can be
30 or 60 seconds. Defaults to 60 seconds. Note - this parameter is under active
development and still considered "alpha".</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>seconds to wait between polling calls, defaults to
pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>return_immediately</code></strong></dt>
<dd>initiate the search and return without waiting for data to
be received, defaults to False</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>show the progress of the request using the request log, defaults</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a pyaurorax.conjunctions.Search object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(start: datetime.datetime,
           end: datetime.datetime,
           distance: Union[int, float, Dict[str, Union[int, float]]],
           ground: Optional[List[Dict[str, str]]] = [],
           space: Optional[List[Dict[str, str]]] = [],
           events: Optional[List[Dict[str, str]]] = [],
           conjunction_types: Optional[List[str]] = [],
           epoch_search_precision: Optional[int] = 60,
           response_format: Optional[Dict[str, bool]] = None,
           poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
           return_immediately: Optional[bool] = False,
           verbose: Optional[bool] = False) -&gt; Search:
    &#34;&#34;&#34;
    Search for conjunctions between data sources

    By default, this function will block and wait until the request completes and
    all data is downloaded. If you don&#39;t want to wait, set the &#39;return_immediately`
    value to True. The Search object will be returned right after the search has been
    started, and you can use the helper functions as part of that object to get the
    data when it&#39;s done.

    Args:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        distance: the maximum distance allowed between data sources when searching for
            conjunctions. This can either be a number (int or float), or a dictionary
            modified from the output of the &#34;get_advanced_distances_combos()&#34; function.
        ground: list of ground instrument search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [&#34;themis-asi&#34;],
                    &#34;platforms&#34;: [&#34;gillam&#34;, &#34;rabbit lake&#34;],
                    &#34;instrument_types&#34;: [&#34;RGB&#34;],
                    &#34;ephemeris_metadata_filters&#34;: {
                        &#34;logical_operator&#34;: &#34;AND&#34;,
                        &#34;expressions&#34;: [
                            {
                                &#34;key&#34;: &#34;calgary_apa_ml_v1&#34;,
                                &#34;operator&#34;: &#34;in&#34;,
                                &#34;values&#34;: [ &#34;classified as APA&#34; ]
                            }
                        ]
                    }
                }]
        space: list of one or more space instrument search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [&#34;themis-asi&#34;, &#34;swarm&#34;],
                    &#34;platforms&#34;: [&#34;themisa&#34;, &#34;swarma&#34;],
                    &#34;instrument_types&#34;: [&#34;footprint&#34;],
                    &#34;ephemeris_metadata_filters&#34;: {
                        &#34;logical_operator&#34;: &#34;AND&#34;,
                        &#34;expressions&#34;: [
                            {
                                &#34;key&#34;: &#34;nbtrace_region&#34;,
                                &#34;operator&#34;: &#34;in&#34;,
                                &#34;values&#34;: [ &#34;north auroral oval&#34; ]
                            }
                        ]
                    },
                    &#34;hemisphere&#34;: [
                        &#34;northern&#34;
                    ]
                }]
        events: list of one or more events search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [ &#34;events&#34; ],
                    &#34;instrument_types&#34;: [ &#34;substorm onsets&#34; ]
                }]
        conjunction_types: list of conjunction types, defaults to [] (meaning all conjunction
            types). Options are in the pyaurorax.conjunctions module, or at the top level using
            the pyaurorax.CONJUNCTION_TYPE_* variables.
        epoch_search_precision: the time precision to which conjunctions are calculated. Can be
            30 or 60 seconds. Defaults to 60 seconds. Note - this parameter is under active
            development and still considered &#34;alpha&#34;.
        response_format: JSON representation of desired data response format
        poll_interval: seconds to wait between polling calls, defaults to
            pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
        return_immediately: initiate the search and return without waiting for data to
            be received, defaults to False
        verbose: show the progress of the request using the request log, defaults

    Returns:
        a pyaurorax.conjunctions.Search object
    &#34;&#34;&#34;
    # create a Search object
    s = Search(start,
               end,
               distance,
               ground=ground,
               space=space,
               events=events,
               conjunction_types=conjunction_types,
               epoch_search_precision=epoch_search_precision,
               response_format=response_format)
    if (verbose is True):
        print(f&#34;[{datetime.datetime.now()}] Search object created&#34;)

    # execute the search
    s.execute()
    if (verbose is True):
        print(&#34;[%s] Request submitted&#34; % (datetime.datetime.now()))
        print(&#34;[%s] Request ID: %s&#34; % (datetime.datetime.now(), s.request_id))
        print(&#34;[%s] Request details available at: %s&#34; % (datetime.datetime.now(),
                                                         s.request_url))

    # return immediately if we wanted to
    if (return_immediately is True):
        return s

    # wait for data
    if (verbose is True):
        print(&#34;[%s] Waiting for data ...&#34; % (datetime.datetime.now()))
    s.wait(poll_interval=poll_interval, verbose=verbose)

    # check if error condition encountered
    if (s.status[&#34;search_result&#34;][&#34;error_condition&#34;] is True):
        # error encountered
        raise AuroraXSearchException(s.logs[-1][&#34;summary&#34;])

    # get the data
    if (verbose is True):
        print(&#34;[%s] Retrieving data ...&#34; % (datetime.datetime.now()))
    s.get_data()

    # return response with the data
    if (verbose is True):
        print(&#34;[%s] Retrieved %s of data containing %d records&#34; % (datetime.datetime.now(),
                                                                   humanize.filesize.naturalsize(
                                                                       s.status[&#34;search_result&#34;][&#34;file_size&#34;]),
                                                                   s.status[&#34;search_result&#34;][&#34;result_count&#34;]))

    # return
    return s</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.conjunctions.Conjunction"><code class="flex name class">
<span>class <span class="ident">Conjunction</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Conjunction object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>conjunction_type</code></strong></dt>
<dd>the type of location data used when the
conjunction was found (either be 'nbtrace' or 'sbtrace')</dd>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the conjunction</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the conjunction</dd>
<dt><strong><code>data_sources</code></strong></dt>
<dd>data sources in the conjunction</dd>
<dt><strong><code>min_distance</code></strong></dt>
<dd>minimum kilometer distance of the conjunction</dd>
<dt><strong><code>max_distance</code></strong></dt>
<dd>maximum kilometer distance of the conjunction</dd>
<dt><strong><code>events</code></strong></dt>
<dd>the sub-conjunctions that make up this over-arching
conjunction (the conjunctions between each set of two data
sources)</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conjunction(BaseModel):
    &#34;&#34;&#34;
    Conjunction object

    Attributes:
        conjunction_type: the type of location data used when the
            conjunction was found (either be &#39;nbtrace&#39; or &#39;sbtrace&#39;)
        start: start timestamp of the conjunction
        end: end timestamp of the conjunction
        data_sources: data sources in the conjunction
        min_distance: minimum kilometer distance of the conjunction
        max_distance: maximum kilometer distance of the conjunction
        events: the sub-conjunctions that make up this over-arching
            conjunction (the conjunctions between each set of two data
            sources)
    &#34;&#34;&#34;
    conjunction_type: str
    start: datetime.datetime
    end: datetime.datetime
    data_sources: List[DataSource]
    min_distance: float
    max_distance: float
    events: List[Dict]

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        String method

        Returns:
            string format of Conjunction object
        &#34;&#34;&#34;
        return self.__repr__()

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Object representation

        Returns:
            object representation of Conjunction object
        &#34;&#34;&#34;
        return f&#34;Conjunction(start={repr(self.start)}, end={repr(self.end)}, &#34; \
            f&#34;min_distance={self.min_distance:.2f}, max_distance={self.max_distance:.2f}, &#34; \
            &#34;data_sources=[...], events=[...])&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.conjunctions.Conjunction.conjunction_type"><code class="name">var <span class="ident">conjunction_type</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.conjunctions.Conjunction.data_sources"><code class="name">var <span class="ident">data_sources</span> : List[<a title="pyaurorax.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.sources.classes.data_source.DataSource">DataSource</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.conjunctions.Conjunction.end"><code class="name">var <span class="ident">end</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.conjunctions.Conjunction.events"><code class="name">var <span class="ident">events</span> : List[Dict]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.conjunctions.Conjunction.max_distance"><code class="name">var <span class="ident">max_distance</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.conjunctions.Conjunction.min_distance"><code class="name">var <span class="ident">min_distance</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.conjunctions.Conjunction.start"><code class="name">var <span class="ident">start</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.conjunctions.Search"><code class="flex name class">
<span>class <span class="ident">Search</span></span>
<span>(</span><span>start: datetime.datetime, end: datetime.datetime, distance: Union[int, float, Dict[str, Union[int, float]]], ground: Optional[List[Dict[str, str]]] = [], space: Optional[List[Dict[str, str]]] = [], events: Optional[List[Dict[str, str]]] = [], conjunction_types: Optional[List[str]] = ['nbtrace'], epoch_search_precision: Optional[int] = 60, response_format: Optional[Dict[str, bool]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a conjunction search</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>the maximum distance allowed between data sources when searching for
conjunctions. This can either be a number (int or float), or a dictionary
modified from the output of the "get_advanced_distances_combos()" function.</dd>
<dt><strong><code>ground</code></strong></dt>
<dd>
<p>list of ground instrument search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": ["themis-asi"],
    "platforms": ["gillam", "rabbit lake"],
    "instrument_types": ["RGB"],
    "ephemeris_metadata_filters": {
        "logical_operator": "AND",
        "expressions": [
            {
                "key": "calgary_apa_ml_v1",
                "operator": "in",
                "values": [ "classified as APA" ]
            }
        ]
    }
}]
</code></pre>
</dd>
<dt><strong><code>space</code></strong></dt>
<dd>
<p>list of one or more space instrument search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": ["themis-asi", "swarm"],
    "platforms": ["themisa", "swarma"],
    "instrument_types": ["footprint"],
    "ephemeris_metadata_filters": {
        "logical_operator": "AND",
        "expressions": [
            {
                "key": "nbtrace_region",
                "operator": "in",
                "values": [ "north auroral oval" ]
            }
        ]
    },
    "hemisphere": [
        "northern"
    ]
}]
</code></pre>
</dd>
<dt><strong><code>events</code></strong></dt>
<dd>
<p>list of one or more events search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": [ "events" ],
    "instrument_types": [ "substorm onsets" ]
}]
</code></pre>
</dd>
<dt><strong><code>conjunction_types</code></strong></dt>
<dd>list of conjunction types, defaults to ["nbtrace"]. Options are
in the pyaurorax.conjunctions module, or at the top level using the
pyaurorax.CONJUNCTION_TYPE_* variables.</dd>
<dt><strong><code>epoch_search_precision</code></strong></dt>
<dd>the time precision to which conjunctions are calculated. Can be
30 or 60 seconds. Defaults to 60 seconds. Note - this parameter is under active
development and still considered "alpha".</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong></dt>
<dd>unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong></dt>
<dd>unique URL assigned to the request by the AuroraX API</dd>
<dt><strong><code>executed</code></strong></dt>
<dd>indicates if the search has been executed/started</dd>
<dt><strong><code>completed</code></strong></dt>
<dd>indicates if the search has finished</dd>
<dt><strong><code>data_url</code></strong></dt>
<dd>the URL where data is accessed</dd>
<dt><strong><code>query</code></strong></dt>
<dd>the query for this request as JSON</dd>
<dt><strong><code>status</code></strong></dt>
<dd>the status of the query</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the conjunctions found</dd>
<dt><strong><code>logs</code></strong></dt>
<dd>all log messages outputed by the AuroraX API for this request</dd>
</dl>
<p>Returns:
a pyaurorax.conjunctions.Search object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Search():
    &#34;&#34;&#34;
    Class representing a conjunction search

    Attributes:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        distance: the maximum distance allowed between data sources when searching for
            conjunctions. This can either be a number (int or float), or a dictionary
            modified from the output of the &#34;get_advanced_distances_combos()&#34; function.
        ground: list of ground instrument search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [&#34;themis-asi&#34;],
                    &#34;platforms&#34;: [&#34;gillam&#34;, &#34;rabbit lake&#34;],
                    &#34;instrument_types&#34;: [&#34;RGB&#34;],
                    &#34;ephemeris_metadata_filters&#34;: {
                        &#34;logical_operator&#34;: &#34;AND&#34;,
                        &#34;expressions&#34;: [
                            {
                                &#34;key&#34;: &#34;calgary_apa_ml_v1&#34;,
                                &#34;operator&#34;: &#34;in&#34;,
                                &#34;values&#34;: [ &#34;classified as APA&#34; ]
                            }
                        ]
                    }
                }]
        space: list of one or more space instrument search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [&#34;themis-asi&#34;, &#34;swarm&#34;],
                    &#34;platforms&#34;: [&#34;themisa&#34;, &#34;swarma&#34;],
                    &#34;instrument_types&#34;: [&#34;footprint&#34;],
                    &#34;ephemeris_metadata_filters&#34;: {
                        &#34;logical_operator&#34;: &#34;AND&#34;,
                        &#34;expressions&#34;: [
                            {
                                &#34;key&#34;: &#34;nbtrace_region&#34;,
                                &#34;operator&#34;: &#34;in&#34;,
                                &#34;values&#34;: [ &#34;north auroral oval&#34; ]
                            }
                        ]
                    },
                    &#34;hemisphere&#34;: [
                        &#34;northern&#34;
                    ]
                }]
        events: list of one or more events search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [ &#34;events&#34; ],
                    &#34;instrument_types&#34;: [ &#34;substorm onsets&#34; ]
                }]
        conjunction_types: list of conjunction types, defaults to [&#34;nbtrace&#34;]. Options are
            in the pyaurorax.conjunctions module, or at the top level using the
            pyaurorax.CONJUNCTION_TYPE_* variables.
        epoch_search_precision: the time precision to which conjunctions are calculated. Can be
            30 or 60 seconds. Defaults to 60 seconds. Note - this parameter is under active
            development and still considered &#34;alpha&#34;.
        response_format: JSON representation of desired data response format
        request: AuroraXResponse object returned when the search is executed
        request_id: unique ID assigned to the request by the AuroraX API
        request_url: unique URL assigned to the request by the AuroraX API
        executed: indicates if the search has been executed/started
        completed: indicates if the search has finished
        data_url: the URL where data is accessed
        query: the query for this request as JSON
        status: the status of the query
        data: the conjunctions found
        logs: all log messages outputed by the AuroraX API for this request

        Returns:
            a pyaurorax.conjunctions.Search object
    &#34;&#34;&#34;

    def __init__(self, start: datetime.datetime,
                 end: datetime.datetime,
                 distance: Union[int, float, Dict[str, Union[int, float]]],
                 ground: Optional[List[Dict[str, str]]] = [],
                 space: Optional[List[Dict[str, str]]] = [],
                 events: Optional[List[Dict[str, str]]] = [],
                 conjunction_types: Optional[List[str]] = [CONJUNCTION_TYPE_NBTRACE],
                 epoch_search_precision: Optional[int] = 60,
                 response_format: Optional[Dict[str, bool]] = None):

        # set variables using passed in args
        self.start = start
        self.end = end
        self.ground = ground
        self.space = space
        self.events = events
        self.distance = distance
        self.conjunction_types = conjunction_types
        self.epoch_search_precision = epoch_search_precision
        self.response_format = response_format

        # initialize additional variables
        self.request: AuroraXResponse = None
        self.request_id: str = &#34;&#34;
        self.request_url: str = &#34;&#34;
        self.executed: bool = False
        self.completed: bool = False
        self.data_url: str = &#34;&#34;
        self.query: Dict = {}
        self.status: Dict = {}
        self.data: List[Union[Conjunction, Dict]] = []
        self.logs: List[Dict] = []

    def __str__(self):
        &#34;&#34;&#34;
        String method

        Returns:
            string format of Conjunction Search object
        &#34;&#34;&#34;
        return self.__repr__()

    def __repr__(self):
        &#34;&#34;&#34;
        Object representation

        Returns:
            object representation of Conjunction Search object
        &#34;&#34;&#34;
        return f&#34;ConjunctionSearch(executed={self.executed}, &#34; \
            f&#34;completed={self.completed}, request_id=&#39;{self.request_id}&#39;)&#34;

    def check_criteria_block_count_validity(self) -&gt; None:
        &#34;&#34;&#34;
        Check the number of of criteria blocks to see if there
        is too many. A max of 10 is allowed by the AuroraX
        conjunction search engine. An exception is raised if
        it was determined to have too many.

        Raises:
            pyaurorax.exceptions.AuroraXBadParametersException: too many criteria blocks are found
        &#34;&#34;&#34;
        if ((len(self.ground) + len(self.space) + len(self.events)) &gt; 10):
            raise AuroraXBadParametersException(&#34;Number of criteria blocks exceeds 10, &#34;
                                                &#34;please reduce the count&#34;)

    def get_advanced_distances_combos(self, default_distance: Union[int, float] = None) -&gt; Dict:
        &#34;&#34;&#34;
        Get the advanced distances combinations for this search

        Args:
            default_distance: the default distance to use, defaults to None

        Returns:
            the advanced distances combinations
        &#34;&#34;&#34;
        # set input arrays
        options = []
        for i in range(0, len(self.ground)):
            options.append(&#34;ground%d&#34; % (i + 1))
        for i in range(0, len(self.space)):
            options.append(&#34;space%d&#34; % (i + 1))
        for i in range(0, len(self.events)):
            options.append(&#34;events%d&#34; % (i + 1))

        # derive all combinations of options of size 2
        combinations = {}
        for element in itertools.combinations(options, r=2):
            combinations[&#34;%s-%s&#34; % (element[0], element[1])] = default_distance

        # return
        return combinations

    def __fill_in_missing_distances(self, curr_distances: Dict) -&gt; Dict:
        # get all distances possible
        all_distances = self.get_advanced_distances_combos()

        # go through current distances and fill in the values
        for curr_key, curr_value in curr_distances.items():
            curr_key_split = curr_key.split(&#39;-&#39;)
            curr_key1 = curr_key_split[0].strip()
            curr_key2 = curr_key_split[1].strip()
            for all_key in all_distances.keys():
                if (curr_key1 in all_key and curr_key2 in all_key):
                    # found the matching key, replace the value
                    all_distances[all_key] = curr_value

        # return
        return all_distances

    @property
    def distance(self) -&gt; Union[int, float, Dict[str, Union[int, float]]]:
        &#34;&#34;&#34;
        Property for the distance parameter

        Returns:
            the distance dictionary with all combinations
        &#34;&#34;&#34;
        return self._distance

    @distance.setter
    def distance(self, distance: Union[int, float, Dict[str, Union[int, float]]]) -&gt; None:
        # set distances to a dict if it&#39;s an int or float
        if (type(distance) is int or type(distance) is float):
            self._distance = self.get_advanced_distances_combos(default_distance=distance)  # type: ignore
        else:
            # is a dict, fill in any gaps
            self._distance = self.__fill_in_missing_distances(distance)  # type: ignore

    @property
    def query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Property for the query value

        Returns:
            the query parameter
        &#34;&#34;&#34;
        self._query = {
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;ground&#34;: self.ground,
            &#34;space&#34;: self.space,
            &#34;events&#34;: self.events,
            &#34;conjunction_types&#34;: self.conjunction_types,
            &#34;max_distances&#34;: self.distance,
            &#34;epoch_search_precision&#34;: self.epoch_search_precision if self.epoch_search_precision in [30, 60] else 60,
        }
        return self._query

    @query.setter
    def query(self, query: Dict) -&gt; None:
        self._query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate a conjunction search request

        Raises:
            pyaurorax.exceptions.AuroraXBadParametersException: too many criteria blocks
        &#34;&#34;&#34;
        # check number of criteria blocks
        self.check_criteria_block_count_validity()

        # do request
        url = urls.conjunction_search_url
        req = AuroraXRequest(method=&#34;post&#34;,
                             url=url,
                             body=self.query,
                             null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if res.status_code == 202:
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this conjunction search request

        Args:
            status: the previously-retrieved status of this request (include
                to avoid requesting it from the API again), defaults to None
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.request_url)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = f&#39;{urls.base_url}{status[&#34;search_result&#34;][&#34;data_uri&#34;]}&#39;

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this conjunction
        search request

        Returns:
            True if data is available, else False
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this conjunction search request
        &#34;&#34;&#34;
        # check if request is completed
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.data_url, response_format=self.response_format)

        # set data variable
        if (self.response_format is not None):
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                for j in range(0, len(raw_data[i][&#34;data_sources&#34;])):
                    ds = DataSource(**raw_data[i][&#34;data_sources&#34;][j], format=FORMAT_BASIC_INFO)
                    raw_data[i][&#34;data_sources&#34;][j] = ds

            # cast conjunctions
            self.data = [Conjunction(**c) for c in raw_data]

    def wait(self,
             poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
             verbose: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait until the request is complete and data is
        available for retrieval

        Args:
            poll_interval: time in seconds to wait between polling attempts, defaults
                to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
            verbose: output poll times and other progress messages, defaults to False
        &#34;&#34;&#34;
        url = urls.conjunction_request_url.format(self.request_id)
        self.update_status(requests_wait_for_data(url,
                                                  poll_interval=poll_interval,
                                                  verbose=verbose))

    def cancel(self,
               wait: Optional[bool] = False,
               poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
               verbose: Optional[bool] = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the conjunction search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait: wait until the cancellation request has been
                completed (may wait for several minutes)
            poll_interval: seconds to wait between polling
                calls, defaults to STANDARD_POLLING_SLEEP_TIME.
            verbose: output poll times and other progress messages, defaults
                to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
            pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
        &#34;&#34;&#34;
        url = urls.conjunction_request_url.format(self.request_id)
        return requests_cancel(url, wait=wait, poll_interval=poll_interval, verbose=verbose)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.conjunctions.Search.distance"><code class="name">var <span class="ident">distance</span> : Union[int, float, Dict[str, Union[int, float]]]</code></dt>
<dd>
<div class="desc"><p>Property for the distance parameter</p>
<h2 id="returns">Returns</h2>
<p>the distance dictionary with all combinations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def distance(self) -&gt; Union[int, float, Dict[str, Union[int, float]]]:
    &#34;&#34;&#34;
    Property for the distance parameter

    Returns:
        the distance dictionary with all combinations
    &#34;&#34;&#34;
    return self._distance</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.Search.query"><code class="name">var <span class="ident">query</span> : Dict</code></dt>
<dd>
<div class="desc"><p>Property for the query value</p>
<h2 id="returns">Returns</h2>
<p>the query parameter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self) -&gt; Dict:
    &#34;&#34;&#34;
    Property for the query value

    Returns:
        the query parameter
    &#34;&#34;&#34;
    self._query = {
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;ground&#34;: self.ground,
        &#34;space&#34;: self.space,
        &#34;events&#34;: self.events,
        &#34;conjunction_types&#34;: self.conjunction_types,
        &#34;max_distances&#34;: self.distance,
        &#34;epoch_search_precision&#34;: self.epoch_search_precision if self.epoch_search_precision in [30, 60] else 60,
    }
    return self._query</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.conjunctions.Search.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: Optional[bool] = False, poll_interval: Optional[float] = 1.0, verbose: Optional[bool] = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel the conjunction search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong></dt>
<dd>wait until the cancellation request has been
completed (may wait for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>seconds to wait between polling
calls, defaults to STANDARD_POLLING_SLEEP_TIME.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedException">AuroraXUnauthorizedException</a></code></dt>
<dd>invalid API key for this operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self,
           wait: Optional[bool] = False,
           poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
           verbose: Optional[bool] = False) -&gt; int:
    &#34;&#34;&#34;
    Cancel the conjunction search request

    This method returns immediately by default since the API processes
    this request asynchronously. If you would prefer to wait for it
    to be completed, set the &#39;wait&#39; parameter to True. You can adjust
    the polling time using the &#39;poll_interval&#39; parameter.

    Args:
        wait: wait until the cancellation request has been
            completed (may wait for several minutes)
        poll_interval: seconds to wait between polling
            calls, defaults to STANDARD_POLLING_SLEEP_TIME.
        verbose: output poll times and other progress messages, defaults
            to False

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
        pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
    &#34;&#34;&#34;
    url = urls.conjunction_request_url.format(self.request_id)
    return requests_cancel(url, wait=wait, poll_interval=poll_interval, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.Search.check_criteria_block_count_validity"><code class="name flex">
<span>def <span class="ident">check_criteria_block_count_validity</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check the number of of criteria blocks to see if there
is too many. A max of 10 is allowed by the AuroraX
conjunction search engine. An exception is raised if
it was determined to have too many.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>too many criteria blocks are found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_criteria_block_count_validity(self) -&gt; None:
    &#34;&#34;&#34;
    Check the number of of criteria blocks to see if there
    is too many. A max of 10 is allowed by the AuroraX
    conjunction search engine. An exception is raised if
    it was determined to have too many.

    Raises:
        pyaurorax.exceptions.AuroraXBadParametersException: too many criteria blocks are found
    &#34;&#34;&#34;
    if ((len(self.ground) + len(self.space) + len(self.events)) &gt; 10):
        raise AuroraXBadParametersException(&#34;Number of criteria blocks exceeds 10, &#34;
                                            &#34;please reduce the count&#34;)</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.Search.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to see if data is available for this conjunction
search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Check to see if data is available for this conjunction
    search request

    Returns:
        True if data is available, else False
    &#34;&#34;&#34;
    self.update_status()
    return self.completed</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.Search.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a conjunction search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>too many criteria blocks</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; None:
    &#34;&#34;&#34;
    Initiate a conjunction search request

    Raises:
        pyaurorax.exceptions.AuroraXBadParametersException: too many criteria blocks
    &#34;&#34;&#34;
    # check number of criteria blocks
    self.check_criteria_block_count_validity()

    # do request
    url = urls.conjunction_search_url
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=url,
                         body=self.query,
                         null_response=True)
    res = req.execute()

    # set request ID, request_url, executed
    self.executed = True
    if res.status_code == 202:
        # request successfully dispatched
        self.executed = True
        self.request_url = res.request.headers[&#34;location&#34;]
        self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

    # set request variable
    self.request = res</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.Search.get_advanced_distances_combos"><code class="name flex">
<span>def <span class="ident">get_advanced_distances_combos</span></span>(<span>self, default_distance: Union[int, float] = None) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get the advanced distances combinations for this search</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default_distance</code></strong></dt>
<dd>the default distance to use, defaults to None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the advanced distances combinations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_advanced_distances_combos(self, default_distance: Union[int, float] = None) -&gt; Dict:
    &#34;&#34;&#34;
    Get the advanced distances combinations for this search

    Args:
        default_distance: the default distance to use, defaults to None

    Returns:
        the advanced distances combinations
    &#34;&#34;&#34;
    # set input arrays
    options = []
    for i in range(0, len(self.ground)):
        options.append(&#34;ground%d&#34; % (i + 1))
    for i in range(0, len(self.space)):
        options.append(&#34;space%d&#34; % (i + 1))
    for i in range(0, len(self.events)):
        options.append(&#34;events%d&#34; % (i + 1))

    # derive all combinations of options of size 2
    combinations = {}
    for element in itertools.combinations(options, r=2):
        combinations[&#34;%s-%s&#34; % (element[0], element[1])] = default_distance

    # return
    return combinations</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.Search.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the data available for this conjunction search request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; None:
    &#34;&#34;&#34;
    Retrieve the data available for this conjunction search request
    &#34;&#34;&#34;
    # check if request is completed
    if (self.completed is False):
        print(&#34;No data available, update status or check for data first&#34;)
        return

    # get data
    raw_data = requests_get_data(self.data_url, response_format=self.response_format)

    # set data variable
    if (self.response_format is not None):
        self.data = raw_data
    else:
        # cast data source objects
        for i in range(0, len(raw_data)):
            for j in range(0, len(raw_data[i][&#34;data_sources&#34;])):
                ds = DataSource(**raw_data[i][&#34;data_sources&#34;][j], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_sources&#34;][j] = ds

        # cast conjunctions
        self.data = [Conjunction(**c) for c in raw_data]</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.Search.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of this conjunction search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong></dt>
<dd>the previously-retrieved status of this request (include
to avoid requesting it from the API again), defaults to None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self, status: Optional[Dict] = None) -&gt; None:
    &#34;&#34;&#34;
    Update the status of this conjunction search request

    Args:
        status: the previously-retrieved status of this request (include
            to avoid requesting it from the API again), defaults to None
    &#34;&#34;&#34;
    # get the status if it isn&#39;t passed in
    if (status is None):
        status = requests_get_status(self.request_url)

    # update request status by checking if data URI is set
    if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
        self.completed = True
        self.data_url = f&#39;{urls.base_url}{status[&#34;search_result&#34;][&#34;data_uri&#34;]}&#39;

    # set class variable &#34;status&#34; and &#34;logs&#34;
    self.status = status
    self.logs = status[&#34;logs&#34;]</code></pre>
</details>
</dd>
<dt id="pyaurorax.conjunctions.Search.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: Optional[float] = 1.0, verbose: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Block and wait until the request is complete and data is
available for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts, defaults
to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults to False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self,
         poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
         verbose: Optional[bool] = False) -&gt; None:
    &#34;&#34;&#34;
    Block and wait until the request is complete and data is
    available for retrieval

    Args:
        poll_interval: time in seconds to wait between polling attempts, defaults
            to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
        verbose: output poll times and other progress messages, defaults to False
    &#34;&#34;&#34;
    url = urls.conjunction_request_url.format(self.request_id)
    self.update_status(requests_wait_for_data(url,
                                              poll_interval=poll_interval,
                                              verbose=verbose))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax" href="../index.html">pyaurorax</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyaurorax.conjunctions.classes" href="classes/index.html">pyaurorax.conjunctions.classes</a></code></li>
<li><code><a title="pyaurorax.conjunctions.conjunctions" href="conjunctions.html">pyaurorax.conjunctions.conjunctions</a></code></li>
<li><code><a title="pyaurorax.conjunctions.swarmaurora" href="swarmaurora/index.html">pyaurorax.conjunctions.swarmaurora</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pyaurorax.conjunctions.CONJUNCTION_TYPE_NBTRACE" href="#pyaurorax.conjunctions.CONJUNCTION_TYPE_NBTRACE">CONJUNCTION_TYPE_NBTRACE</a></code></li>
<li><code><a title="pyaurorax.conjunctions.CONJUNCTION_TYPE_SBTRACE" href="#pyaurorax.conjunctions.CONJUNCTION_TYPE_SBTRACE">CONJUNCTION_TYPE_SBTRACE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyaurorax.conjunctions.describe" href="#pyaurorax.conjunctions.describe">describe</a></code></li>
<li><code><a title="pyaurorax.conjunctions.get_request_url" href="#pyaurorax.conjunctions.get_request_url">get_request_url</a></code></li>
<li><code><a title="pyaurorax.conjunctions.search" href="#pyaurorax.conjunctions.search">search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.conjunctions.Conjunction" href="#pyaurorax.conjunctions.Conjunction">Conjunction</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.conjunctions.Conjunction.conjunction_type" href="#pyaurorax.conjunctions.Conjunction.conjunction_type">conjunction_type</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Conjunction.data_sources" href="#pyaurorax.conjunctions.Conjunction.data_sources">data_sources</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Conjunction.end" href="#pyaurorax.conjunctions.Conjunction.end">end</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Conjunction.events" href="#pyaurorax.conjunctions.Conjunction.events">events</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Conjunction.max_distance" href="#pyaurorax.conjunctions.Conjunction.max_distance">max_distance</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Conjunction.min_distance" href="#pyaurorax.conjunctions.Conjunction.min_distance">min_distance</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Conjunction.start" href="#pyaurorax.conjunctions.Conjunction.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.conjunctions.Search" href="#pyaurorax.conjunctions.Search">Search</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.conjunctions.Search.cancel" href="#pyaurorax.conjunctions.Search.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.check_criteria_block_count_validity" href="#pyaurorax.conjunctions.Search.check_criteria_block_count_validity">check_criteria_block_count_validity</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.check_for_data" href="#pyaurorax.conjunctions.Search.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.distance" href="#pyaurorax.conjunctions.Search.distance">distance</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.execute" href="#pyaurorax.conjunctions.Search.execute">execute</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.get_advanced_distances_combos" href="#pyaurorax.conjunctions.Search.get_advanced_distances_combos">get_advanced_distances_combos</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.get_data" href="#pyaurorax.conjunctions.Search.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.query" href="#pyaurorax.conjunctions.Search.query">query</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.update_status" href="#pyaurorax.conjunctions.Search.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.conjunctions.Search.wait" href="#pyaurorax.conjunctions.Search.wait">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>pyaurorax.search.data_products API documentation</title>
<meta name="description" content="Use the AuroraX search engine to search and upload data product records …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>
@media screen and (max-width: 699px) {
#content {
padding-left: 2em;
padding-right: 2em;
padding-top: 0;
}
}
@media screen and (min-width: 700px) {
#content {
max-width: 125ch;
padding-left: 3em;
padding-right: 3em;
padding-top: 1em;
border-left: 1px solid #ddd;
}
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.search.data_products</code></h1>
</header>
<section id="section-intro">
<p>Use the AuroraX search engine to search and upload data product records.</p>
<p>Note that all functions and classes from submodules are all imported
at this level of the data_products module. They can be referenced from
here instead of digging in deeper to the submodules.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyaurorax.search.data_products.classes" href="classes/index.html">pyaurorax.search.data_products.classes</a></code></dt>
<dd>
<div class="desc"><p>Separated classes and functions used by the data_products module …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.search.data_products.DataProductsManager"><code class="flex name class">
<span>class <span class="ident">DataProductsManager</span></span>
<span>(</span><span>aurorax_obj)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataProductsManager:
    &#34;&#34;&#34;
    The DataProductsManager object is initialized within every PyAuroraX object. It acts as a way to access 
    the submodules and carry over configuration information in the super class.
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0  # Polling sleep time when waiting for data (after the initial sleep time), in seconds
    __UPLOAD_CHUNK_SIZE = 500  # number of ephemeris records to upload at a time

    def __init__(self, aurorax_obj):
        self.__aurorax_obj = aurorax_obj

    def search(self,
               start: datetime.datetime,
               end: datetime.datetime,
               programs: Optional[List[str]] = None,
               platforms: Optional[List[str]] = None,
               instrument_types: Optional[List[str]] = None,
               data_product_types: Optional[List[Literal[&#34;keogram&#34;, &#34;montage&#34;, &#34;movie&#34;, &#34;summary_plot&#34;, &#34;data_availability&#34;]]] = None,
               metadata_filters: Optional[Union[MetadataFilter, List[Dict]]] = None,
               metadata_filters_logical_operator: Optional[Literal[&#34;and&#34;, &#34;or&#34;, &#34;AND&#34;, &#34;OR&#34;]] = None,
               response_format: Optional[Dict] = None,
               poll_interval: float = __STANDARD_POLLING_SLEEP_TIME,
               return_immediately: bool = False,
               verbose: bool = False) -&gt; DataProductSearch:
        &#34;&#34;&#34;
        Search for data product records

        By default, this function will block and wait until the request completes and
        all data is downloaded. If you don&#39;t want to wait, set the &#39;return_immediately`
        value to True. The Search object will be returned right after the search has been
        started, and you can use the helper functions as part of that object to get the
        data when it&#39;s done.

        Note: At least one search criteria from programs, platforms, or instrument_types, 
        must be specified.

        Args:
            start (datetime.datetime): 
                Start timestamp of the search (inclusive)
         
            end (datetime.datetime): 
                End timestamp of the search (inclusive)
         
            programs (List[str]): 
                List of programs to search through, defaults to None
        
            platforms (List[str]): 
                List of platforms to search through, defaults to None
        
            instrument_types (List[str]): 
                List of instrument types to search through, defaults to None
        
            data_product_types (List[str]): 
                List of strings describing data product types to filter on e.g. &#34;keogram&#34;, defaults 
                to None. Valid options are: `keogram`, `montage`, `movie`, `summary_plot`, and 
                `data_availability`.
        
            metadata_filters (MetadataFilter or List[Dict]): 
                The metadata filters to use when searching, defaults to None

            metadata_filters_logical_operator (str): 
                The logical operator to use when evaluating metadata filters (either `and` or `or`), 
                defaults to `and`. This parameter is deprecated in exchange for passing a 
                MetadataFilter object into the metadata_filters parameter. 
            
            response_format (Dict): 
                JSON representation of desired data response format
            
            poll_interval (float): 
                Time in seconds to wait between polling attempts, defaults to 1 second
            
            return_immediately (bool): 
                Initiate the search and return without waiting for data to be received, 
                defaults to False
            
            verbose (bool): 
                Output poll times and other progress messages, defaults to False

        Returns:
            A `pyaurorax.search.DataProductSearch` object
        &#34;&#34;&#34;
        # return
        return func_search(
            self.__aurorax_obj,
            start,
            end,
            programs,
            platforms,
            instrument_types,
            data_product_types,
            metadata_filters,
            metadata_filters_logical_operator,
            response_format,
            poll_interval,
            return_immediately,
            verbose,
        )

    def upload(
        self,
        identifier: int,
        records: List[DataProductData],
        validate_source: bool = False,
        chunk_size: int = __UPLOAD_CHUNK_SIZE,
    ) -&gt; int:
        &#34;&#34;&#34;
        Upload data product records to AuroraX

        Args:
            identifier (int): 
                The AuroraX data source ID

            records (List[DataProductData]): 
                Data product records to upload

            validate_source (bool): 
                Validate all records before uploading, defaults to False

            chunk_size (int): 
                Number of records to upload in a single call, defaults to 500

        Returns:
            0 for success, raises exception on error

        Raises:
            pyaurorax.exceptions.AuroraXUploadError: Upload error
            pyaurorax.exceptions.AuroraXError: Data source validation error
        &#34;&#34;&#34;
        return func_upload(self.__aurorax_obj, identifier, records, validate_source, chunk_size)

    def delete_urls(self, data_source: DataSource, urls: List[str]) -&gt; int:
        &#34;&#34;&#34;
        Delete data products by URL.

        The API processes this request asynchronously, so this method will return
        immediately whether or not the data has already been deleted.

        Args:
            data_source (DataSource): 
                Data source associated with the data product records (note that
                identifier, program, platform, and instrument_type are required)

            urls (List[str]): 
                URLs of data product records to delete

        Returns:
            0 on success

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
            pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
        &#34;&#34;&#34;
        return func_delete_urls(self.__aurorax_obj, data_source, urls)

    def delete(self,
               data_source: DataSource,
               start: datetime.datetime,
               end: datetime.datetime,
               data_product_types: Optional[List[str]] = None) -&gt; int:
        &#34;&#34;&#34;
        Delete data products associated with a data source within a date range.

        The API processes this request asynchronously, so this method will return
        immediately whether or not the data has already been deleted.

        Args:
            data_source (DataSource): 
                Data source associated with the data product records (note that
                identifier, program, platform, and instrument_type are required)
            
            start (datetime.datetime): 
                Timestamp marking beginning of range to delete records for, inclusive
            
            end (datetime.datetime): 
                Timestamp marking end of range to delete records for, inclusive
            
            data_product_types (List[str]): 
                Specific types of data product to delete, e.g. [&#34;keogram&#34;, &#34;movie&#34;]. If 
                omitted, all data product types will be deleted.

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXNotFoundError: Source not found
            pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
        &#34;&#34;&#34;
        return func_delete(self.__aurorax_obj, data_source, start, end, data_product_types)

    def describe(self, search_obj: Optional[DataProductSearch] = None, query_dict: Optional[Dict] = None) -&gt; str:
        &#34;&#34;&#34;
        Describe a data product search as an &#34;SQL-like&#34; string. Either a DataProductSearch
        object can be supplied, or a dictionary of the raw JSON query.

        Args:
            search_obj (DataProductSearch): 
                The data product search to describe, optional

            query_dict (Dict): 
                The data product search query represented as a raw dictionary, optional

        Returns:
            The &#34;SQL-like&#34; string describing the data product search object
        &#34;&#34;&#34;
        return func_describe(self.__aurorax_obj, search_obj, query_dict)

    def get_request_url(self, request_id: str) -&gt; str:
        &#34;&#34;&#34;
        Get the data product search request URL for a given
        request ID. This URL can be used for subsequent
        pyaurorax.requests function calls. Primarily this method
        facilitates delving into details about a set of already-submitted
        data product searches.

        Args:
            request_id (str): 
                The request identifier

        Returns:
            The request URL
        &#34;&#34;&#34;
        return func_get_request_url(self.__aurorax_obj, request_id)

    def create_response_format_template(self, default: bool = False) -&gt; Dict:
        &#34;&#34;&#34;
        Generate a template dictionary that can be used as the response_format parameter
        in a data products search.

        Args:
            default (bool): 
                The default value to set for every parameter that can be returned, defaults
                to False.

        Returns:
            A template dictionary for the response format
        &#34;&#34;&#34;
        return {
            &#34;start&#34;: default,
            &#34;end&#34;: default,
            &#34;data_source&#34;: {
                &#34;identifier&#34;: default,
                &#34;program&#34;: default,
                &#34;platform&#34;: default,
                &#34;instrument_type&#34;: default,
                &#34;source_type&#34;: default,
                &#34;display_name&#34;: default,
                &#34;ephemeris_metadata_schema&#34;: {
                    &#34;field_name&#34;: default,
                    &#34;description&#34;: default,
                    &#34;data_type&#34;: default,
                    &#34;allowed_values&#34;: default,
                    &#34;additional_description&#34;: default
                },
                &#34;data_product_metadata_schema&#34;: {
                    &#34;field_name&#34;: default,
                    &#34;description&#34;: default,
                    &#34;data_type&#34;: default,
                    &#34;allowed_values&#34;: default,
                    &#34;additional_description&#34;: default
                },
                &#34;owner&#34;: default,
                &#34;maintainers&#34;: default,
                &#34;metadata&#34;: default
            },
            &#34;url&#34;: default,
            &#34;data_product_type&#34;: default,
            &#34;metadata&#34;: default
        }</code></pre>
</details>
<div class="desc"><p>The DataProductsManager object is initialized within every PyAuroraX object. It acts as a way to access
the submodules and carry over configuration information in the super class.</p></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.data_products.DataProductsManager.create_response_format_template"><code class="name flex">
<span>def <span class="ident">create_response_format_template</span></span>(<span>self, default: bool = False) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_response_format_template(self, default: bool = False) -&gt; Dict:
    &#34;&#34;&#34;
    Generate a template dictionary that can be used as the response_format parameter
    in a data products search.

    Args:
        default (bool): 
            The default value to set for every parameter that can be returned, defaults
            to False.

    Returns:
        A template dictionary for the response format
    &#34;&#34;&#34;
    return {
        &#34;start&#34;: default,
        &#34;end&#34;: default,
        &#34;data_source&#34;: {
            &#34;identifier&#34;: default,
            &#34;program&#34;: default,
            &#34;platform&#34;: default,
            &#34;instrument_type&#34;: default,
            &#34;source_type&#34;: default,
            &#34;display_name&#34;: default,
            &#34;ephemeris_metadata_schema&#34;: {
                &#34;field_name&#34;: default,
                &#34;description&#34;: default,
                &#34;data_type&#34;: default,
                &#34;allowed_values&#34;: default,
                &#34;additional_description&#34;: default
            },
            &#34;data_product_metadata_schema&#34;: {
                &#34;field_name&#34;: default,
                &#34;description&#34;: default,
                &#34;data_type&#34;: default,
                &#34;allowed_values&#34;: default,
                &#34;additional_description&#34;: default
            },
            &#34;owner&#34;: default,
            &#34;maintainers&#34;: default,
            &#34;metadata&#34;: default
        },
        &#34;url&#34;: default,
        &#34;data_product_type&#34;: default,
        &#34;metadata&#34;: default
    }</code></pre>
</details>
<div class="desc"><p>Generate a template dictionary that can be used as the response_format parameter
in a data products search.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default</code></strong> :&ensp;<code>bool</code></dt>
<dd>The default value to set for every parameter that can be returned, defaults
to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A template dictionary for the response format</p></div>
</dd>
<dt id="pyaurorax.search.data_products.DataProductsManager.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self,<br>data_source: <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>data_product_types: List[str] | None = None) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self,
           data_source: DataSource,
           start: datetime.datetime,
           end: datetime.datetime,
           data_product_types: Optional[List[str]] = None) -&gt; int:
    &#34;&#34;&#34;
    Delete data products associated with a data source within a date range.

    The API processes this request asynchronously, so this method will return
    immediately whether or not the data has already been deleted.

    Args:
        data_source (DataSource): 
            Data source associated with the data product records (note that
            identifier, program, platform, and instrument_type are required)
        
        start (datetime.datetime): 
            Timestamp marking beginning of range to delete records for, inclusive
        
        end (datetime.datetime): 
            Timestamp marking end of range to delete records for, inclusive
        
        data_product_types (List[str]): 
            Specific types of data product to delete, e.g. [&#34;keogram&#34;, &#34;movie&#34;]. If 
            omitted, all data product types will be deleted.

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXNotFoundError: Source not found
        pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
    &#34;&#34;&#34;
    return func_delete(self.__aurorax_obj, data_source, start, end, data_product_types)</code></pre>
</details>
<div class="desc"><p>Delete data products associated with a data source within a date range.</p>
<p>The API processes this request asynchronously, so this method will return
immediately whether or not the data has already been deleted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_source</code></strong> :&ensp;<code>DataSource</code></dt>
<dd>Data source associated with the data product records (note that
identifier, program, platform, and instrument_type are required)</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Timestamp marking beginning of range to delete records for, inclusive</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Timestamp marking end of range to delete records for, inclusive</dd>
<dt><strong><code>data_product_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>Specific types of data product to delete, e.g. ["keogram", "movie"]. If
omitted, all data product types will be deleted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXNotFoundError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXNotFoundError">AuroraXNotFoundError</a></code></dt>
<dd>Source not found</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>Invalid API key for this operation</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.data_products.DataProductsManager.delete_urls"><code class="name flex">
<span>def <span class="ident">delete_urls</span></span>(<span>self,<br>data_source: <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>,<br>urls: List[str]) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_urls(self, data_source: DataSource, urls: List[str]) -&gt; int:
    &#34;&#34;&#34;
    Delete data products by URL.

    The API processes this request asynchronously, so this method will return
    immediately whether or not the data has already been deleted.

    Args:
        data_source (DataSource): 
            Data source associated with the data product records (note that
            identifier, program, platform, and instrument_type are required)

        urls (List[str]): 
            URLs of data product records to delete

    Returns:
        0 on success

    Raises:
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
    &#34;&#34;&#34;
    return func_delete_urls(self.__aurorax_obj, data_source, urls)</code></pre>
</details>
<div class="desc"><p>Delete data products by URL.</p>
<p>The API processes this request asynchronously, so this method will return
immediately whether or not the data has already been deleted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_source</code></strong> :&ensp;<code>DataSource</code></dt>
<dd>Data source associated with the data product records (note that
identifier, program, platform, and instrument_type are required)</dd>
<dt><strong><code>urls</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>URLs of data product records to delete</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>Invalid API key for this operation</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.data_products.DataProductsManager.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self,<br>search_obj: <a title="pyaurorax.search.data_products.classes.search.DataProductSearch" href="classes/search.html#pyaurorax.search.data_products.classes.search.DataProductSearch">DataProductSearch</a> | None = None,<br>query_dict: Dict | None = None) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self, search_obj: Optional[DataProductSearch] = None, query_dict: Optional[Dict] = None) -&gt; str:
    &#34;&#34;&#34;
    Describe a data product search as an &#34;SQL-like&#34; string. Either a DataProductSearch
    object can be supplied, or a dictionary of the raw JSON query.

    Args:
        search_obj (DataProductSearch): 
            The data product search to describe, optional

        query_dict (Dict): 
            The data product search query represented as a raw dictionary, optional

    Returns:
        The &#34;SQL-like&#34; string describing the data product search object
    &#34;&#34;&#34;
    return func_describe(self.__aurorax_obj, search_obj, query_dict)</code></pre>
</details>
<div class="desc"><p>Describe a data product search as an "SQL-like" string. Either a DataProductSearch
object can be supplied, or a dictionary of the raw JSON query.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>search_obj</code></strong> :&ensp;<code>DataProductSearch</code></dt>
<dd>The data product search to describe, optional</dd>
<dt><strong><code>query_dict</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The data product search query represented as a raw dictionary, optional</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The "SQL-like" string describing the data product search object</p></div>
</dd>
<dt id="pyaurorax.search.data_products.DataProductsManager.get_request_url"><code class="name flex">
<span>def <span class="ident">get_request_url</span></span>(<span>self, request_id: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_request_url(self, request_id: str) -&gt; str:
    &#34;&#34;&#34;
    Get the data product search request URL for a given
    request ID. This URL can be used for subsequent
    pyaurorax.requests function calls. Primarily this method
    facilitates delving into details about a set of already-submitted
    data product searches.

    Args:
        request_id (str): 
            The request identifier

    Returns:
        The request URL
    &#34;&#34;&#34;
    return func_get_request_url(self.__aurorax_obj, request_id)</code></pre>
</details>
<div class="desc"><p>Get the data product search request URL for a given
request ID. This URL can be used for subsequent
pyaurorax.requests function calls. Primarily this method
facilitates delving into details about a set of already-submitted
data product searches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The request identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The request URL</p></div>
</dd>
<dt id="pyaurorax.search.data_products.DataProductsManager.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>programs: List[str] | None = None,<br>platforms: List[str] | None = None,<br>instrument_types: List[str] | None = None,<br>data_product_types: List[Literal['keogram', 'montage', 'movie', 'summary_plot', 'data_availability']] | None = None,<br>metadata_filters: <a title="pyaurorax.search.metadata_filters.MetadataFilter" href="../metadata_filters.html#pyaurorax.search.metadata_filters.MetadataFilter">MetadataFilter</a> | List[Dict] | None = None,<br>metadata_filters_logical_operator: Literal['and', 'or', 'AND', 'OR'] | None = None,<br>response_format: Dict | None = None,<br>poll_interval: float = 1.0,<br>return_immediately: bool = False,<br>verbose: bool = False) ‑> <a title="pyaurorax.search.data_products.classes.search.DataProductSearch" href="classes/search.html#pyaurorax.search.data_products.classes.search.DataProductSearch">DataProductSearch</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self,
           start: datetime.datetime,
           end: datetime.datetime,
           programs: Optional[List[str]] = None,
           platforms: Optional[List[str]] = None,
           instrument_types: Optional[List[str]] = None,
           data_product_types: Optional[List[Literal[&#34;keogram&#34;, &#34;montage&#34;, &#34;movie&#34;, &#34;summary_plot&#34;, &#34;data_availability&#34;]]] = None,
           metadata_filters: Optional[Union[MetadataFilter, List[Dict]]] = None,
           metadata_filters_logical_operator: Optional[Literal[&#34;and&#34;, &#34;or&#34;, &#34;AND&#34;, &#34;OR&#34;]] = None,
           response_format: Optional[Dict] = None,
           poll_interval: float = __STANDARD_POLLING_SLEEP_TIME,
           return_immediately: bool = False,
           verbose: bool = False) -&gt; DataProductSearch:
    &#34;&#34;&#34;
    Search for data product records

    By default, this function will block and wait until the request completes and
    all data is downloaded. If you don&#39;t want to wait, set the &#39;return_immediately`
    value to True. The Search object will be returned right after the search has been
    started, and you can use the helper functions as part of that object to get the
    data when it&#39;s done.

    Note: At least one search criteria from programs, platforms, or instrument_types, 
    must be specified.

    Args:
        start (datetime.datetime): 
            Start timestamp of the search (inclusive)
     
        end (datetime.datetime): 
            End timestamp of the search (inclusive)
     
        programs (List[str]): 
            List of programs to search through, defaults to None
    
        platforms (List[str]): 
            List of platforms to search through, defaults to None
    
        instrument_types (List[str]): 
            List of instrument types to search through, defaults to None
    
        data_product_types (List[str]): 
            List of strings describing data product types to filter on e.g. &#34;keogram&#34;, defaults 
            to None. Valid options are: `keogram`, `montage`, `movie`, `summary_plot`, and 
            `data_availability`.
    
        metadata_filters (MetadataFilter or List[Dict]): 
            The metadata filters to use when searching, defaults to None

        metadata_filters_logical_operator (str): 
            The logical operator to use when evaluating metadata filters (either `and` or `or`), 
            defaults to `and`. This parameter is deprecated in exchange for passing a 
            MetadataFilter object into the metadata_filters parameter. 
        
        response_format (Dict): 
            JSON representation of desired data response format
        
        poll_interval (float): 
            Time in seconds to wait between polling attempts, defaults to 1 second
        
        return_immediately (bool): 
            Initiate the search and return without waiting for data to be received, 
            defaults to False
        
        verbose (bool): 
            Output poll times and other progress messages, defaults to False

    Returns:
        A `pyaurorax.search.DataProductSearch` object
    &#34;&#34;&#34;
    # return
    return func_search(
        self.__aurorax_obj,
        start,
        end,
        programs,
        platforms,
        instrument_types,
        data_product_types,
        metadata_filters,
        metadata_filters_logical_operator,
        response_format,
        poll_interval,
        return_immediately,
        verbose,
    )</code></pre>
</details>
<div class="desc"><p>Search for data product records</p>
<p>By default, this function will block and wait until the request completes and
all data is downloaded. If you don't want to wait, set the 'return_immediately`
value to True. The Search object will be returned right after the search has been
started, and you can use the helper functions as part of that object to get the
data when it's done.</p>
<p>Note: At least one search criteria from programs, platforms, or instrument_types,
must be specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>
<p>Start timestamp of the search (inclusive)</p>
<p>end (datetime.datetime):
End timestamp of the search (inclusive)</p>
<p>programs (List[str]):
List of programs to search through, defaults to None</p>
<p>platforms (List[str]):
List of platforms to search through, defaults to None</p>
<p>instrument_types (List[str]):
List of instrument types to search through, defaults to None</p>
<p>data_product_types (List[str]):
List of strings describing data product types to filter on e.g. "keogram", defaults
to None. Valid options are: <code>keogram</code>, <code>montage</code>, <code>movie</code>, <code>summary_plot</code>, and
<code>data_availability</code>.</p>
<p>metadata_filters (MetadataFilter or List[Dict]):
The metadata filters to use when searching, defaults to None</p>
<p>metadata_filters_logical_operator (str):
The logical operator to use when evaluating metadata filters (either <code>and</code> or <code>or</code>),
defaults to <code>and</code>. This parameter is deprecated in exchange for passing a
MetadataFilter object into the metadata_filters parameter. </p>
<p>response_format (Dict):
JSON representation of desired data response format</p>
<p>poll_interval (float):
Time in seconds to wait between polling attempts, defaults to 1 second</p>
<p>return_immediately (bool):
Initiate the search and return without waiting for data to be received,
defaults to False</p>
<p>verbose (bool):
Output poll times and other progress messages, defaults to False</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code><a title="pyaurorax.search.DataProductSearch" href="../index.html#pyaurorax.search.DataProductSearch">DataProductSearch</a></code> object</p></div>
</dd>
<dt id="pyaurorax.search.data_products.DataProductsManager.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>self,<br>identifier: int,<br>records: List[<a title="pyaurorax.search.data_products.classes.data_product.DataProductData" href="classes/data_product.html#pyaurorax.search.data_products.classes.data_product.DataProductData">DataProductData</a>],<br>validate_source: bool = False,<br>chunk_size: int = 500) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(
    self,
    identifier: int,
    records: List[DataProductData],
    validate_source: bool = False,
    chunk_size: int = __UPLOAD_CHUNK_SIZE,
) -&gt; int:
    &#34;&#34;&#34;
    Upload data product records to AuroraX

    Args:
        identifier (int): 
            The AuroraX data source ID

        records (List[DataProductData]): 
            Data product records to upload

        validate_source (bool): 
            Validate all records before uploading, defaults to False

        chunk_size (int): 
            Number of records to upload in a single call, defaults to 500

    Returns:
        0 for success, raises exception on error

    Raises:
        pyaurorax.exceptions.AuroraXUploadError: Upload error
        pyaurorax.exceptions.AuroraXError: Data source validation error
    &#34;&#34;&#34;
    return func_upload(self.__aurorax_obj, identifier, records, validate_source, chunk_size)</code></pre>
</details>
<div class="desc"><p>Upload data product records to AuroraX</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>int</code></dt>
<dd>The AuroraX data source ID</dd>
<dt><strong><code>records</code></strong> :&ensp;<code>List[DataProductData]</code></dt>
<dd>Data product records to upload</dd>
<dt><strong><code>validate_source</code></strong> :&ensp;<code>bool</code></dt>
<dd>Validate all records before uploading, defaults to False</dd>
<dt><strong><code>chunk_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of records to upload in a single call, defaults to 500</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 for success, raises exception on error</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXUploadError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXUploadError">AuroraXUploadError</a></code></dt>
<dd>Upload error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXError">AuroraXError</a></code></dt>
<dd>Data source validation error</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax.search" href="../index.html">pyaurorax.search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyaurorax.search.data_products.classes" href="classes/index.html">pyaurorax.search.data_products.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.search.data_products.DataProductsManager" href="#pyaurorax.search.data_products.DataProductsManager">DataProductsManager</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.data_products.DataProductsManager.create_response_format_template" href="#pyaurorax.search.data_products.DataProductsManager.create_response_format_template">create_response_format_template</a></code></li>
<li><code><a title="pyaurorax.search.data_products.DataProductsManager.delete" href="#pyaurorax.search.data_products.DataProductsManager.delete">delete</a></code></li>
<li><code><a title="pyaurorax.search.data_products.DataProductsManager.delete_urls" href="#pyaurorax.search.data_products.DataProductsManager.delete_urls">delete_urls</a></code></li>
<li><code><a title="pyaurorax.search.data_products.DataProductsManager.describe" href="#pyaurorax.search.data_products.DataProductsManager.describe">describe</a></code></li>
<li><code><a title="pyaurorax.search.data_products.DataProductsManager.get_request_url" href="#pyaurorax.search.data_products.DataProductsManager.get_request_url">get_request_url</a></code></li>
<li><code><a title="pyaurorax.search.data_products.DataProductsManager.search" href="#pyaurorax.search.data_products.DataProductsManager.search">search</a></code></li>
<li><code><a title="pyaurorax.search.data_products.DataProductsManager.upload" href="#pyaurorax.search.data_products.DataProductsManager.upload">upload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>

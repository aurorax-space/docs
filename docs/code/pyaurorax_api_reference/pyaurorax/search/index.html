<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>pyaurorax.search API documentation</title>
<meta name="description" content="Interact with the AuroraX search engine. This includes finding data sources, searching
for conjunctions or ephemeris data, and uploading/managing …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>
@media screen and (max-width: 699px) {
#content {
padding-left: 2em;
padding-right: 2em;
padding-top: 0;
}
}
@media screen and (min-width: 700px) {
#content {
max-width: 125ch;
padding-left: 3em;
padding-right: 3em;
padding-top: 1em;
border-left: 1px solid #ddd;
}
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.search</code></h1>
</header>
<section id="section-intro">
<p>Interact with the AuroraX search engine. This includes finding data sources, searching
for conjunctions or ephemeris data, and uploading/managing your own data in the AuroraX platform.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyaurorax.search.api" href="api/index.html">pyaurorax.search.api</a></code></dt>
<dd>
<div class="desc"><p>Interface for AuroraX API requests. Primarily an under-the-hood module
not needed for most use-cases.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.availability" href="availability/index.html">pyaurorax.search.availability</a></code></dt>
<dd>
<div class="desc"><p>Retrieve availability information about data in the AuroraX search engine.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.conjunctions" href="conjunctions/index.html">pyaurorax.search.conjunctions</a></code></dt>
<dd>
<div class="desc"><p>Use the AuroraX search engine to find conjunctions between groupings
of data sources …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.data_products" href="data_products/index.html">pyaurorax.search.data_products</a></code></dt>
<dd>
<div class="desc"><p>Use the AuroraX search engine to search and upload data product records …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.ephemeris" href="ephemeris/index.html">pyaurorax.search.ephemeris</a></code></dt>
<dd>
<div class="desc"><p>Use the AuroraX search engine to search and upload ephemeris records …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.location" href="location.html">pyaurorax.search.location</a></code></dt>
<dd>
<div class="desc"><p>Class definition for AuroraX search engine location data</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.metadata" href="metadata/index.html">pyaurorax.search.metadata</a></code></dt>
<dd>
<div class="desc"><p>Interacting with the data source metadata schemas …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.metadata_filters" href="metadata_filters.html">pyaurorax.search.metadata_filters</a></code></dt>
<dd>
<div class="desc"><p>Class definition for a metadata filter objects</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.requests" href="requests/index.html">pyaurorax.search.requests</a></code></dt>
<dd>
<div class="desc"><p>Helper methods for retrieving data from an AuroraX search engine API
request …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.sources" href="sources/index.html">pyaurorax.search.sources</a></code></dt>
<dd>
<div class="desc"><p>Manage AuroraX data sources utilized by the search engine.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.util" href="util/index.html">pyaurorax.search.util</a></code></dt>
<dd>
<div class="desc"><p>Utility methods. For example, converting arbitrary geographic locations to North/South
B-trace geographic locations.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.search.AvailabilityResult"><code class="flex name class">
<span>class <span class="ident">AvailabilityResult</span></span>
<span>(</span><span>data_source: <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>,<br>available_data_products: Dict | None = None,<br>available_ephemeris: Dict | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AvailabilityResult:
    &#34;&#34;&#34;
    Class definition for data availability information

    Attributes:
        data_source (pyaurorax.search.DataSource): 
            The data source that the records are associated with

        available_ephemeris (Dict): 
            The ephemeris availability information

        available_data_products (Dict): 
            The data product availability information
    &#34;&#34;&#34;
    data_source: DataSource
    available_data_products: Optional[Dict] = None
    available_ephemeris: Optional[Dict] = None</code></pre>
</details>
<div class="desc"><p>Class definition for data availability information</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_source</code></strong> :&ensp;<code><a title="pyaurorax.search.DataSource" href="#pyaurorax.search.DataSource">DataSource</a></code></dt>
<dd>The data source that the records are associated with</dd>
<dt><strong><code>available_ephemeris</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The ephemeris availability information</dd>
<dt><strong><code>available_data_products</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The data product availability information</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.search.AvailabilityResult.available_data_products"><code class="name">var <span class="ident">available_data_products</span> : Dict | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.search.AvailabilityResult.available_ephemeris"><code class="name">var <span class="ident">available_ephemeris</span> : Dict | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.search.AvailabilityResult.data_source"><code class="name">var <span class="ident">data_source</span> : <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.Conjunction"><code class="flex name class">
<span>class <span class="ident">Conjunction</span></span>
<span>(</span><span>conjunction_type: str,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>data_sources: List[<a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>],<br>min_distance: float,<br>max_distance: float,<br>events: List[Dict],<br>closest_epoch: datetime.datetime,<br>farthest_epoch: datetime.datetime)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conjunction:
    &#34;&#34;&#34;
    Conjunction object

    Attributes:
        conjunction_type (str): 
            The type of location data used when the conjunction was found (either `nbtrace`, 
            `sbtrace`, or `geographic`)
            
        start (datetime.datetime): 
            Start timestamp of the conjunction

        end (datetime.datetime): 
            End timestamp of the conjunction

        data_sources (List[DataSource]): 
            Data sources in the conjunction

        min_distance (float): 
            Minimum kilometer distance of the conjunction

        max_distance (float): 
            Maximum kilometer distance of the conjunction

        events (List[Dict]): 
            The sub-conjunctions that make up this over-arching conjunction (the conjunctions 
            between each set of two data sources)

        closest_epoch (datetime.datetime): 
            Timestamp for when data sources were closest

        farthest_epoch (datetime.datetime): 
            Timestamp for when data sources were farthest
    &#34;&#34;&#34;

    def __init__(
        self,
        conjunction_type: str,
        start: datetime.datetime,
        end: datetime.datetime,
        data_sources: List[DataSource],
        min_distance: float,
        max_distance: float,
        events: List[Dict],
        closest_epoch: datetime.datetime,
        farthest_epoch: datetime.datetime,
    ):
        self.conjunction_type = conjunction_type
        self.start = start
        self.end = end
        self.data_sources = data_sources
        self.min_distance = min_distance
        self.max_distance = max_distance
        self.events = events
        self.closest_epoch = closest_epoch
        self.farthest_epoch = farthest_epoch

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#34;Conjunction(start={repr(self.start)}, end={repr(self.end)}, min_distance={self.min_distance:.2f}, &#34; \
            f&#34;max_distance={self.max_distance:.2f}, data_sources=[...], events=[...])&#34;</code></pre>
</details>
<div class="desc"><p>Conjunction object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>conjunction_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of location data used when the conjunction was found (either <code>nbtrace</code>,
<code>sbtrace</code>, or <code>geographic</code>)</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Start timestamp of the conjunction</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>End timestamp of the conjunction</dd>
<dt><strong><code>data_sources</code></strong> :&ensp;<code>List[<a title="pyaurorax.search.DataSource" href="#pyaurorax.search.DataSource">DataSource</a>]</code></dt>
<dd>Data sources in the conjunction</dd>
<dt><strong><code>min_distance</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum kilometer distance of the conjunction</dd>
<dt><strong><code>max_distance</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum kilometer distance of the conjunction</dd>
<dt><strong><code>events</code></strong> :&ensp;<code>List[Dict]</code></dt>
<dd>The sub-conjunctions that make up this over-arching conjunction (the conjunctions
between each set of two data sources)</dd>
<dt><strong><code>closest_epoch</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Timestamp for when data sources were closest</dd>
<dt><strong><code>farthest_epoch</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Timestamp for when data sources were farthest</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch"><code class="flex name class">
<span>class <span class="ident">ConjunctionSearch</span></span>
<span>(</span><span>aurorax_obj: PyAuroraX,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>distance: Union[int, float, Dict],<br>ground: Sequence[Union[<a title="pyaurorax.search.GroundCriteriaBlock" href="#pyaurorax.search.GroundCriteriaBlock">GroundCriteriaBlock</a>, Dict]] = [],<br>space: Sequence[Union[<a title="pyaurorax.search.SpaceCriteriaBlock" href="#pyaurorax.search.SpaceCriteriaBlock">SpaceCriteriaBlock</a>, Dict]] = [],<br>events: Sequence[Union[<a title="pyaurorax.search.EventsCriteriaBlock" href="#pyaurorax.search.EventsCriteriaBlock">EventsCriteriaBlock</a>, Dict]] = [],<br>custom_locations: Sequence[Union[<a title="pyaurorax.search.CustomLocationsCriteriaBlock" href="#pyaurorax.search.CustomLocationsCriteriaBlock">CustomLocationsCriteriaBlock</a>, Dict]] = [],<br>conjunction_types: "Sequence[Union[str, Literal['nbtrace', 'sbtrace', 'geographic']]]" = ['nbtrace'],<br>response_format: Optional[Dict] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConjunctionSearch:
    &#34;&#34;&#34;
    Class representing a conjunction search

    Attributes:
        start (datetime.datetime): 
            Start timestamp of the search (inclusive).

        end (datetime.datetime): 
            End timestamp of the search (inclusive).

        distance (int or float or Dict): 
            The maximum distance allowed between data sources when searching for
            conjunctions. This can either be a number (int or float), or a dictionary
            modified from the output of the &#34;get_advanced_distances_combos()&#34; function.

        ground (List[GroundCriteriaBlock or Dict]): 
            List of ground instrument criteria blocks, defaults to [].

        space (List[SpaceCriteriaBlock or Dict]): 
            List of space instrument criteria blocks, defaults to [].

        events (List[EventsCriteriaBlock or Dict]): 
            List of event criteria blocks, defaults to [].

        custom_locations (List[CustomLocationsCriteriaBlock or Dict]): 
            List of custom location criteria blocks, defaults to [].

        conjunction_types (List[str]): 
            List of conjunction types, defaults to [] (meaning all conjunction types). Valid
            options are &#39;nbtrace&#39;, &#39;sbtrace&#39;, and &#39;geographic&#39;. Defaults to &#39;nbtrace&#39;.

        response_format (Dict): 
            JSON representation of desired data response format

        request (AuroraXResponse): 
            AuroraXResponse object returned when the search is executed

        request_id (str): 
            Unique ID assigned to the request by the AuroraX API

        request_url (str): 
            Unique URL assigned to the request by the AuroraX API

        executed (bool): 
            Indicates if the search has been executed/started

        completed (bool): 
            Indicates if the search has finished

        data_url (str): 
            The URL where data is accessed

        query (Dict): 
            The query for this request as JSON

        status (Dict): 
            The status of the query

        data (List[Conjunction]): 
            The conjunctions found

        logs (List[Dict]): 
            All log messages outputted by the AuroraX API for this request
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0

    def __init__(self,
                 aurorax_obj: PyAuroraX,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 distance: Union[int, float, Dict],
                 ground: Sequence[Union[GroundCriteriaBlock, Dict]] = [],
                 space: Sequence[Union[SpaceCriteriaBlock, Dict]] = [],
                 events: Sequence[Union[EventsCriteriaBlock, Dict]] = [],
                 custom_locations: Sequence[Union[CustomLocationsCriteriaBlock, Dict]] = [],
                 conjunction_types: Sequence[Union[str, Literal[&#34;nbtrace&#34;, &#34;sbtrace&#34;, &#34;geographic&#34;]]] = [&#34;nbtrace&#34;],
                 response_format: Optional[Dict] = None):

        # set variables using passed in args
        self.__aurorax_obj = aurorax_obj
        self.start = start
        self.end = end
        self.ground = ground
        self.space = space
        self.events = events
        self.custom_locations = custom_locations
        self.distance = distance
        self.conjunction_types = conjunction_types
        self.response_format = response_format

        # initialize additional variables
        self.request = None
        self.request_id = &#34;&#34;
        self.request_url = &#34;&#34;
        self.executed = False
        self.completed = False
        self.data_url = &#34;&#34;
        self.__query = {}
        self.status = {}
        self.data = []
        self.logs = []

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return &#34;ConjunctionSearch(executed=%s, completed=%s, request_id=&#39;%s&#39;)&#34; % (
            self.executed,
            self.completed,
            self.request_id,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set status and query strings
        max_len = 80
        status_str = str(self.status)
        query_str = str(self.query)
        if (len(status_str) &gt; max_len):
            status_str = &#34;%s...&#34; % (status_str[0:max_len])
        if (len(query_str) &gt; max_len):
            query_str = &#34;%s...&#34; % (query_str[0:max_len])

        # set results string
        if (self.executed is True):
            if (len(self.data) == 0):
                data_str = &#34;[0 conjunction results]&#34;
            elif (len(self.data) == 1):
                data_str = &#34;[1 conjunction result]&#34;
            else:
                data_str = &#34;[%d conjunction results]&#34; % (len(self.data))
        else:
            data_str = &#34;&#34;

        # set logs string
        if (self.executed is True):
            if (len(self.logs) == 0):
                logs_str = &#34;[0 log messages]&#34;
            elif (len(self.logs) == 1):
                logs_str = &#34;[1 log message]&#34;
            else:
                logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
        else:
            logs_str = &#34;&#34;

        # print
        print(&#34;ConjunctionSearch:&#34;)
        print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
        print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
        print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
        print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
        print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
        print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
        print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
        print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
        print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))

    def __fill_in_missing_distances(self, curr_distances: Dict) -&gt; Dict:
        # get all distances possible
        all_distances = self.get_advanced_distances_combos()

        # go through current distances and fill in the values
        for curr_key, curr_value in curr_distances.items():
            curr_key_split = curr_key.split(&#39;-&#39;)
            curr_key1 = curr_key_split[0].strip()
            curr_key2 = curr_key_split[1].strip()
            for all_key in all_distances.keys():
                if (curr_key1 in all_key and curr_key2 in all_key):
                    # found the matching key, replace the value
                    all_distances[all_key] = curr_value

        # return
        return all_distances

    def check_criteria_block_count_validity(self) -&gt; None:
        &#34;&#34;&#34;
        Check the number of of criteria blocks to see if there
        is too many. A max of 10 is allowed by the AuroraX
        conjunction search engine. An exception is raised if
        it was determined to have too many.

        Raises:
            pyaurorax.exceptions.AuroraXError: Too many criteria blocks are found
        &#34;&#34;&#34;
        count_ground = 0
        count_space = 0
        count_events = 0
        count_custom_locations = 0
        if (self.ground is not None):
            count_ground = len(self.ground)
        if (self.space is not None):
            count_space = len(self.space)
        if (self.events is not None):
            count_events = len(self.events)
        if (self.custom_locations is not None):
            count_custom_locations = len(self.custom_locations)
        if ((count_ground + count_space + count_events + count_custom_locations) &gt; 10):
            raise AuroraXError(&#34;Number of criteria blocks exceeds 10, please reduce the count&#34;)

    def get_advanced_distances_combos(self, default_distance: Optional[Union[int, float]] = None) -&gt; Dict:
        &#34;&#34;&#34;
        Get the advanced distances combinations for this search

        Args:
            default_distance (int): 
                The default distance to use, defaults to None

        Returns:
            The advanced distances combinations
        &#34;&#34;&#34;
        # set input arrays
        options = []
        if (self.ground is not None):
            for i in range(0, len(self.ground)):
                options.append(&#34;ground%d&#34; % (i + 1))
        if (self.space is not None):
            for i in range(0, len(self.space)):
                options.append(&#34;space%d&#34; % (i + 1))
        if (self.events is not None):
            for i in range(0, len(self.events)):
                options.append(&#34;events%d&#34; % (i + 1))
        if (self.custom_locations is not None):
            for i in range(0, len(self.custom_locations)):
                options.append(&#34;adhoc%d&#34; % (i + 1))

        # derive all combinations of options of size 2
        combinations = {}
        for element in itertools.combinations(options, r=2):
            combinations[&#34;%s-%s&#34; % (element[0], element[1])] = default_distance

        # return
        return combinations

    @property
    def distance(self) -&gt; Union[int, float, Dict[str, Union[int, float]]]:
        &#34;&#34;&#34;
        Property for the distance parameter

        Returns:
            The distance dictionary with all combinations
        &#34;&#34;&#34;
        return self.__distance

    @distance.setter
    def distance(self, distance: Union[int, float, Dict[str, Union[int, float]]]) -&gt; None:
        # set distances to a dict if it&#39;s an int or float
        if (isinstance(distance, int) or isinstance(distance, float)):
            self.__distance = self.get_advanced_distances_combos(default_distance=distance)  # type: ignore
        else:
            # is a dict, fill in any gaps
            self.__distance = self.__fill_in_missing_distances(distance)  # type: ignore

    @property
    def query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Property for the query value

        Returns:
            The query parameter
        &#34;&#34;&#34;
        # set ground
        ground_param = self.ground
        if (isinstance(self.ground, list) and all(isinstance(item, GroundCriteriaBlock) for item in self.ground)):
            # ground parameter is a list of GroundCriteriaBlock objects, so we
            # want to set the query to the dict version of it
            ground_param = []
            for val in self.ground:
                this_dict = deepcopy(val.__dict__)
                this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;metadata_filters&#34;]
                del this_dict[&#34;metadata_filters&#34;]
                if (this_dict[&#34;ephemeris_metadata_filters&#34;] is not None):
                    this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;ephemeris_metadata_filters&#34;].to_query_dict()
                ground_param.append(this_dict)

        # set space
        space_param = self.space
        if (isinstance(self.space, list) and all(isinstance(item, SpaceCriteriaBlock) for item in self.space)):
            # space parameter is a list of SpaceCriteriaBlock objects, so we
            # want to set the query to the dict version of it
            space_param = []
            for val in self.space:
                this_dict = deepcopy(val.__dict__)
                this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;metadata_filters&#34;]
                del this_dict[&#34;metadata_filters&#34;]
                if (this_dict[&#34;ephemeris_metadata_filters&#34;] is not None):
                    this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;ephemeris_metadata_filters&#34;].to_query_dict()
                space_param.append(this_dict)

        # set events
        events_param = self.events
        if (isinstance(self.events, list) and all(isinstance(item, EventsCriteriaBlock) for item in self.events)):
            # space parameter is a list of EventsCriteriaBlock objects, so we
            # want to set the query to the dict version of it
            events_param = []
            for val in self.events:
                this_dict = deepcopy(val.__dict__)
                this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;metadata_filters&#34;]
                this_dict[&#34;programs&#34;] = [&#34;events&#34;]
                del this_dict[&#34;metadata_filters&#34;]
                if (this_dict[&#34;ephemeris_metadata_filters&#34;] is not None):
                    this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;ephemeris_metadata_filters&#34;].to_query_dict()
                events_param.append(this_dict)

        # set custom locations
        custom_param = self.custom_locations
        if (isinstance(self.custom_locations, list) and all(isinstance(item, CustomLocationsCriteriaBlock) for item in self.custom_locations)):
            # space parameter is a list of CustomLocationsCriteriaBlock objects, so we
            # want to set the query to the dict version of it
            custom_param = []
            for val in self.custom_locations:
                this_dict = val.to_search_query_dict()  # type: ignore
                custom_param.append(this_dict)

        # set query
        self.__query = {
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;ground&#34;: ground_param,
            &#34;space&#34;: space_param,
            &#34;events&#34;: events_param,
            &#34;adhoc&#34;: custom_param,
            &#34;conjunction_types&#34;: self.conjunction_types,
            &#34;max_distances&#34;: self.distance,
            &#34;epoch_search_precision&#34;: 60,
        }
        return self.__query

    @query.setter
    def query(self, query: Dict) -&gt; None:
        self.__query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate a conjunction search request

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        # check number of criteria blocks
        self.check_criteria_block_count_validity()

        # do request
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_SEARCH)
        req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if res.status_code == 202:
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this conjunction search request

        Args:
            status (Dict): 
                The previously-retrieved status of this request (include
                to avoid requesting it from the API again), defaults to None

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.__aurorax_obj, self.request_url)

        # check response
        if (status is None):
            raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s/data&#34; % (self.request_url)

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this conjunction
        search request

        Returns:
            True if data is available, else False

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this conjunction search request

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        # check if completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.__aurorax_obj, self.data_url, self.response_format, False)

        # set data variable
        if (self.response_format is not None):
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                for j in range(0, len(raw_data[i][&#34;data_sources&#34;])):
                    ds = DataSource(**raw_data[i][&#34;data_sources&#34;][j], format=FORMAT_BASIC_INFO)
                    raw_data[i][&#34;data_sources&#34;][j] = ds

            # cast conjunctions
            self.data = [Conjunction(**c) for c in raw_data]

    def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait until the request is complete and data is
        available for retrieval

        Args:
            poll_interval (float): 
                Time in seconds to wait between polling attempts, defaults to 1 second

            verbose (bool): 
                Output poll times and other progress messages, defaults to False

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_REQUEST.format(self.request_id))
        self.update_status(requests_wait_for_data(self.__aurorax_obj, url, poll_interval, verbose))

    def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the conjunction search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait (bool): 
                Wait until the cancellation request has been completed (may wait for several minutes)

            poll_interval (float): 
                Seconds to wait between polling calls, defaults to STANDARD_POLLING_SLEEP_TIME.

            verbose (bool): 
                Output poll times and other progress messages, defaults to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_REQUEST.format(self.request_id))
        return requests_cancel(self.__aurorax_obj, url, wait, poll_interval, verbose)

    def describe(self):
        &#34;&#34;&#34;
        Describe the conjunction search as an &#34;SQL-like&#34; string.

        Returns:
            The &#34;SQL-like&#34; string describing the conjunction search object
        &#34;&#34;&#34;
        # make request
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DESCRIBE_CONJUNCTION_QUERY)
        req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query)
        res = req.execute()

        # return
        return res.data</code></pre>
</details>
<div class="desc"><p>Class representing a conjunction search</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Start timestamp of the search (inclusive).</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>End timestamp of the search (inclusive).</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>Dict</code></dt>
<dd>The maximum distance allowed between data sources when searching for
conjunctions. This can either be a number (int or float), or a dictionary
modified from the output of the "get_advanced_distances_combos()" function.</dd>
<dt><strong><code>ground</code></strong> :&ensp;<code>List[<a title="pyaurorax.search.GroundCriteriaBlock" href="#pyaurorax.search.GroundCriteriaBlock">GroundCriteriaBlock</a></code> or <code>Dict]</code></dt>
<dd>List of ground instrument criteria blocks, defaults to [].</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>List[<a title="pyaurorax.search.SpaceCriteriaBlock" href="#pyaurorax.search.SpaceCriteriaBlock">SpaceCriteriaBlock</a></code> or <code>Dict]</code></dt>
<dd>List of space instrument criteria blocks, defaults to [].</dd>
<dt><strong><code>events</code></strong> :&ensp;<code>List[<a title="pyaurorax.search.EventsCriteriaBlock" href="#pyaurorax.search.EventsCriteriaBlock">EventsCriteriaBlock</a></code> or <code>Dict]</code></dt>
<dd>List of event criteria blocks, defaults to [].</dd>
<dt><strong><code>custom_locations</code></strong> :&ensp;<code>List[<a title="pyaurorax.search.CustomLocationsCriteriaBlock" href="#pyaurorax.search.CustomLocationsCriteriaBlock">CustomLocationsCriteriaBlock</a></code> or <code>Dict]</code></dt>
<dd>List of custom location criteria blocks, defaults to [].</dd>
<dt><strong><code>conjunction_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of conjunction types, defaults to [] (meaning all conjunction types). Valid
options are 'nbtrace', 'sbtrace', and 'geographic'. Defaults to 'nbtrace'.</dd>
<dt><strong><code>response_format</code></strong> :&ensp;<code>Dict</code></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong> :&ensp;<code>AuroraXResponse</code></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique URL assigned to the request by the AuroraX API</dd>
<dt><strong><code>executed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the search has been executed/started</dd>
<dt><strong><code>completed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the search has finished</dd>
<dt><strong><code>data_url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL where data is accessed</dd>
<dt><strong><code>query</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The query for this request as JSON</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The status of the query</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>List[<a title="pyaurorax.search.Conjunction" href="#pyaurorax.search.Conjunction">Conjunction</a>]</code></dt>
<dd>The conjunctions found</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>List[Dict]</code></dt>
<dd>All log messages outputted by the AuroraX API for this request</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.ConjunctionSearch.distance"><code class="name">prop <span class="ident">distance</span> : Union[int, float, Dict[str, Union[int, float]]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def distance(self) -&gt; Union[int, float, Dict[str, Union[int, float]]]:
    &#34;&#34;&#34;
    Property for the distance parameter

    Returns:
        The distance dictionary with all combinations
    &#34;&#34;&#34;
    return self.__distance</code></pre>
</details>
<div class="desc"><p>Property for the distance parameter</p>
<h2 id="returns">Returns</h2>
<p>The distance dictionary with all combinations</p></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.query"><code class="name">prop <span class="ident">query</span> : Dict</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self) -&gt; Dict:
    &#34;&#34;&#34;
    Property for the query value

    Returns:
        The query parameter
    &#34;&#34;&#34;
    # set ground
    ground_param = self.ground
    if (isinstance(self.ground, list) and all(isinstance(item, GroundCriteriaBlock) for item in self.ground)):
        # ground parameter is a list of GroundCriteriaBlock objects, so we
        # want to set the query to the dict version of it
        ground_param = []
        for val in self.ground:
            this_dict = deepcopy(val.__dict__)
            this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;metadata_filters&#34;]
            del this_dict[&#34;metadata_filters&#34;]
            if (this_dict[&#34;ephemeris_metadata_filters&#34;] is not None):
                this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;ephemeris_metadata_filters&#34;].to_query_dict()
            ground_param.append(this_dict)

    # set space
    space_param = self.space
    if (isinstance(self.space, list) and all(isinstance(item, SpaceCriteriaBlock) for item in self.space)):
        # space parameter is a list of SpaceCriteriaBlock objects, so we
        # want to set the query to the dict version of it
        space_param = []
        for val in self.space:
            this_dict = deepcopy(val.__dict__)
            this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;metadata_filters&#34;]
            del this_dict[&#34;metadata_filters&#34;]
            if (this_dict[&#34;ephemeris_metadata_filters&#34;] is not None):
                this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;ephemeris_metadata_filters&#34;].to_query_dict()
            space_param.append(this_dict)

    # set events
    events_param = self.events
    if (isinstance(self.events, list) and all(isinstance(item, EventsCriteriaBlock) for item in self.events)):
        # space parameter is a list of EventsCriteriaBlock objects, so we
        # want to set the query to the dict version of it
        events_param = []
        for val in self.events:
            this_dict = deepcopy(val.__dict__)
            this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;metadata_filters&#34;]
            this_dict[&#34;programs&#34;] = [&#34;events&#34;]
            del this_dict[&#34;metadata_filters&#34;]
            if (this_dict[&#34;ephemeris_metadata_filters&#34;] is not None):
                this_dict[&#34;ephemeris_metadata_filters&#34;] = this_dict[&#34;ephemeris_metadata_filters&#34;].to_query_dict()
            events_param.append(this_dict)

    # set custom locations
    custom_param = self.custom_locations
    if (isinstance(self.custom_locations, list) and all(isinstance(item, CustomLocationsCriteriaBlock) for item in self.custom_locations)):
        # space parameter is a list of CustomLocationsCriteriaBlock objects, so we
        # want to set the query to the dict version of it
        custom_param = []
        for val in self.custom_locations:
            this_dict = val.to_search_query_dict()  # type: ignore
            custom_param.append(this_dict)

    # set query
    self.__query = {
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;ground&#34;: ground_param,
        &#34;space&#34;: space_param,
        &#34;events&#34;: events_param,
        &#34;adhoc&#34;: custom_param,
        &#34;conjunction_types&#34;: self.conjunction_types,
        &#34;max_distances&#34;: self.distance,
        &#34;epoch_search_precision&#34;: 60,
    }
    return self.__query</code></pre>
</details>
<div class="desc"><p>Property for the query value</p>
<h2 id="returns">Returns</h2>
<p>The query parameter</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.ConjunctionSearch.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: bool = False, poll_interval: float = 1.0, verbose: bool = False) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Cancel the conjunction search request

    This method returns immediately by default since the API processes
    this request asynchronously. If you would prefer to wait for it
    to be completed, set the &#39;wait&#39; parameter to True. You can adjust
    the polling time using the &#39;poll_interval&#39; parameter.

    Args:
        wait (bool): 
            Wait until the cancellation request has been completed (may wait for several minutes)

        poll_interval (float): 
            Seconds to wait between polling calls, defaults to STANDARD_POLLING_SLEEP_TIME.

        verbose (bool): 
            Output poll times and other progress messages, defaults to False

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_REQUEST.format(self.request_id))
    return requests_cancel(self.__aurorax_obj, url, wait, poll_interval, verbose)</code></pre>
</details>
<div class="desc"><p>Cancel the conjunction search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>Wait until the cancellation request has been completed (may wait for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Seconds to wait between polling calls, defaults to STANDARD_POLLING_SLEEP_TIME.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.check_criteria_block_count_validity"><code class="name flex">
<span>def <span class="ident">check_criteria_block_count_validity</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_criteria_block_count_validity(self) -&gt; None:
    &#34;&#34;&#34;
    Check the number of of criteria blocks to see if there
    is too many. A max of 10 is allowed by the AuroraX
    conjunction search engine. An exception is raised if
    it was determined to have too many.

    Raises:
        pyaurorax.exceptions.AuroraXError: Too many criteria blocks are found
    &#34;&#34;&#34;
    count_ground = 0
    count_space = 0
    count_events = 0
    count_custom_locations = 0
    if (self.ground is not None):
        count_ground = len(self.ground)
    if (self.space is not None):
        count_space = len(self.space)
    if (self.events is not None):
        count_events = len(self.events)
    if (self.custom_locations is not None):
        count_custom_locations = len(self.custom_locations)
    if ((count_ground + count_space + count_events + count_custom_locations) &gt; 10):
        raise AuroraXError(&#34;Number of criteria blocks exceeds 10, please reduce the count&#34;)</code></pre>
</details>
<div class="desc"><p>Check the number of of criteria blocks to see if there
is too many. A max of 10 is allowed by the AuroraX
conjunction search engine. An exception is raised if
it was determined to have too many.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXError" href="../exceptions.html#pyaurorax.exceptions.AuroraXError">AuroraXError</a></code></dt>
<dd>Too many criteria blocks are found</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Check to see if data is available for this conjunction
    search request

    Returns:
        True if data is available, else False

    Raises:
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    self.update_status()
    return self.completed</code></pre>
</details>
<div class="desc"><p>Check to see if data is available for this conjunction
search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self):
    &#34;&#34;&#34;
    Describe the conjunction search as an &#34;SQL-like&#34; string.

    Returns:
        The &#34;SQL-like&#34; string describing the conjunction search object
    &#34;&#34;&#34;
    # make request
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DESCRIBE_CONJUNCTION_QUERY)
    req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query)
    res = req.execute()

    # return
    return res.data</code></pre>
</details>
<div class="desc"><p>Describe the conjunction search as an "SQL-like" string.</p>
<h2 id="returns">Returns</h2>
<p>The "SQL-like" string describing the conjunction search object</p></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; None:
    &#34;&#34;&#34;
    Initiate a conjunction search request

    Raises:
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    # check number of criteria blocks
    self.check_criteria_block_count_validity()

    # do request
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_SEARCH)
    req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
    res = req.execute()

    # set request ID, request_url, executed
    self.executed = True
    if res.status_code == 202:
        # request successfully dispatched
        self.executed = True
        self.request_url = res.request.headers[&#34;location&#34;]
        self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

    # set request variable
    self.request = res</code></pre>
</details>
<div class="desc"><p>Initiate a conjunction search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.get_advanced_distances_combos"><code class="name flex">
<span>def <span class="ident">get_advanced_distances_combos</span></span>(<span>self, default_distance: Optional[Union[int, float]] = None) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_advanced_distances_combos(self, default_distance: Optional[Union[int, float]] = None) -&gt; Dict:
    &#34;&#34;&#34;
    Get the advanced distances combinations for this search

    Args:
        default_distance (int): 
            The default distance to use, defaults to None

    Returns:
        The advanced distances combinations
    &#34;&#34;&#34;
    # set input arrays
    options = []
    if (self.ground is not None):
        for i in range(0, len(self.ground)):
            options.append(&#34;ground%d&#34; % (i + 1))
    if (self.space is not None):
        for i in range(0, len(self.space)):
            options.append(&#34;space%d&#34; % (i + 1))
    if (self.events is not None):
        for i in range(0, len(self.events)):
            options.append(&#34;events%d&#34; % (i + 1))
    if (self.custom_locations is not None):
        for i in range(0, len(self.custom_locations)):
            options.append(&#34;adhoc%d&#34; % (i + 1))

    # derive all combinations of options of size 2
    combinations = {}
    for element in itertools.combinations(options, r=2):
        combinations[&#34;%s-%s&#34; % (element[0], element[1])] = default_distance

    # return
    return combinations</code></pre>
</details>
<div class="desc"><p>Get the advanced distances combinations for this search</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default_distance</code></strong> :&ensp;<code>int</code></dt>
<dd>The default distance to use, defaults to None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The advanced distances combinations</p></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; None:
    &#34;&#34;&#34;
    Retrieve the data available for this conjunction search request

    Raises:
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    # check if completed yet
    if (self.completed is False):
        print(&#34;No data available, update status or check for data first&#34;)
        return

    # get data
    raw_data = requests_get_data(self.__aurorax_obj, self.data_url, self.response_format, False)

    # set data variable
    if (self.response_format is not None):
        self.data = raw_data
    else:
        # cast data source objects
        for i in range(0, len(raw_data)):
            for j in range(0, len(raw_data[i][&#34;data_sources&#34;])):
                ds = DataSource(**raw_data[i][&#34;data_sources&#34;][j], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_sources&#34;][j] = ds

        # cast conjunctions
        self.data = [Conjunction(**c) for c in raw_data]</code></pre>
</details>
<div class="desc"><p>Retrieve the data available for this conjunction search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set status and query strings
    max_len = 80
    status_str = str(self.status)
    query_str = str(self.query)
    if (len(status_str) &gt; max_len):
        status_str = &#34;%s...&#34; % (status_str[0:max_len])
    if (len(query_str) &gt; max_len):
        query_str = &#34;%s...&#34; % (query_str[0:max_len])

    # set results string
    if (self.executed is True):
        if (len(self.data) == 0):
            data_str = &#34;[0 conjunction results]&#34;
        elif (len(self.data) == 1):
            data_str = &#34;[1 conjunction result]&#34;
        else:
            data_str = &#34;[%d conjunction results]&#34; % (len(self.data))
    else:
        data_str = &#34;&#34;

    # set logs string
    if (self.executed is True):
        if (len(self.logs) == 0):
            logs_str = &#34;[0 log messages]&#34;
        elif (len(self.logs) == 1):
            logs_str = &#34;[1 log message]&#34;
        else:
            logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
    else:
        logs_str = &#34;&#34;

    # print
    print(&#34;ConjunctionSearch:&#34;)
    print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
    print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
    print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
    print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
    print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
    print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
    print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
    print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
    print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
    print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self, status: Optional[Dict] = None) -&gt; None:
    &#34;&#34;&#34;
    Update the status of this conjunction search request

    Args:
        status (Dict): 
            The previously-retrieved status of this request (include
            to avoid requesting it from the API again), defaults to None

    Raises:
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    # get the status if it isn&#39;t passed in
    if (status is None):
        status = requests_get_status(self.__aurorax_obj, self.request_url)

    # check response
    if (status is None):
        raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

    # update request status by checking if data URI is set
    if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
        self.completed = True
        self.data_url = &#34;%s/data&#34; % (self.request_url)

    # set class variable &#34;status&#34; and &#34;logs&#34;
    self.status = status
    self.logs = status[&#34;logs&#34;]</code></pre>
</details>
<div class="desc"><p>Update the status of this conjunction search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The previously-retrieved status of this request (include
to avoid requesting it from the API again), defaults to None</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: float = 1.0, verbose: bool = False) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Block and wait until the request is complete and data is
    available for retrieval

    Args:
        poll_interval (float): 
            Time in seconds to wait between polling attempts, defaults to 1 second

        verbose (bool): 
            Output poll times and other progress messages, defaults to False

    Raises:
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_REQUEST.format(self.request_id))
    self.update_status(requests_wait_for_data(self.__aurorax_obj, url, poll_interval, verbose))</code></pre>
</details>
<div class="desc"><p>Block and wait until the request is complete and data is
available for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Time in seconds to wait between polling attempts, defaults to 1 second</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.CustomLocationsCriteriaBlock"><code class="flex name class">
<span>class <span class="ident">CustomLocationsCriteriaBlock</span></span>
<span>(</span><span>locations: List[Tuple[float, float]] = [])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomLocationsCriteriaBlock:
    &#34;&#34;&#34;
    Representation of a custom location criteria block used for conjunction searches. 

    Attributes:
        locations (List[Tuple[float, float]]): 
            List of locations to use in this criteria block. Location are 2-element tuples
            of (latitude, longitude). Latitude values must be between -90 and 90, and longitude
            values must be between -180 and 180. Optional, default is `[]`.
    &#34;&#34;&#34;

    def __init__(self, locations: List[Tuple[float, float]] = []):
        self.locations = locations

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;CustomLocationsCriteriaBlock(locations=%s)&#34; % (self.locations)

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        print(&#34;CustomLocationsCriteriaBlock:&#34;)
        print(&#34;  %-11s: %s&#34; % (&#34;locations&#34;, self.locations))

    def to_search_query_dict(self):
        query_dict = {}
        if (len(self.locations) &gt; 0):
            query_dict[&#34;locations&#34;] = []
            for location in self.locations:
                query_dict[&#34;locations&#34;].append({
                    &#34;lat&#34;: location[0],
                    &#34;lon&#34;: location[1],
                })
        return query_dict</code></pre>
</details>
<div class="desc"><p>Representation of a custom location criteria block used for conjunction searches. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>locations</code></strong> :&ensp;<code>List[Tuple[float, float]]</code></dt>
<dd>List of locations to use in this criteria block. Location are 2-element tuples
of (latitude, longitude). Latitude values must be between -90 and 90, and longitude
values must be between -180 and 180. Optional, default is <code>[]</code>.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.CustomLocationsCriteriaBlock.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    print(&#34;CustomLocationsCriteriaBlock:&#34;)
    print(&#34;  %-11s: %s&#34; % (&#34;locations&#34;, self.locations))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.CustomLocationsCriteriaBlock.to_search_query_dict"><code class="name flex">
<span>def <span class="ident">to_search_query_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_search_query_dict(self):
    query_dict = {}
    if (len(self.locations) &gt; 0):
        query_dict[&#34;locations&#34;] = []
        for location in self.locations:
            query_dict[&#34;locations&#34;].append({
                &#34;lat&#34;: location[0],
                &#34;lon&#34;: location[1],
            })
    return query_dict</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.DataProductData"><code class="flex name class">
<span>class <span class="ident">DataProductData</span></span>
<span>(</span><span>data_source: <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>,<br>data_product_type: str,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>url: str,<br>metadata: Dict | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataProductData:
    &#34;&#34;&#34;
    Data product object

    Attributes:
        data_source (DataSource): 
            Data source that the ephemeris record is associated with

        data_product_type (str): 
            Data product type (&#34;keogram&#34;, &#34;movie&#34;, &#34;summary_plot&#34;, etc.)

        start (datetime.datetime): 
            Starting timestamp for the record (assumed it is in UTC), inclusive

        end (datetime.datetime): 
            Ending timestamp for the record (assumed it is in UTC), inclusive

        url (str): 
            The URL of data product

        metadata (Dict): 
            Metadata for this record (arbitrary keys and values)
    &#34;&#34;&#34;

    def __init__(self,
                 data_source: DataSource,
                 data_product_type: str,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 url: str,
                 metadata: Optional[Dict] = None):
        self.data_source = data_source
        self.data_product_type = data_product_type
        self.start = start
        self.end = end
        self.url = url
        self.metadata = metadata

    def to_json_serializable(self) -&gt; Dict:
        &#34;&#34;&#34;
        Convert object to a JSON-serializable object (ie. translate
        datetime objects to strings)

        Returns:
            A dictionary object that is JSON-serializable
        &#34;&#34;&#34;
        # init
        d = self.__dict__

        # format epoch as str
        if (type(d[&#34;start&#34;]) is datetime.datetime):
            d[&#34;start&#34;] = d[&#34;start&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)
        if (type(d[&#34;end&#34;]) is datetime.datetime):
            d[&#34;end&#34;] = d[&#34;end&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)

        # format metadata
        if (self.metadata is not None):
            for key, value in self.metadata.items():
                if (isinstance(value, datetime.datetime) is True or isinstance(value, datetime.date) is True):
                    self.metadata[key] = self.metadata[key].strftime(&#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
        # if (isinstance(self.metadata, list) is True):
        #     self.metadata = {}

        # format data source fields for query
        d[&#34;program&#34;] = self.data_source.program
        d[&#34;platform&#34;] = self.data_source.platform
        d[&#34;instrument_type&#34;] = self.data_source.instrument_type
        del d[&#34;data_source&#34;]

        # return
        return d

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        # shorten the metadata and url
        max_len = 20
        attr_metadata = f&#34;{self.metadata}&#34;
        if (len(attr_metadata) &gt; max_len):
            attr_metadata = attr_metadata[0:max_len] + &#34;...}&#34;
        attr_url = f&#34;{self.url}&#34;
        if (len(attr_url) &gt; max_len):
            attr_url = attr_url[0:max_len] + &#34;...&#34;

        # return formatted representation
        return f&#34;DataProductData(start={repr(self.start)}, end={repr(self.end)}, data_product_type=&#39;{self.data_product_type}&#39;, &#34; \
            f&#34;url=&#39;{attr_url}&#39;, metadata={attr_metadata}, data_source=DataSource(...))&#34;</code></pre>
</details>
<div class="desc"><p>Data product object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_source</code></strong> :&ensp;<code><a title="pyaurorax.search.DataSource" href="#pyaurorax.search.DataSource">DataSource</a></code></dt>
<dd>Data source that the ephemeris record is associated with</dd>
<dt><strong><code>data_product_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Data product type ("keogram", "movie", "summary_plot", etc.)</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Starting timestamp for the record (assumed it is in UTC), inclusive</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Ending timestamp for the record (assumed it is in UTC), inclusive</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL of data product</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Metadata for this record (arbitrary keys and values)</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.DataProductData.to_json_serializable"><code class="name flex">
<span>def <span class="ident">to_json_serializable</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json_serializable(self) -&gt; Dict:
    &#34;&#34;&#34;
    Convert object to a JSON-serializable object (ie. translate
    datetime objects to strings)

    Returns:
        A dictionary object that is JSON-serializable
    &#34;&#34;&#34;
    # init
    d = self.__dict__

    # format epoch as str
    if (type(d[&#34;start&#34;]) is datetime.datetime):
        d[&#34;start&#34;] = d[&#34;start&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)
    if (type(d[&#34;end&#34;]) is datetime.datetime):
        d[&#34;end&#34;] = d[&#34;end&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)

    # format metadata
    if (self.metadata is not None):
        for key, value in self.metadata.items():
            if (isinstance(value, datetime.datetime) is True or isinstance(value, datetime.date) is True):
                self.metadata[key] = self.metadata[key].strftime(&#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
    # if (isinstance(self.metadata, list) is True):
    #     self.metadata = {}

    # format data source fields for query
    d[&#34;program&#34;] = self.data_source.program
    d[&#34;platform&#34;] = self.data_source.platform
    d[&#34;instrument_type&#34;] = self.data_source.instrument_type
    del d[&#34;data_source&#34;]

    # return
    return d</code></pre>
</details>
<div class="desc"><p>Convert object to a JSON-serializable object (ie. translate
datetime objects to strings)</p>
<h2 id="returns">Returns</h2>
<p>A dictionary object that is JSON-serializable</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.DataProductSearch"><code class="flex name class">
<span>class <span class="ident">DataProductSearch</span></span>
<span>(</span><span>aurorax_obj: PyAuroraX,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>programs: Optional[List[str]] = None,<br>platforms: Optional[List[str]] = None,<br>instrument_types: Optional[List[str]] = None,<br>data_product_types: "Optional[Literal['keogram', 'montage', 'movie', 'summary_plot', 'data_availability']]" = None,<br>metadata_filters: Optional[Union[<a title="pyaurorax.search.MetadataFilter" href="#pyaurorax.search.MetadataFilter">MetadataFilter</a>, List[Dict]]] = None,<br>metadata_filters_logical_operator: "Optional[Literal['and', 'or', 'AND', 'OR']]" = None,<br>response_format: Optional[Dict] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataProductSearch:
    &#34;&#34;&#34;
    Class representing a data product search

    Attributes:
        start (datetime.datetime): 
            Start timestamp of the search (inclusive)

        end (datetime.datetime): 
            End timestamp of the search (inclusive)

        programs (List[str]): 
            List of program names to search

        platforms (List[str]): 
            List of platform names to search

        instrument_types (List[str]): 
            List of instrument types to search

        data_product_types (List[str]): 
            List of strings describing data product types to filter on e.g. &#34;keogram&#34;, defaults 
            to None. Valid options are: `keogram`, `montage`, `movie`, `summary_plot`, and 
            `data_availability`.
    
        metadata_filters (MetadataFilter or List[Dict]): 
            The metadata filters to use when searching, defaults to None

        metadata_filters_logical_operator (str): 
            The logical operator to use when evaluating metadata filters (either `and` or `or`), 
            defaults to `and`. This parameter is deprecated in exchange for passing a 
            MetadataFilter object into the metadata_filters parameter. 

        response_format (Dict): 
            JSON representation of desired data response format

        request (AuroraXResponse): 
            AuroraXResponse object returned when the search is executed

        request_id (str): 
            Unique ID assigned to the request by the AuroraX API

        request_url (str): 
            Unique URL assigned to the request by the AuroraX API

        executed (bool): 
            Indicates if the search has been executed/started

        completed (bool): 
            Indicates if the search has finished

        data_url (str): 
            The URL where data is accessed

        query (Dict): 
            The query for this request as JSON

        status (Dict): 
            The status of the query

        data (List[DataProductData]): 
            The data product records found

        logs (List[Dict]): 
            All log messages outputted by the AuroraX API for this request
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0

    def __init__(self,
                 aurorax_obj: PyAuroraX,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 programs: Optional[List[str]] = None,
                 platforms: Optional[List[str]] = None,
                 instrument_types: Optional[List[str]] = None,
                 data_product_types: Optional[Literal[&#34;keogram&#34;, &#34;montage&#34;, &#34;movie&#34;, &#34;summary_plot&#34;, &#34;data_availability&#34;]] = None,
                 metadata_filters: Optional[Union[MetadataFilter, List[Dict]]] = None,
                 metadata_filters_logical_operator: Optional[Literal[&#34;and&#34;, &#34;or&#34;, &#34;AND&#34;, &#34;OR&#34;]] = None,
                 response_format: Optional[Dict] = None) -&gt; None:

        # set variables using passed in args
        self.__aurorax_obj = aurorax_obj
        self.start = start
        self.end = end
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.data_product_types = data_product_types
        self.metadata_filters = metadata_filters
        self.metadata_filters_logical_operator = &#34;AND&#34; if metadata_filters_logical_operator is None else metadata_filters_logical_operator
        self.response_format = response_format

        # initialize additional variables
        self.request = None
        self.request_id = &#34;&#34;
        self.request_url = &#34;&#34;
        self.executed = False
        self.completed = False
        self.data_url = &#34;&#34;
        self.__query = {}
        self.status = {}
        self.data = []
        self.logs = []

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;DataProductSearch(executed=%s, completed=%s, request_id=&#39;%s&#39;)&#34; % (
            self.executed,
            self.completed,
            self.request_id,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set status and query strings
        max_len = 80
        status_str = str(self.status)
        query_str = str(self.query)
        if (len(status_str) &gt; max_len):
            status_str = &#34;%s...&#34; % (status_str[0:max_len])
        if (len(query_str) &gt; max_len):
            query_str = &#34;%s...&#34; % (query_str[0:max_len])

        # set results string
        if (self.executed is True):
            if (len(self.data) == 0):
                data_str = &#34;[0 data product results]&#34;
            elif (len(self.data) == 1):
                data_str = &#34;[1 data product result]&#34;
            else:
                data_str = &#34;[%d data product results]&#34; % (len(self.data))
        else:
            data_str = &#34;&#34;

        # set logs string
        if (self.executed is True):
            if (len(self.logs) == 0):
                logs_str = &#34;[0 log messages]&#34;
            elif (len(self.logs) == 1):
                logs_str = &#34;[1 log message]&#34;
            else:
                logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
        else:
            logs_str = &#34;&#34;

        # print
        print(&#34;DataProductSearch:&#34;)
        print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
        print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
        print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
        print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
        print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
        print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
        print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
        print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
        print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))

    @property
    def query(self):
        &#34;&#34;&#34;
        Property for the query value
        &#34;&#34;&#34;
        # set metadata filter value
        if (self.metadata_filters is None):
            metadata_filters_dict = {}
        elif (isinstance(self.metadata_filters, MetadataFilter) is True):
            # metadata filter is a class
            metadata_filters_dict = self.metadata_filters.to_query_dict()  # type: ignore
        else:
            # metadata filter is a dictionary
            metadata_filters_dict = {
                &#34;expressions&#34;: self.metadata_filters,
                &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
            }

        # set query
        self.__query = {
            &#34;data_sources&#34;: {
                &#34;programs&#34;: [] if not self.programs else self.programs,
                &#34;platforms&#34;: [] if not self.platforms else self.platforms,
                &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
                &#34;data_product_metadata_filters&#34;: metadata_filters_dict,
            },
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;data_product_type_filters&#34;: [] if not self.data_product_types else self.data_product_types,
        }

        # return
        return self.__query

    @query.setter
    def query(self, query):
        self.__query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate a data product search request
        &#34;&#34;&#34;
        # do request
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_SEARCH)
        req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if (res.status_code == 202):
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this data product search request

        Args:
            status (Dict): 
                The previously-retrieved status of this request (include
                to avoid requesting it from the API again), defaults to None
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.__aurorax_obj, self.request_url)

        # check response
        if (status is None):
            raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s/data&#34; % (self.request_url)

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this data product
        search request

        Returns:
            True if data is available, else False
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this data product search request
        &#34;&#34;&#34;
        # check if completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.__aurorax_obj, self.data_url, self.response_format, False)

        # set data variable
        if (self.response_format is not None):
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_source&#34;] = ds

            # cast data product objects
            self.data = [DataProductData(**dp) for dp in raw_data]

    def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait for the request to complete and data is available
        for retrieval

        Args:
            poll_interval (float): 
                Time in seconds to wait between polling attempts, defaults to 1 second

            verbose (bool): 
                Output poll times and other progress messages, defaults to False
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_REQUEST.format(self.request_id))
        self.update_status(requests_wait_for_data(self.__aurorax_obj, url, poll_interval, verbose))

    def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the data product search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait (bool): 
                Wait until the cancellation request has been completed (may wait 
                for several minutes)
            
            poll_interval (float): 
                Seconds to wait between polling calls, defaults to 1 second.
            
            verbose (bool): 
                Output poll times and other progress messages, defaults to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
            pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_REQUEST.format(self.request_id))
        return requests_cancel(self.__aurorax_obj, url, wait, poll_interval, verbose)

    def describe(self):
        &#34;&#34;&#34;
        Describe the data products search as an &#34;SQL-like&#34; string.

        Returns:
            The &#34;SQL-like&#34; string describing the data products search object
        &#34;&#34;&#34;
        # make request
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DESCRIBE_DATA_PRODUCTS_QUERY)
        req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query)
        res = req.execute()

        # return
        return res.data</code></pre>
</details>
<div class="desc"><p>Class representing a data product search</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>End timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of program names to search</dd>
<dt><strong><code>platforms</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of platform names to search</dd>
<dt><strong><code>instrument_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of instrument types to search</dd>
<dt><strong><code>data_product_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of strings describing data product types to filter on e.g. "keogram", defaults
to None. Valid options are: <code>keogram</code>, <code>montage</code>, <code>movie</code>, <code>summary_plot</code>, and
<code>data_availability</code>.</dd>
<dt><strong><code>metadata_filters</code></strong> :&ensp;<code><a title="pyaurorax.search.MetadataFilter" href="#pyaurorax.search.MetadataFilter">MetadataFilter</a></code> or <code>List[Dict]</code></dt>
<dd>The metadata filters to use when searching, defaults to None</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong> :&ensp;<code>str</code></dt>
<dd>The logical operator to use when evaluating metadata filters (either <code>and</code> or <code>or</code>),
defaults to <code>and</code>. This parameter is deprecated in exchange for passing a
MetadataFilter object into the metadata_filters parameter. </dd>
<dt><strong><code>response_format</code></strong> :&ensp;<code>Dict</code></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong> :&ensp;<code>AuroraXResponse</code></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique URL assigned to the request by the AuroraX API</dd>
<dt><strong><code>executed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the search has been executed/started</dd>
<dt><strong><code>completed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the search has finished</dd>
<dt><strong><code>data_url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL where data is accessed</dd>
<dt><strong><code>query</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The query for this request as JSON</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The status of the query</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>List[<a title="pyaurorax.search.DataProductData" href="#pyaurorax.search.DataProductData">DataProductData</a>]</code></dt>
<dd>The data product records found</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>List[Dict]</code></dt>
<dd>All log messages outputted by the AuroraX API for this request</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.DataProductSearch.query"><code class="name">prop <span class="ident">query</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self):
    &#34;&#34;&#34;
    Property for the query value
    &#34;&#34;&#34;
    # set metadata filter value
    if (self.metadata_filters is None):
        metadata_filters_dict = {}
    elif (isinstance(self.metadata_filters, MetadataFilter) is True):
        # metadata filter is a class
        metadata_filters_dict = self.metadata_filters.to_query_dict()  # type: ignore
    else:
        # metadata filter is a dictionary
        metadata_filters_dict = {
            &#34;expressions&#34;: self.metadata_filters,
            &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
        }

    # set query
    self.__query = {
        &#34;data_sources&#34;: {
            &#34;programs&#34;: [] if not self.programs else self.programs,
            &#34;platforms&#34;: [] if not self.platforms else self.platforms,
            &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
            &#34;data_product_metadata_filters&#34;: metadata_filters_dict,
        },
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;data_product_type_filters&#34;: [] if not self.data_product_types else self.data_product_types,
    }

    # return
    return self.__query</code></pre>
</details>
<div class="desc"><p>Property for the query value</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.DataProductSearch.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: bool = False, poll_interval: float = 1.0, verbose: bool = False) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Cancel the data product search request

    This method returns immediately by default since the API processes
    this request asynchronously. If you would prefer to wait for it
    to be completed, set the &#39;wait&#39; parameter to True. You can adjust
    the polling time using the &#39;poll_interval&#39; parameter.

    Args:
        wait (bool): 
            Wait until the cancellation request has been completed (may wait 
            for several minutes)
        
        poll_interval (float): 
            Seconds to wait between polling calls, defaults to 1 second.
        
        verbose (bool): 
            Output poll times and other progress messages, defaults to False

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
    &#34;&#34;&#34;
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_REQUEST.format(self.request_id))
    return requests_cancel(self.__aurorax_obj, url, wait, poll_interval, verbose)</code></pre>
</details>
<div class="desc"><p>Cancel the data product search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>Wait until the cancellation request has been completed (may wait
for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Seconds to wait between polling calls, defaults to 1 second.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>Invalid API key for this operation</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Check to see if data is available for this data product
    search request

    Returns:
        True if data is available, else False
    &#34;&#34;&#34;
    self.update_status()
    return self.completed</code></pre>
</details>
<div class="desc"><p>Check to see if data is available for this data product
search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self):
    &#34;&#34;&#34;
    Describe the data products search as an &#34;SQL-like&#34; string.

    Returns:
        The &#34;SQL-like&#34; string describing the data products search object
    &#34;&#34;&#34;
    # make request
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DESCRIBE_DATA_PRODUCTS_QUERY)
    req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query)
    res = req.execute()

    # return
    return res.data</code></pre>
</details>
<div class="desc"><p>Describe the data products search as an "SQL-like" string.</p>
<h2 id="returns">Returns</h2>
<p>The "SQL-like" string describing the data products search object</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; None:
    &#34;&#34;&#34;
    Initiate a data product search request
    &#34;&#34;&#34;
    # do request
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_SEARCH)
    req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
    res = req.execute()

    # set request ID, request_url, executed
    self.executed = True
    if (res.status_code == 202):
        # request successfully dispatched
        self.executed = True
        self.request_url = res.request.headers[&#34;location&#34;]
        self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

    # set request variable
    self.request = res</code></pre>
</details>
<div class="desc"><p>Initiate a data product search request</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; None:
    &#34;&#34;&#34;
    Retrieve the data available for this data product search request
    &#34;&#34;&#34;
    # check if completed yet
    if (self.completed is False):
        print(&#34;No data available, update status or check for data first&#34;)
        return

    # get data
    raw_data = requests_get_data(self.__aurorax_obj, self.data_url, self.response_format, False)

    # set data variable
    if (self.response_format is not None):
        self.data = raw_data
    else:
        # cast data source objects
        for i in range(0, len(raw_data)):
            ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
            raw_data[i][&#34;data_source&#34;] = ds

        # cast data product objects
        self.data = [DataProductData(**dp) for dp in raw_data]</code></pre>
</details>
<div class="desc"><p>Retrieve the data available for this data product search request</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set status and query strings
    max_len = 80
    status_str = str(self.status)
    query_str = str(self.query)
    if (len(status_str) &gt; max_len):
        status_str = &#34;%s...&#34; % (status_str[0:max_len])
    if (len(query_str) &gt; max_len):
        query_str = &#34;%s...&#34; % (query_str[0:max_len])

    # set results string
    if (self.executed is True):
        if (len(self.data) == 0):
            data_str = &#34;[0 data product results]&#34;
        elif (len(self.data) == 1):
            data_str = &#34;[1 data product result]&#34;
        else:
            data_str = &#34;[%d data product results]&#34; % (len(self.data))
    else:
        data_str = &#34;&#34;

    # set logs string
    if (self.executed is True):
        if (len(self.logs) == 0):
            logs_str = &#34;[0 log messages]&#34;
        elif (len(self.logs) == 1):
            logs_str = &#34;[1 log message]&#34;
        else:
            logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
    else:
        logs_str = &#34;&#34;

    # print
    print(&#34;DataProductSearch:&#34;)
    print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
    print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
    print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
    print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
    print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
    print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
    print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
    print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
    print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
    print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self, status: Optional[Dict] = None) -&gt; None:
    &#34;&#34;&#34;
    Update the status of this data product search request

    Args:
        status (Dict): 
            The previously-retrieved status of this request (include
            to avoid requesting it from the API again), defaults to None
    &#34;&#34;&#34;
    # get the status if it isn&#39;t passed in
    if (status is None):
        status = requests_get_status(self.__aurorax_obj, self.request_url)

    # check response
    if (status is None):
        raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

    # update request status by checking if data URI is set
    if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
        self.completed = True
        self.data_url = &#34;%s/data&#34; % (self.request_url)

    # set class variable &#34;status&#34; and &#34;logs&#34;
    self.status = status
    self.logs = status[&#34;logs&#34;]</code></pre>
</details>
<div class="desc"><p>Update the status of this data product search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The previously-retrieved status of this request (include
to avoid requesting it from the API again), defaults to None</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: float = 1.0, verbose: bool = False) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Block and wait for the request to complete and data is available
    for retrieval

    Args:
        poll_interval (float): 
            Time in seconds to wait between polling attempts, defaults to 1 second

        verbose (bool): 
            Output poll times and other progress messages, defaults to False
    &#34;&#34;&#34;
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_REQUEST.format(self.request_id))
    self.update_status(requests_wait_for_data(self.__aurorax_obj, url, poll_interval, verbose))</code></pre>
</details>
<div class="desc"><p>Block and wait for the request to complete and data is available
for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Time in seconds to wait between polling attempts, defaults to 1 second</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.DataSource"><code class="flex name class">
<span>class <span class="ident">DataSource</span></span>
<span>(</span><span>identifier: int | None = None,<br>program: str | None = None,<br>platform: str | None = None,<br>instrument_type: str | None = None,<br>source_type: str | None = None,<br>display_name: str | None = None,<br>metadata: Dict | None = None,<br>owner: str | None = None,<br>maintainers: List[str] | None = None,<br>ephemeris_metadata_schema: List[Dict] | None = None,<br>data_product_metadata_schema: List[Dict] | None = None,<br>stats: <a title="pyaurorax.search.sources.classes.data_source_stats.DataSourceStatistics" href="sources/classes/data_source_stats.html#pyaurorax.search.sources.classes.data_source_stats.DataSourceStatistics">DataSourceStatistics</a> | None = None,<br>format: str = 'full_record')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataSource:
    &#34;&#34;&#34;
    AuroraX data source record

    Attributes:
        identifier (int): 
            The unique AuroraX data source identifier

        program (str): 
            The program for this data source

        platform (str): 
            The platform for this data source

        instrument_type (str): 
            The instrument type for this data source

        source_type (str): 
            The data source type for this data source. Options are in the 
            pyaurorax.search.sources module, or at the top level using the
            pyaurorax.search.SOURCE_TYPE_* variables.

        display_name (str): 
            The display name for this data source

        metadata (Dict): 
            Metadata for this data source (arbitrary keys and values)

        owner (str): 
            The owner&#39;s email address of this data source

        maintainers (List[str]): 
            The email addresses of AuroraX accounts that can alter this data source and 
            its associated records

        ephemeris_metadata_schema (Dict): 
            A list of dictionaries capturing the metadata keys and values that can appear 
            in ephemeris records associated with this data source

        data_product_metadata_schema (Dict): 
            A list of dictionaries capturing the metadata keys and values that can appear 
            in data product records associated with this data source

        stats (DataSourceStatistics): 
            Data source statistics information
            
        format (str): 
            The format used when printing the data source, defaults to `full_record`. Other 
            options are in the pyaurorax.search.sources module, or at the top level using 
            the pyaurorax.search.FORMAT_* variables.
    &#34;&#34;&#34;

    def __init__(self,
                 identifier: Optional[int] = None,
                 program: Optional[str] = None,
                 platform: Optional[str] = None,
                 instrument_type: Optional[str] = None,
                 source_type: Optional[str] = None,
                 display_name: Optional[str] = None,
                 metadata: Optional[Dict] = None,
                 owner: Optional[str] = None,
                 maintainers: Optional[List[str]] = None,
                 ephemeris_metadata_schema: Optional[List[Dict]] = None,
                 data_product_metadata_schema: Optional[List[Dict]] = None,
                 stats: Optional[DataSourceStatistics] = None,
                 format: str = FORMAT_FULL_RECORD):
        self.identifier = identifier
        self.program = program
        self.platform = platform
        self.instrument_type = instrument_type
        self.source_type = source_type
        self.display_name = display_name
        self.metadata = metadata
        self.owner = owner
        self.maintainers = maintainers
        self.ephemeris_metadata_schema = ephemeris_metadata_schema
        self.data_product_metadata_schema = data_product_metadata_schema
        self.stats = stats
        self.format = format

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;DataSource(identifier=%s, program=&#39;%s&#39;, platform=&#39;%s&#39;, instrument_type=&#39;%s&#39;, source_type=&#39;%s&#39;, display_name=&#39;%s&#39;, ...)&#34; % (
            self.identifier,
            self.program,
            self.platform,
            self.instrument_type,
            self.source_type,
            self.display_name,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        max_len = 80
        print(&#34;DataSource:&#34;)
        print(&#34;  %-30s: %d&#34; % (&#34;identifier&#34;, self.identifier))
        print(&#34;  %-30s: %s&#34; % (&#34;program&#34;, self.program))
        print(&#34;  %-30s: %s&#34; % (&#34;platform&#34;, self.platform))
        print(&#34;  %-30s: %s&#34; % (&#34;instrument_type&#34;, self.instrument_type))
        print(&#34;  %-30s: %s&#34; % (&#34;source_type&#34;, self.source_type))
        print(&#34;  %-30s: %s&#34; % (&#34;display_name&#34;, self.display_name))
        print(&#34;  %-30s: %s&#34; % (&#34;metadata&#34;, self.metadata))
        print(&#34;  %-30s: %s&#34; % (&#34;owner&#34;, self.owner))
        print(&#34;  %-30s: %s&#34; % (&#34;maintainers&#34;, self.maintainers))
        if (self.ephemeris_metadata_schema is not None and len(str(self.ephemeris_metadata_schema)) &gt; max_len):
            ephemeris_metadata_schema_str = &#34;%s...&#34; % (str(self.ephemeris_metadata_schema)[0:max_len])
        else:
            ephemeris_metadata_schema_str = self.ephemeris_metadata_schema
        print(&#34;  %-30s: %s&#34; % (&#34;ephemeris_metadata_schema&#34;, ephemeris_metadata_schema_str))
        if (self.data_product_metadata_schema is not None and len(str(self.data_product_metadata_schema)) &gt; max_len):
            data_product_metadata_schema_str = &#34;%s...&#34; % (str(self.data_product_metadata_schema)[0:max_len])
        else:
            data_product_metadata_schema_str = self.data_product_metadata_schema
        print(&#34;  %-30s: %s&#34; % (&#34;data_product_metadata_schema&#34;, data_product_metadata_schema_str))
        if (self.stats is not None and len(str(self.stats)) &gt; max_len):
            stats_str = &#34;%s...&#34; % (str(self.stats)[0:max_len])
        else:
            stats_str = self.data_product_metadata_schema
        print(&#34;  %-30s: %s&#34; % (&#34;stats&#34;, stats_str))
        print(&#34;  %-30s: %s&#34; % (&#34;format&#34;, self.format))</code></pre>
</details>
<div class="desc"><p>AuroraX data source record</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>int</code></dt>
<dd>The unique AuroraX data source identifier</dd>
<dt><strong><code>program</code></strong> :&ensp;<code>str</code></dt>
<dd>The program for this data source</dd>
<dt><strong><code>platform</code></strong> :&ensp;<code>str</code></dt>
<dd>The platform for this data source</dd>
<dt><strong><code>instrument_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The instrument type for this data source</dd>
<dt><strong><code>source_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The data source type for this data source. Options are in the
pyaurorax.search.sources module, or at the top level using the
pyaurorax.search.SOURCE_TYPE_* variables.</dd>
<dt><strong><code>display_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The display name for this data source</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Metadata for this data source (arbitrary keys and values)</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>str</code></dt>
<dd>The owner's email address of this data source</dd>
<dt><strong><code>maintainers</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>The email addresses of AuroraX accounts that can alter this data source and
its associated records</dd>
<dt><strong><code>ephemeris_metadata_schema</code></strong> :&ensp;<code>Dict</code></dt>
<dd>A list of dictionaries capturing the metadata keys and values that can appear
in ephemeris records associated with this data source</dd>
<dt><strong><code>data_product_metadata_schema</code></strong> :&ensp;<code>Dict</code></dt>
<dd>A list of dictionaries capturing the metadata keys and values that can appear
in data product records associated with this data source</dd>
<dt><strong><code>stats</code></strong> :&ensp;<code>DataSourceStatistics</code></dt>
<dd>Data source statistics information</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The format used when printing the data source, defaults to <code>full_record</code>. Other
options are in the pyaurorax.search.sources module, or at the top level using
the pyaurorax.search.FORMAT_* variables.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.DataSource.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    max_len = 80
    print(&#34;DataSource:&#34;)
    print(&#34;  %-30s: %d&#34; % (&#34;identifier&#34;, self.identifier))
    print(&#34;  %-30s: %s&#34; % (&#34;program&#34;, self.program))
    print(&#34;  %-30s: %s&#34; % (&#34;platform&#34;, self.platform))
    print(&#34;  %-30s: %s&#34; % (&#34;instrument_type&#34;, self.instrument_type))
    print(&#34;  %-30s: %s&#34; % (&#34;source_type&#34;, self.source_type))
    print(&#34;  %-30s: %s&#34; % (&#34;display_name&#34;, self.display_name))
    print(&#34;  %-30s: %s&#34; % (&#34;metadata&#34;, self.metadata))
    print(&#34;  %-30s: %s&#34; % (&#34;owner&#34;, self.owner))
    print(&#34;  %-30s: %s&#34; % (&#34;maintainers&#34;, self.maintainers))
    if (self.ephemeris_metadata_schema is not None and len(str(self.ephemeris_metadata_schema)) &gt; max_len):
        ephemeris_metadata_schema_str = &#34;%s...&#34; % (str(self.ephemeris_metadata_schema)[0:max_len])
    else:
        ephemeris_metadata_schema_str = self.ephemeris_metadata_schema
    print(&#34;  %-30s: %s&#34; % (&#34;ephemeris_metadata_schema&#34;, ephemeris_metadata_schema_str))
    if (self.data_product_metadata_schema is not None and len(str(self.data_product_metadata_schema)) &gt; max_len):
        data_product_metadata_schema_str = &#34;%s...&#34; % (str(self.data_product_metadata_schema)[0:max_len])
    else:
        data_product_metadata_schema_str = self.data_product_metadata_schema
    print(&#34;  %-30s: %s&#34; % (&#34;data_product_metadata_schema&#34;, data_product_metadata_schema_str))
    if (self.stats is not None and len(str(self.stats)) &gt; max_len):
        stats_str = &#34;%s...&#34; % (str(self.stats)[0:max_len])
    else:
        stats_str = self.data_product_metadata_schema
    print(&#34;  %-30s: %s&#34; % (&#34;stats&#34;, stats_str))
    print(&#34;  %-30s: %s&#34; % (&#34;format&#34;, self.format))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.EphemerisData"><code class="flex name class">
<span>class <span class="ident">EphemerisData</span></span>
<span>(</span><span>data_source: <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>,<br>epoch: datetime.datetime,<br>location_geo: <a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a> | None = None,<br>nbtrace: <a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a> | None = None,<br>sbtrace: <a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a> | None = None,<br>location_gsm: <a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a> | None = None,<br>metadata: Dict | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EphemerisData:
    &#34;&#34;&#34;
    Ephemeris object

    Attributes:
        data_source (DataSource): 
            Data source that the ephemeris record is associated with

        epoch (datetime.datetime): 
            Timestamp for the record (assumed it is in UTC)

        location_geo (Location): 
            Location object containing geographic latitude and longitude

        location_gsm (Location): 
            Location object containing GSM latitude and longitude (leave empty for data 
            sources with a type of &#39;ground&#39;)

        nbtrace (Location): 
            Location object with north B-trace geographic latitude and longitude

        sbtrace (Location): 
            Location object with south B-trace geographic latitude and longitude

        metadata (Dict): 
            Metadata for this record (arbitrary keys and values)
    &#34;&#34;&#34;

    def __init__(self,
                 data_source: DataSource,
                 epoch: datetime.datetime,
                 location_geo: Optional[Location] = None,
                 nbtrace: Optional[Location] = None,
                 sbtrace: Optional[Location] = None,
                 location_gsm: Optional[Location] = None,
                 metadata: Optional[Dict] = None):
        self.data_source = data_source
        self.epoch = epoch
        self.location_geo = Location(lat=None, lon=None) if location_geo is None else location_geo
        self.nbtrace = Location(lat=None, lon=None) if nbtrace is None else nbtrace
        self.sbtrace = Location(lat=None, lon=None) if sbtrace is None else sbtrace
        self.location_gsm = Location(lat=None, lon=None) if location_gsm is None else location_gsm
        self.metadata = metadata

    def to_json_serializable(self) -&gt; Dict:
        &#34;&#34;&#34;
        Convert object to a JSON-serializable object (ie. translate
        datetime objects to strings)

        Returns:
            A dictionary object that is JSON-serializable
        &#34;&#34;&#34;
        # init
        d = self.__dict__

        # format epoch as str
        if (isinstance(d[&#34;epoch&#34;], datetime.datetime) is True):
            d[&#34;epoch&#34;] = d[&#34;epoch&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000Z&#34;)

        # format location
        if (isinstance(d[&#34;location_geo&#34;], Location) is True):
            d[&#34;location_geo&#34;] = d[&#34;location_geo&#34;].to_json_serializable()
        if (isinstance(d[&#34;location_gsm&#34;], Location) is True):
            d[&#34;location_gsm&#34;] = d[&#34;location_gsm&#34;].to_json_serializable()
        if (isinstance(d[&#34;nbtrace&#34;], Location) is True):
            d[&#34;nbtrace&#34;] = d[&#34;nbtrace&#34;].to_json_serializable()
        if (isinstance(d[&#34;sbtrace&#34;], Location) is True):
            d[&#34;sbtrace&#34;] = d[&#34;sbtrace&#34;].to_json_serializable()

        # format metadata
        if (self.metadata is not None):
            for key, value in self.metadata.items():
                if (isinstance(value, datetime.datetime) is True or isinstance(value, datetime.date) is True):
                    self.metadata[key] = self.metadata[key].strftime(&#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
        # if (isinstance(self.metadata, list) is True):
        #     self.metadata = {}

        # format data source fields for query
        d[&#34;program&#34;] = self.data_source.program
        d[&#34;platform&#34;] = self.data_source.platform
        d[&#34;instrument_type&#34;] = self.data_source.instrument_type
        del d[&#34;data_source&#34;]

        # return
        return d

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        # shorten the metadata
        max_len = 20
        attr_metadata = f&#34;{self.metadata}&#34;
        if (len(attr_metadata) &gt; max_len):
            attr_metadata = attr_metadata[0:max_len] + &#34;...}&#34;

        # return formatted representation
        return f&#34;EphemerisData(epoch={repr(self.epoch)}, location_geo={repr(self.location_geo)}, &#34; \
            f&#34;location_gsm={repr(self.location_gsm)}, nbtrace={repr(self.nbtrace)}, sbtrace={repr(self.sbtrace)}, &#34; \
            f&#34;metadata={attr_metadata}, data_source=DataSource(...))&#34;</code></pre>
</details>
<div class="desc"><p>Ephemeris object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_source</code></strong> :&ensp;<code><a title="pyaurorax.search.DataSource" href="#pyaurorax.search.DataSource">DataSource</a></code></dt>
<dd>Data source that the ephemeris record is associated with</dd>
<dt><strong><code>epoch</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Timestamp for the record (assumed it is in UTC)</dd>
<dt><strong><code>location_geo</code></strong> :&ensp;<code><a title="pyaurorax.search.Location" href="#pyaurorax.search.Location">Location</a></code></dt>
<dd>Location object containing geographic latitude and longitude</dd>
<dt><strong><code>location_gsm</code></strong> :&ensp;<code><a title="pyaurorax.search.Location" href="#pyaurorax.search.Location">Location</a></code></dt>
<dd>Location object containing GSM latitude and longitude (leave empty for data
sources with a type of 'ground')</dd>
<dt><strong><code>nbtrace</code></strong> :&ensp;<code><a title="pyaurorax.search.Location" href="#pyaurorax.search.Location">Location</a></code></dt>
<dd>Location object with north B-trace geographic latitude and longitude</dd>
<dt><strong><code>sbtrace</code></strong> :&ensp;<code><a title="pyaurorax.search.Location" href="#pyaurorax.search.Location">Location</a></code></dt>
<dd>Location object with south B-trace geographic latitude and longitude</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Metadata for this record (arbitrary keys and values)</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.EphemerisData.to_json_serializable"><code class="name flex">
<span>def <span class="ident">to_json_serializable</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json_serializable(self) -&gt; Dict:
    &#34;&#34;&#34;
    Convert object to a JSON-serializable object (ie. translate
    datetime objects to strings)

    Returns:
        A dictionary object that is JSON-serializable
    &#34;&#34;&#34;
    # init
    d = self.__dict__

    # format epoch as str
    if (isinstance(d[&#34;epoch&#34;], datetime.datetime) is True):
        d[&#34;epoch&#34;] = d[&#34;epoch&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000Z&#34;)

    # format location
    if (isinstance(d[&#34;location_geo&#34;], Location) is True):
        d[&#34;location_geo&#34;] = d[&#34;location_geo&#34;].to_json_serializable()
    if (isinstance(d[&#34;location_gsm&#34;], Location) is True):
        d[&#34;location_gsm&#34;] = d[&#34;location_gsm&#34;].to_json_serializable()
    if (isinstance(d[&#34;nbtrace&#34;], Location) is True):
        d[&#34;nbtrace&#34;] = d[&#34;nbtrace&#34;].to_json_serializable()
    if (isinstance(d[&#34;sbtrace&#34;], Location) is True):
        d[&#34;sbtrace&#34;] = d[&#34;sbtrace&#34;].to_json_serializable()

    # format metadata
    if (self.metadata is not None):
        for key, value in self.metadata.items():
            if (isinstance(value, datetime.datetime) is True or isinstance(value, datetime.date) is True):
                self.metadata[key] = self.metadata[key].strftime(&#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
    # if (isinstance(self.metadata, list) is True):
    #     self.metadata = {}

    # format data source fields for query
    d[&#34;program&#34;] = self.data_source.program
    d[&#34;platform&#34;] = self.data_source.platform
    d[&#34;instrument_type&#34;] = self.data_source.instrument_type
    del d[&#34;data_source&#34;]

    # return
    return d</code></pre>
</details>
<div class="desc"><p>Convert object to a JSON-serializable object (ie. translate
datetime objects to strings)</p>
<h2 id="returns">Returns</h2>
<p>A dictionary object that is JSON-serializable</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.EphemerisSearch"><code class="flex name class">
<span>class <span class="ident">EphemerisSearch</span></span>
<span>(</span><span>aurorax_obj: PyAuroraX,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>programs: Optional[List[str]] = None,<br>platforms: Optional[List[str]] = None,<br>instrument_types: Optional[List[str]] = None,<br>metadata_filters: Optional[Union[<a title="pyaurorax.search.MetadataFilter" href="#pyaurorax.search.MetadataFilter">MetadataFilter</a>, List[Dict]]] = None,<br>metadata_filters_logical_operator: "Optional[Literal['and', 'or', 'AND', 'OR']]" = None,<br>response_format: Optional[Dict] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EphemerisSearch:
    &#34;&#34;&#34;
    Class representing an ephemeris search

    Note: At least one search criteria from programs, platforms, or instrument_types
    must be specified.

    Attributes:
        start (datetime.datetime): 
            Start timestamp of the search (inclusive)

        end (datetime.datetime): 
            End timestamp of the search (inclusive)

        programs (List[str]): 
            List of programs to search through, defaults to None

        platforms (List[str]): 
            List of platforms to search through, defaults to None

        instrument_types (List[str]): 
            List of instrument types to search through, defaults to None

        metadata_filters (MetadataFilter or List[Dict]): 
            List of dictionaries describing metadata keys and values to filter on, defaults 
            to None

        metadata_filters_logical_operator (str): 
            The logical operator to use when evaluating metadata filters (either `AND` or `OR`), 
            defaults to `AND`

        response_format (Dict): 
            JSON representation of desired data response format
        
        request (AuroraXResponse): 
            AuroraXResponse object returned when the search is executed
        
        request_id (str): 
            Unique ID assigned to the request by the AuroraX API
       
        request_url (str): 
            Unique URL assigned to the request by the AuroraX API
     
        executed (bool): 
            Indicates if the search has been executed/started
     
        completed (bool): 
            Indicates if the search has finished
       
        data_url (str): 
            The URL where data is accessed
      
        query (Dict): 
            The query for this request as JSON
      
        status (Dict): 
            The status of the query
      
        data (List[EphemerisData]): 
            The ephemeris records found
      
        logs (List[Dict]): 
            All log messages outputted by the AuroraX API for this request
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0

    def __init__(self,
                 aurorax_obj: PyAuroraX,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 programs: Optional[List[str]] = None,
                 platforms: Optional[List[str]] = None,
                 instrument_types: Optional[List[str]] = None,
                 metadata_filters: Optional[Union[MetadataFilter, List[Dict]]] = None,
                 metadata_filters_logical_operator: Optional[Literal[&#34;and&#34;, &#34;or&#34;, &#34;AND&#34;, &#34;OR&#34;]] = None,
                 response_format: Optional[Dict] = None) -&gt; None:

        # set variables using passed in args
        self.__aurorax_obj = aurorax_obj
        self.start = start
        self.end = end
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.metadata_filters = metadata_filters
        self.metadata_filters_logical_operator = &#34;AND&#34; if metadata_filters_logical_operator is None else metadata_filters_logical_operator.upper()
        self.response_format = response_format

        # initialize additional variables
        self.request = None
        self.request_id = &#34;&#34;
        self.request_url = &#34;&#34;
        self.executed = False
        self.completed = False
        self.data_url = &#34;&#34;
        self.__query = {}
        self.status = {}
        self.data = []
        self.logs = []

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;EphemerisSearch(executed=%s, completed=%s, request_id=&#39;%s&#39;)&#34; % (
            self.executed,
            self.completed,
            self.request_id,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set status and query strings
        max_len = 80
        status_str = str(self.status)
        query_str = str(self.query)
        if (len(status_str) &gt; max_len):
            status_str = &#34;%s...&#34; % (status_str[0:max_len])
        if (len(query_str) &gt; max_len):
            query_str = &#34;%s...&#34; % (query_str[0:max_len])

        # set results string
        if (self.executed is True):
            if (len(self.data) == 0):
                data_str = &#34;[0 ephemeris results]&#34;
            elif (len(self.data) == 1):
                data_str = &#34;[1 ephemeris result]&#34;
            else:
                data_str = &#34;[%d ephemeris results]&#34; % (len(self.data))
        else:
            data_str = &#34;&#34;

        # set logs string
        if (self.executed is True):
            if (len(self.logs) == 0):
                logs_str = &#34;[0 log messages]&#34;
            elif (len(self.logs) == 1):
                logs_str = &#34;[1 log message]&#34;
            else:
                logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
        else:
            logs_str = &#34;&#34;

        # print
        print(&#34;EphemerisSearch:&#34;)
        print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
        print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
        print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
        print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
        print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
        print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
        print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
        print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
        print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))

    @property
    def query(self):
        &#34;&#34;&#34;
        Property for the query value
        &#34;&#34;&#34;
        # set metadata filter value
        if (self.metadata_filters is None):
            metadata_filters_dict = {}
        elif (isinstance(self.metadata_filters, MetadataFilter) is True):
            # metadata filter is a class
            metadata_filters_dict = self.metadata_filters.to_query_dict()  # type: ignore
        else:
            # metadata filter is a dictionary
            metadata_filters_dict = {
                &#34;expressions&#34;: self.metadata_filters,
                &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
            }

        # set query
        self.__query = {
            &#34;data_sources&#34;: {
                &#34;programs&#34;: [] if not self.programs else self.programs,
                &#34;platforms&#34;: [] if not self.platforms else self.platforms,
                &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
                &#34;ephemeris_metadata_filters&#34;: metadata_filters_dict,
            },
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        }

        # return
        return self.__query

    @query.setter
    def query(self, query):
        self.__query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate ephemeris search request

        Raises:
            pyaurorax.exceptions.AuroraXError: Invalid request parameters are set
        &#34;&#34;&#34;
        # check for at least one filter criteria
        if not (self.programs or self.platforms or self.instrument_types or self.metadata_filters):
            raise AuroraXError(&#34;At least one filter criteria parameter besides &#39;start&#39; and &#39;end&#39; must be specified&#34;)

        # do request
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_SEARCH)
        req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if (res.status_code == 202):
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set the request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this ephemeris search request

        Args:
            status (Dict): 
                The previously-retrieved status of this request (include to avoid requesting it 
                from the API again), defaults to None
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.__aurorax_obj, self.request_url)

        # check response
        if (status is None):
            raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s/data&#34; % (self.request_url)

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this ephemeris search request

        Returns:
            True if data is available, else False
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this ephemeris search request
        &#34;&#34;&#34;
        # check if completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.__aurorax_obj, self.data_url, self.response_format, False)

        # set data variable
        if (self.response_format is not None):
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_source&#34;] = ds

            # cast ephemeris objects
            self.data = [EphemerisData(**e) for e in raw_data]

    def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait for the request to complete and data is available for retrieval

        Args:
            poll_interval (float): 
                Time in seconds to wait between polling attempts, defaults to 1 second

            verbose (bool): 
                Output poll times and other progress messages, defaults to False
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
        self.update_status(requests_wait_for_data(self.__aurorax_obj, url, poll_interval, verbose))

    def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the ephemeris search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait (bool): 
                Wait until the cancellation request has been completed (may wait for 
                several minutes)

            poll_interval (float): 
                Seconds to wait between polling calls, defaults to 1 second

            verbose (bool): 
                Output poll times and other progress messages, defaults to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
        return requests_cancel(self.__aurorax_obj, url, wait, poll_interval, verbose)

    def describe(self):
        &#34;&#34;&#34;
        Describe the ephemeris search as an &#34;SQL-like&#34; string.

        Returns:
            The &#34;SQL-like&#34; string describing the ephemeris search object
        &#34;&#34;&#34;
        # make request
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DESCRIBE_EPHEMERIS_QUERY)
        req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query)
        res = req.execute()

        # return
        return res.data</code></pre>
</details>
<div class="desc"><p>Class representing an ephemeris search</p>
<p>Note: At least one search criteria from programs, platforms, or instrument_types
must be specified.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>End timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of programs to search through, defaults to None</dd>
<dt><strong><code>platforms</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of platforms to search through, defaults to None</dd>
<dt><strong><code>instrument_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of instrument types to search through, defaults to None</dd>
<dt><strong><code>metadata_filters</code></strong> :&ensp;<code><a title="pyaurorax.search.MetadataFilter" href="#pyaurorax.search.MetadataFilter">MetadataFilter</a></code> or <code>List[Dict]</code></dt>
<dd>List of dictionaries describing metadata keys and values to filter on, defaults
to None</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong> :&ensp;<code>str</code></dt>
<dd>The logical operator to use when evaluating metadata filters (either <code>AND</code> or <code>OR</code>),
defaults to <code>AND</code></dd>
<dt><strong><code>response_format</code></strong> :&ensp;<code>Dict</code></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong> :&ensp;<code>AuroraXResponse</code></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Unique URL assigned to the request by the AuroraX API</p>
<p>executed (bool):
Indicates if the search has been executed/started</p>
<p>completed (bool):
Indicates if the search has finished</p>
<p>data_url (str):
The URL where data is accessed</p>
<p>query (Dict):
The query for this request as JSON</p>
<p>status (Dict):
The status of the query</p>
<p>data (List[EphemerisData]):
The ephemeris records found</p>
<p>logs (List[Dict]):
All log messages outputted by the AuroraX API for this request</p>
</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.EphemerisSearch.query"><code class="name">prop <span class="ident">query</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self):
    &#34;&#34;&#34;
    Property for the query value
    &#34;&#34;&#34;
    # set metadata filter value
    if (self.metadata_filters is None):
        metadata_filters_dict = {}
    elif (isinstance(self.metadata_filters, MetadataFilter) is True):
        # metadata filter is a class
        metadata_filters_dict = self.metadata_filters.to_query_dict()  # type: ignore
    else:
        # metadata filter is a dictionary
        metadata_filters_dict = {
            &#34;expressions&#34;: self.metadata_filters,
            &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
        }

    # set query
    self.__query = {
        &#34;data_sources&#34;: {
            &#34;programs&#34;: [] if not self.programs else self.programs,
            &#34;platforms&#34;: [] if not self.platforms else self.platforms,
            &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
            &#34;ephemeris_metadata_filters&#34;: metadata_filters_dict,
        },
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
    }

    # return
    return self.__query</code></pre>
</details>
<div class="desc"><p>Property for the query value</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.EphemerisSearch.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: bool = False, poll_interval: float = 1.0, verbose: bool = False) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Cancel the ephemeris search request

    This method returns immediately by default since the API processes
    this request asynchronously. If you would prefer to wait for it
    to be completed, set the &#39;wait&#39; parameter to True. You can adjust
    the polling time using the &#39;poll_interval&#39; parameter.

    Args:
        wait (bool): 
            Wait until the cancellation request has been completed (may wait for 
            several minutes)

        poll_interval (float): 
            Seconds to wait between polling calls, defaults to 1 second

        verbose (bool): 
            Output poll times and other progress messages, defaults to False

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
    return requests_cancel(self.__aurorax_obj, url, wait, poll_interval, verbose)</code></pre>
</details>
<div class="desc"><p>Cancel the ephemeris search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>Wait until the cancellation request has been completed (may wait for
several minutes)</dd>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Seconds to wait between polling calls, defaults to 1 second</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>Invalid API key for this operation</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Check to see if data is available for this ephemeris search request

    Returns:
        True if data is available, else False
    &#34;&#34;&#34;
    self.update_status()
    return self.completed</code></pre>
</details>
<div class="desc"><p>Check to see if data is available for this ephemeris search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self):
    &#34;&#34;&#34;
    Describe the ephemeris search as an &#34;SQL-like&#34; string.

    Returns:
        The &#34;SQL-like&#34; string describing the ephemeris search object
    &#34;&#34;&#34;
    # make request
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DESCRIBE_EPHEMERIS_QUERY)
    req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query)
    res = req.execute()

    # return
    return res.data</code></pre>
</details>
<div class="desc"><p>Describe the ephemeris search as an "SQL-like" string.</p>
<h2 id="returns">Returns</h2>
<p>The "SQL-like" string describing the ephemeris search object</p></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; None:
    &#34;&#34;&#34;
    Initiate ephemeris search request

    Raises:
        pyaurorax.exceptions.AuroraXError: Invalid request parameters are set
    &#34;&#34;&#34;
    # check for at least one filter criteria
    if not (self.programs or self.platforms or self.instrument_types or self.metadata_filters):
        raise AuroraXError(&#34;At least one filter criteria parameter besides &#39;start&#39; and &#39;end&#39; must be specified&#34;)

    # do request
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_SEARCH)
    req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
    res = req.execute()

    # set request ID, request_url, executed
    self.executed = True
    if (res.status_code == 202):
        # request successfully dispatched
        self.executed = True
        self.request_url = res.request.headers[&#34;location&#34;]
        self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

    # set the request variable
    self.request = res</code></pre>
</details>
<div class="desc"><p>Initiate ephemeris search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXError" href="../exceptions.html#pyaurorax.exceptions.AuroraXError">AuroraXError</a></code></dt>
<dd>Invalid request parameters are set</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; None:
    &#34;&#34;&#34;
    Retrieve the data available for this ephemeris search request
    &#34;&#34;&#34;
    # check if completed yet
    if (self.completed is False):
        print(&#34;No data available, update status or check for data first&#34;)
        return

    # get data
    raw_data = requests_get_data(self.__aurorax_obj, self.data_url, self.response_format, False)

    # set data variable
    if (self.response_format is not None):
        self.data = raw_data
    else:
        # cast data source objects
        for i in range(0, len(raw_data)):
            ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
            raw_data[i][&#34;data_source&#34;] = ds

        # cast ephemeris objects
        self.data = [EphemerisData(**e) for e in raw_data]</code></pre>
</details>
<div class="desc"><p>Retrieve the data available for this ephemeris search request</p></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set status and query strings
    max_len = 80
    status_str = str(self.status)
    query_str = str(self.query)
    if (len(status_str) &gt; max_len):
        status_str = &#34;%s...&#34; % (status_str[0:max_len])
    if (len(query_str) &gt; max_len):
        query_str = &#34;%s...&#34; % (query_str[0:max_len])

    # set results string
    if (self.executed is True):
        if (len(self.data) == 0):
            data_str = &#34;[0 ephemeris results]&#34;
        elif (len(self.data) == 1):
            data_str = &#34;[1 ephemeris result]&#34;
        else:
            data_str = &#34;[%d ephemeris results]&#34; % (len(self.data))
    else:
        data_str = &#34;&#34;

    # set logs string
    if (self.executed is True):
        if (len(self.logs) == 0):
            logs_str = &#34;[0 log messages]&#34;
        elif (len(self.logs) == 1):
            logs_str = &#34;[1 log message]&#34;
        else:
            logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
    else:
        logs_str = &#34;&#34;

    # print
    print(&#34;EphemerisSearch:&#34;)
    print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
    print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
    print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
    print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
    print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
    print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
    print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
    print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
    print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
    print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self, status: Optional[Dict] = None) -&gt; None:
    &#34;&#34;&#34;
    Update the status of this ephemeris search request

    Args:
        status (Dict): 
            The previously-retrieved status of this request (include to avoid requesting it 
            from the API again), defaults to None
    &#34;&#34;&#34;
    # get the status if it isn&#39;t passed in
    if (status is None):
        status = requests_get_status(self.__aurorax_obj, self.request_url)

    # check response
    if (status is None):
        raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

    # update request status by checking if data URI is set
    if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
        self.completed = True
        self.data_url = &#34;%s/data&#34; % (self.request_url)

    # set class variable &#34;status&#34; and &#34;logs&#34;
    self.status = status
    self.logs = status[&#34;logs&#34;]</code></pre>
</details>
<div class="desc"><p>Update the status of this ephemeris search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The previously-retrieved status of this request (include to avoid requesting it
from the API again), defaults to None</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: float = 1.0, verbose: bool = False) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Block and wait for the request to complete and data is available for retrieval

    Args:
        poll_interval (float): 
            Time in seconds to wait between polling attempts, defaults to 1 second

        verbose (bool): 
            Output poll times and other progress messages, defaults to False
    &#34;&#34;&#34;
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
    self.update_status(requests_wait_for_data(self.__aurorax_obj, url, poll_interval, verbose))</code></pre>
</details>
<div class="desc"><p>Block and wait for the request to complete and data is available for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Time in seconds to wait between polling attempts, defaults to 1 second</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.EventsCriteriaBlock"><code class="flex name class">
<span>class <span class="ident">EventsCriteriaBlock</span></span>
<span>(</span><span>platforms: List[str] = [],<br>instrument_types: List[str] = [],<br>metadata_filters: <a title="pyaurorax.search.metadata_filters.MetadataFilter" href="metadata_filters.html#pyaurorax.search.metadata_filters.MetadataFilter">MetadataFilter</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventsCriteriaBlock:
    &#34;&#34;&#34;
    Representation of a event criteria block used for conjunction searches. 

    Attributes:
        platforms (List[str]): 
            List of platform strings to use in this criteria block. Optional, default is `[]`.

        instrument_types (List[str]): 
            List of instrument type strings to use in this criteria block. Optional, default is `[]`.

        metadata_filters (MetadataFilter): 
            The metadata filters to use in this criteria block. Optional, default is None.
    &#34;&#34;&#34;

    def __init__(self, platforms: List[str] = [], instrument_types: List[str] = [], metadata_filters: Optional[MetadataFilter] = None):
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.metadata_filters = metadata_filters

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;EventsCriteriaBlock(platforms=%s, instrument_types=%s, metadata_filters=%s)&#34; % (
            self.platforms,
            self.instrument_types,
            self.metadata_filters,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        max_len = 80
        metadata_filters_str = str(self.metadata_filters)
        if (len(metadata_filters_str) &gt; max_len):
            metadata_filters_str = &#34;%s...)&#34; % (metadata_filters_str[0:max_len])

        # print
        print(&#34;EventsCriteriaBlock:&#34;)
        print(&#34;  %-18s: %s&#34; % (&#34;platforms&#34;, self.platforms))
        print(&#34;  %-18s: %s&#34; % (&#34;instrument_types&#34;, self.instrument_types))
        print(&#34;  %-18s: %s&#34; % (&#34;metadata_filters&#34;, metadata_filters_str))</code></pre>
</details>
<div class="desc"><p>Representation of a event criteria block used for conjunction searches. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>platforms</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of platform strings to use in this criteria block. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>instrument_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of instrument type strings to use in this criteria block. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>metadata_filters</code></strong> :&ensp;<code><a title="pyaurorax.search.MetadataFilter" href="#pyaurorax.search.MetadataFilter">MetadataFilter</a></code></dt>
<dd>The metadata filters to use in this criteria block. Optional, default is None.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.EventsCriteriaBlock.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    max_len = 80
    metadata_filters_str = str(self.metadata_filters)
    if (len(metadata_filters_str) &gt; max_len):
        metadata_filters_str = &#34;%s...)&#34; % (metadata_filters_str[0:max_len])

    # print
    print(&#34;EventsCriteriaBlock:&#34;)
    print(&#34;  %-18s: %s&#34; % (&#34;platforms&#34;, self.platforms))
    print(&#34;  %-18s: %s&#34; % (&#34;instrument_types&#34;, self.instrument_types))
    print(&#34;  %-18s: %s&#34; % (&#34;metadata_filters&#34;, metadata_filters_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.GroundCriteriaBlock"><code class="flex name class">
<span>class <span class="ident">GroundCriteriaBlock</span></span>
<span>(</span><span>programs: List[str] = [],<br>platforms: List[str] = [],<br>instrument_types: List[str] = [],<br>metadata_filters: <a title="pyaurorax.search.metadata_filters.MetadataFilter" href="metadata_filters.html#pyaurorax.search.metadata_filters.MetadataFilter">MetadataFilter</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GroundCriteriaBlock:
    &#34;&#34;&#34;
    Representation of a ground criteria block used for conjunction searches. 

    Attributes:
        programs (List[str]): 
            List of program strings to use in this criteria block. Optional, default is `[]`.
        
        platforms (List[str]): 
            List of platform strings to use in this criteria block. Optional, default is `[]`.

        instrument_types (List[str]): 
            List of instrument type strings to use in this criteria block. Optional, default is `[]`.

        metadata_filters (MetadataFilter): 
            The metadata filters to use in this criteria block. Optional, default is None.
    &#34;&#34;&#34;

    def __init__(self,
                 programs: List[str] = [],
                 platforms: List[str] = [],
                 instrument_types: List[str] = [],
                 metadata_filters: Optional[MetadataFilter] = None):
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.metadata_filters = metadata_filters

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;GroundCriteriaBlock(programs=%s, platforms=%s, instrument_types=%s, metadata_filters=%s)&#34; % (
            self.programs,
            self.platforms,
            self.instrument_types,
            self.metadata_filters,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        max_len = 80
        metadata_filters_str = str(self.metadata_filters)
        if (len(metadata_filters_str) &gt; max_len):
            metadata_filters_str = &#34;%s...)&#34; % (metadata_filters_str[0:max_len])

        # print
        print(&#34;GroundCriteriaBlock:&#34;)
        print(&#34;  %-18s: %s&#34; % (&#34;programs&#34;, self.programs))
        print(&#34;  %-18s: %s&#34; % (&#34;platforms&#34;, self.platforms))
        print(&#34;  %-18s: %s&#34; % (&#34;instrument_types&#34;, self.instrument_types))
        print(&#34;  %-18s: %s&#34; % (&#34;metadata_filters&#34;, metadata_filters_str))</code></pre>
</details>
<div class="desc"><p>Representation of a ground criteria block used for conjunction searches. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of program strings to use in this criteria block. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>platforms</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of platform strings to use in this criteria block. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>instrument_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of instrument type strings to use in this criteria block. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>metadata_filters</code></strong> :&ensp;<code><a title="pyaurorax.search.MetadataFilter" href="#pyaurorax.search.MetadataFilter">MetadataFilter</a></code></dt>
<dd>The metadata filters to use in this criteria block. Optional, default is None.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.GroundCriteriaBlock.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    max_len = 80
    metadata_filters_str = str(self.metadata_filters)
    if (len(metadata_filters_str) &gt; max_len):
        metadata_filters_str = &#34;%s...)&#34; % (metadata_filters_str[0:max_len])

    # print
    print(&#34;GroundCriteriaBlock:&#34;)
    print(&#34;  %-18s: %s&#34; % (&#34;programs&#34;, self.programs))
    print(&#34;  %-18s: %s&#34; % (&#34;platforms&#34;, self.platforms))
    print(&#34;  %-18s: %s&#34; % (&#34;instrument_types&#34;, self.instrument_types))
    print(&#34;  %-18s: %s&#34; % (&#34;metadata_filters&#34;, metadata_filters_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>lat: float | None = None, lon: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location:
    &#34;&#34;&#34;
    Representation for an AuroraX search engine location. This data can be in geodetic 
    coordinates, GSM coordinates, or geodetic northern/southern B-trace magnetic footprints.

    Latitude and longitude values are in decimal degrees format, ranging from -90 to 90
    for latitude and -180 to 180 for longitude.

    Note that latitude and longitude must both be numbers, or both be None.

    Attributes:
        lat (float): latitude value
        lon (float): longitude value
    
    Raises:
        ValueError: if both latitude and longitude are not real numbers, or not both None.
    &#34;&#34;&#34;

    def __init__(self, lat: Optional[float] = None, lon: Optional[float] = None):
        if (lat is None and lon is not None) or (lat is not None and lon is None):
            # one of them is None, not allowed
            raise ValueError(&#34;Latitude and longitude must both be numbers, or both be None&#34;)
        self.__lat = lat
        self.__lon = lon

    @property
    def lat(self):
        return self.__lat

    @lat.setter
    def lat(self, value: float):
        if (self.__lon is None and value is not None) or (self.__lon is not None and value is None):
            # one of them is None, not allowed
            raise ValueError(&#34;Latitude and longitude must both be numbers, or both be None&#34;)
        self.__lat = value

    @property
    def lon(self):
        return self.__lon

    @lon.setter
    def lon(self, value: float):
        if (self.__lat is None and value is not None) or (self.__lat is not None and value is None):
            # one of them is None, not allowed
            raise ValueError(&#34;Latitude and longitude must both be numbers, or both be None&#34;)
        self.__lon = value

    def to_json_serializable(self) -&gt; Dict:
        &#34;&#34;&#34;
        Convert object to a JSON-serializable object (ie. translate
        datetime objects to strings)

        Returns:
            a dictionary object that is JSON-serializable
        &#34;&#34;&#34;
        return {&#34;lat&#34;: self.lat, &#34;lon&#34;: self.lon}

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;%s(lat=%s, lon=%s)&#34; % (self.__class__.__name__, str(self.lat), str(self.lon))</code></pre>
</details>
<div class="desc"><p>Representation for an AuroraX search engine location. This data can be in geodetic
coordinates, GSM coordinates, or geodetic northern/southern B-trace magnetic footprints.</p>
<p>Latitude and longitude values are in decimal degrees format, ranging from -90 to 90
for latitude and -180 to 180 for longitude.</p>
<p>Note that latitude and longitude must both be numbers, or both be None.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude value</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude value</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if both latitude and longitude are not real numbers, or not both None.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.Location.lat"><code class="name">prop <span class="ident">lat</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lat(self):
    return self.__lat</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.search.Location.lon"><code class="name">prop <span class="ident">lon</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lon(self):
    return self.__lon</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.Location.to_json_serializable"><code class="name flex">
<span>def <span class="ident">to_json_serializable</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json_serializable(self) -&gt; Dict:
    &#34;&#34;&#34;
    Convert object to a JSON-serializable object (ie. translate
    datetime objects to strings)

    Returns:
        a dictionary object that is JSON-serializable
    &#34;&#34;&#34;
    return {&#34;lat&#34;: self.lat, &#34;lon&#34;: self.lon}</code></pre>
</details>
<div class="desc"><p>Convert object to a JSON-serializable object (ie. translate
datetime objects to strings)</p>
<h2 id="returns">Returns</h2>
<p>a dictionary object that is JSON-serializable</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.MetadataFilter"><code class="flex name class">
<span>class <span class="ident">MetadataFilter</span></span>
<span>(</span><span>expressions: List[<a title="pyaurorax.search.metadata_filters.MetadataFilterExpression" href="metadata_filters.html#pyaurorax.search.metadata_filters.MetadataFilterExpression">MetadataFilterExpression</a>],<br>operator: Literal['and', 'or', 'AND', 'OR'] = 'and')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetadataFilter:
    &#34;&#34;&#34;
    Representation for an AuroraX search engine metadata filter. These are used 
    as part of conjunction, ephemeris, and data product searching.

    Attributes:
        expressions (List[MetadataFilterExpression]): 
            The list of metadata filter expressions for use with conjunction, ephemeris, and 
            data product searches.
        
        operator (str): 
            The logical operator to use when the search engine will evaluate multiple expressions. If 
            not supplied, the search engine will perform a logical &#39;AND&#39; between each expression. Possible
            choices are &#39;and&#39; or &#39;or&#39;.

    Raises:
        pyaurorax.exceptions.AuroraXError: if invalid operator was specified.
    &#34;&#34;&#34;

    def __init__(
        self,
        expressions: List[MetadataFilterExpression],
        operator: Literal[&#34;and&#34;, &#34;or&#34;, &#34;AND&#34;, &#34;OR&#34;] = &#34;and&#34;,
    ):
        self.expressions = expressions
        self.__operator = operator

    @property
    def operator(self):
        return self.__operator

    @operator.setter
    def operator(self, val: Literal[&#34;and&#34;, &#34;or&#34;, &#34;AND&#34;, &#34;OR&#34;] = &#34;and&#34;):
        if (val.lower() not in [&#34;and&#34;, &#34;or&#34;]):
            AuroraXError(&#34;Operator &#39;%s&#39; not allowed. You must use one of the following: [&#39;and&#39;, &#39;or&#39;]&#34; % (val))
        self.__operator = val.lower()

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        # set special strings
        if (len(self.expressions) == 0):
            expressions_str = &#34;[0 expressions]&#34;
        elif (len(self.expressions) == 1):
            expressions_str = &#34;[1 expression]&#34;
        else:
            expressions_str = &#34;[%d expressions]&#34; % (len(self.expressions))

        # return
        return &#34;MetadataFilter(expressions=%s, operator=&#39;%s&#39;)&#34; % (expressions_str, self.operator)

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        if (len(self.expressions) == 0):
            expressions_str = &#34;[0 expressions]&#34;
        elif (len(self.expressions) == 1):
            expressions_str = &#34;[1 expression]&#34;
        else:
            expressions_str = &#34;[%d expressions]&#34; % (len(self.expressions))

        # print
        print(&#34;MetadataFilter:&#34;)
        print(&#34;  %-13s: %s&#34; % (&#34;expressions&#34;, expressions_str))
        print(&#34;  %-13s: %s&#34; % (&#34;operator&#34;, self.operator))

    def to_query_dict(self):
        &#34;&#34;&#34;
        Convert the expression object to a dictionary that will be used when executing a search.
        &#34;&#34;&#34;
        return {
            &#34;expressions&#34;: [x.to_query_dict() for x in self.expressions],
            &#34;logical_operator&#34;: self.operator.upper(),
        }</code></pre>
</details>
<div class="desc"><p>Representation for an AuroraX search engine metadata filter. These are used
as part of conjunction, ephemeris, and data product searching.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>expressions</code></strong> :&ensp;<code>List[<a title="pyaurorax.search.MetadataFilterExpression" href="#pyaurorax.search.MetadataFilterExpression">MetadataFilterExpression</a>]</code></dt>
<dd>The list of metadata filter expressions for use with conjunction, ephemeris, and
data product searches.</dd>
<dt><strong><code>operator</code></strong> :&ensp;<code>str</code></dt>
<dd>The logical operator to use when the search engine will evaluate multiple expressions. If
not supplied, the search engine will perform a logical 'AND' between each expression. Possible
choices are 'and' or 'or'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXError" href="../exceptions.html#pyaurorax.exceptions.AuroraXError">AuroraXError</a></code></dt>
<dd>if invalid operator was specified.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.MetadataFilter.operator"><code class="name">prop <span class="ident">operator</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def operator(self):
    return self.__operator</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.MetadataFilter.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    if (len(self.expressions) == 0):
        expressions_str = &#34;[0 expressions]&#34;
    elif (len(self.expressions) == 1):
        expressions_str = &#34;[1 expression]&#34;
    else:
        expressions_str = &#34;[%d expressions]&#34; % (len(self.expressions))

    # print
    print(&#34;MetadataFilter:&#34;)
    print(&#34;  %-13s: %s&#34; % (&#34;expressions&#34;, expressions_str))
    print(&#34;  %-13s: %s&#34; % (&#34;operator&#34;, self.operator))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.MetadataFilter.to_query_dict"><code class="name flex">
<span>def <span class="ident">to_query_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_query_dict(self):
    &#34;&#34;&#34;
    Convert the expression object to a dictionary that will be used when executing a search.
    &#34;&#34;&#34;
    return {
        &#34;expressions&#34;: [x.to_query_dict() for x in self.expressions],
        &#34;logical_operator&#34;: self.operator.upper(),
    }</code></pre>
</details>
<div class="desc"><p>Convert the expression object to a dictionary that will be used when executing a search.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.MetadataFilterExpression"><code class="flex name class">
<span>class <span class="ident">MetadataFilterExpression</span></span>
<span>(</span><span>key: str,<br>values: Any | List[Any],<br>operator: Literal['=', '!=', '>', '<', '>=', '<=', 'between', 'in', 'not in'] = 'in')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetadataFilterExpression:
    &#34;&#34;&#34;
    Representation for an AuroraX search engine metadata filter expression. These are used 
    as part of conjunction, ephemeris, and data product searching.

    Attributes:
        key (str): 
            The special key for the metadata filter. For example, &#39;nbtrace_region&#39;.
        
        values (Any or List[Any]): 
            The value(s) that the search will use when filtering. This can either be a single value, 
            or a list of values.

        operator (str): 
            The operator to use when the search engine evaluates the expression. Valid choices
            are: &#34;=&#34;, &#34;!=&#34;, &#34;&gt;&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&lt;=&#34;, &#34;between&#34;, &#34;in&#34;, &#34;not in&#34;.

            The &#34;in&#34; and &#34;not in&#34; operators are meant exclusively for expressions where there 
            are multiple values (ie. the values parameter is a list of strings).
        
    Raises:
        pyaurorax.exceptions.AuroraXError: if invalid operator was specified.
    &#34;&#34;&#34;

    def __init__(
        self,
        key: str,
        values: Union[Any, List[Any]],
        operator: Literal[&#34;=&#34;, &#34;!=&#34;, &#34;&gt;&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&lt;=&#34;, &#34;between&#34;, &#34;in&#34;, &#34;not in&#34;] = &#34;in&#34;,
    ):
        # set required parameters
        self.key = key
        self.values = values
        self.__operator = operator

    @property
    def operator(self) -&gt; str:
        return self.__operator

    @operator.setter
    def operator(self, val: Literal[&#34;=&#34;, &#34;!=&#34;, &#34;&gt;&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&lt;=&#34;, &#34;between&#34;, &#34;in&#34;, &#34;not in&#34;]):
        if (val not in [&#34;=&#34;, &#34;!=&#34;, &#34;&gt;&#34;, &#34;&lt;&#34;, &#34;&gt;=&#34;, &#34;&lt;=&#34;, &#34;between&#34;, &#34;in&#34;, &#34;not in&#34;]):
            AuroraXError(&#34;Operator &#39;%s&#39; not allowed. You must use one of the following: [&#39;=&#39;, &#39;!=&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#34; +
                         &#34;&#39;&gt;=&#39;, &#39;&lt;=&#39;, &#39;between&#39;, &#39;in&#39;, &#39;not in&#39;]&#34; % (val))
        self.__operator = val

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        # set special strings
        values_str = &#34;&#39;%s&#39;&#34; % (self.values)
        if (type(self.values) is list):
            values_str = str(self.values)

        # return
        return &#34;MetadataFilterExpression(key=&#39;%s&#39;, values=%s, operator=&#39;%s&#39;)&#34; % (self.key, values_str, self.operator)

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;

        # print
        print(&#34;MetadataFilterExpression:&#34;)
        print(&#34;  %-10s: %s&#34; % (&#34;key&#34;, self.key))
        print(&#34;  %-10s: %s&#34; % (&#34;values&#34;, self.values))
        print(&#34;  %-10s: %s&#34; % (&#34;operator&#34;, self.operator))

    def to_query_dict(self):
        &#34;&#34;&#34;
        Convert the expression object to a dictionary that will be used when executing a search.
        &#34;&#34;&#34;
        return {
            &#34;key&#34;: str(self.key),
            &#34;values&#34;: [str(self.values)] if type(self.values) is not list else self.values,
            &#34;operator&#34;: str(self.operator),
        }</code></pre>
</details>
<div class="desc"><p>Representation for an AuroraX search engine metadata filter expression. These are used
as part of conjunction, ephemeris, and data product searching.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The special key for the metadata filter. For example, 'nbtrace_region'.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>Any</code> or <code>List[Any]</code></dt>
<dd>The value(s) that the search will use when filtering. This can either be a single value,
or a list of values.</dd>
<dt><strong><code>operator</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The operator to use when the search engine evaluates the expression. Valid choices
are: "=", "!=", "&gt;", "&lt;", "&gt;=", "&lt;=", "between", "in", "not in".</p>
<p>The "in" and "not in" operators are meant exclusively for expressions where there
are multiple values (ie. the values parameter is a list of strings).</p>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXError" href="../exceptions.html#pyaurorax.exceptions.AuroraXError">AuroraXError</a></code></dt>
<dd>if invalid operator was specified.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.MetadataFilterExpression.operator"><code class="name">prop <span class="ident">operator</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def operator(self) -&gt; str:
    return self.__operator</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.MetadataFilterExpression.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;

    # print
    print(&#34;MetadataFilterExpression:&#34;)
    print(&#34;  %-10s: %s&#34; % (&#34;key&#34;, self.key))
    print(&#34;  %-10s: %s&#34; % (&#34;values&#34;, self.values))
    print(&#34;  %-10s: %s&#34; % (&#34;operator&#34;, self.operator))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.MetadataFilterExpression.to_query_dict"><code class="name flex">
<span>def <span class="ident">to_query_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_query_dict(self):
    &#34;&#34;&#34;
    Convert the expression object to a dictionary that will be used when executing a search.
    &#34;&#34;&#34;
    return {
        &#34;key&#34;: str(self.key),
        &#34;values&#34;: [str(self.values)] if type(self.values) is not list else self.values,
        &#34;operator&#34;: str(self.operator),
    }</code></pre>
</details>
<div class="desc"><p>Convert the expression object to a dictionary that will be used when executing a search.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.SearchManager"><code class="flex name class">
<span>class <span class="ident">SearchManager</span></span>
<span>(</span><span>aurorax_obj)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SearchManager:
    &#34;&#34;&#34;
    The SearchManager object is initialized within every PyAuroraX object. It acts as a way to access 
    the submodules and carry over configuration information in the super class.
    &#34;&#34;&#34;

    def __init__(self, aurorax_obj):
        self.__aurorax_obj = aurorax_obj

        # initialize sub-modules
        self.__util = UtilManager()
        self.__api = module_api
        self.__sources = SourcesManager(self.__aurorax_obj)
        self.__availability = AvailabilityManager(self.__aurorax_obj)
        self.__metadata = MetadataManager(self.__aurorax_obj)
        self.__requests = RequestsManager(self.__aurorax_obj)
        self.__ephemeris = EphemerisManager(self.__aurorax_obj)
        self.__data_products = DataProductsManager(self.__aurorax_obj)
        self.__conjunctions = ConjunctionsManager(self.__aurorax_obj)

        # initialize class vars
        self.DataSource = DataSource
        self.Location = Location
        self.MetadataFilter = MetadataFilter
        self.MetadataFilterExpression = MetadataFilterExpression
        self.GroundCriteriaBlock = GroundCriteriaBlock
        self.SpaceCriteriaBlock = SpaceCriteriaBlock
        self.EventsCriteriaBlock = EventsCriteriaBlock
        self.CustomLocationsCriteriaBlock = CustomLocationsCriteriaBlock
        self.ConjunctionSearch = ConjunctionSearch
        self.EphemerisSearch = EphemerisSearch
        self.DataProductSearch = DataProductSearch
        self.EphemerisData = EphemerisData
        self.DataProductData = DataProductData

        # initialize static vars
        self.FORMAT_BASIC_INFO = FORMAT_BASIC_INFO
        self.FORMAT_BASIC_INFO_WITH_METADATA = FORMAT_BASIC_INFO_WITH_METADATA
        self.FORMAT_FULL_RECORD = FORMAT_FULL_RECORD
        self.FORMAT_IDENTIFIER_ONLY = FORMAT_IDENTIFIER_ONLY
        self.FORMAT_DEFAULT = FORMAT_DEFAULT
        self.SOURCE_TYPE_EVENT_LIST = SOURCE_TYPE_EVENT_LIST
        self.SOURCE_TYPE_GROUND = SOURCE_TYPE_GROUND
        self.SOURCE_TYPE_HEO = SOURCE_TYPE_HEO
        self.SOURCE_TYPE_LEO = SOURCE_TYPE_LEO
        self.SOURCE_TYPE_LUNAR = SOURCE_TYPE_LUNAR
        self.DATA_PRODUCT_TYPE_KEOGRAM = DATA_PRODUCT_TYPE_KEOGRAM
        self.DATA_PRODUCT_TYPE_MONTAGE = DATA_PRODUCT_TYPE_MONTAGE
        self.DATA_PRODUCT_TYPE_MOVIE = DATA_PRODUCT_TYPE_MOVIE
        self.DATA_PRODUCT_TYPE_SUMMARY_PLOT = DATA_PRODUCT_TYPE_SUMMARY_PLOT
        self.DATA_PRODUCT_TYPE_DATA_AVAILABILITY = DATA_PRODUCT_TYPE_DATA_AVAILABILITY
        self.CONJUNCTION_TYPE_NBTRACE = CONJUNCTION_TYPE_NBTRACE
        self.CONJUNCTION_TYPE_SBTRACE = CONJUNCTION_TYPE_SBTRACE

    # ------------------------------------------
    # properties for submodule managers
    # ------------------------------------------
    @property
    def util(self):
        &#34;&#34;&#34;
        Access to the `util` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__util

    @property
    def api(self):
        &#34;&#34;&#34;
        Access to the `api` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__api

    @property
    def sources(self):
        &#34;&#34;&#34;
        Access to the `sources` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__sources

    @property
    def availability(self):
        &#34;&#34;&#34;
        Access to the `availability` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__availability

    @property
    def metadata(self):
        &#34;&#34;&#34;
        Access to the `metadata` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__metadata

    @property
    def requests(self):
        &#34;&#34;&#34;
        Access to the `requests` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__requests

    @property
    def ephemeris(self):
        &#34;&#34;&#34;
        Access to the `ephemeris` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__ephemeris

    @property
    def data_products(self):
        &#34;&#34;&#34;
        Access to the `data_products` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__data_products

    @property
    def conjunctions(self):
        &#34;&#34;&#34;
        Access to the `conjunctions` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__conjunctions</code></pre>
</details>
<div class="desc"><p>The SearchManager object is initialized within every PyAuroraX object. It acts as a way to access
the submodules and carry over configuration information in the super class.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.SearchManager.api"><code class="name">prop <span class="ident">api</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def api(self):
    &#34;&#34;&#34;
    Access to the `api` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__api</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.api" href="api/index.html">pyaurorax.search.api</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.search.SearchManager.availability"><code class="name">prop <span class="ident">availability</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def availability(self):
    &#34;&#34;&#34;
    Access to the `availability` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__availability</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.availability" href="availability/index.html">pyaurorax.search.availability</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.search.SearchManager.conjunctions"><code class="name">prop <span class="ident">conjunctions</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def conjunctions(self):
    &#34;&#34;&#34;
    Access to the `conjunctions` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__conjunctions</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.conjunctions" href="conjunctions/index.html">pyaurorax.search.conjunctions</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.search.SearchManager.data_products"><code class="name">prop <span class="ident">data_products</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_products(self):
    &#34;&#34;&#34;
    Access to the `data_products` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__data_products</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.data_products" href="data_products/index.html">pyaurorax.search.data_products</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.search.SearchManager.ephemeris"><code class="name">prop <span class="ident">ephemeris</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ephemeris(self):
    &#34;&#34;&#34;
    Access to the `ephemeris` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__ephemeris</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.ephemeris" href="ephemeris/index.html">pyaurorax.search.ephemeris</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.search.SearchManager.metadata"><code class="name">prop <span class="ident">metadata</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self):
    &#34;&#34;&#34;
    Access to the `metadata` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__metadata</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.metadata" href="metadata/index.html">pyaurorax.search.metadata</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.search.SearchManager.requests"><code class="name">prop <span class="ident">requests</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def requests(self):
    &#34;&#34;&#34;
    Access to the `requests` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__requests</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.requests" href="requests/index.html">pyaurorax.search.requests</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.search.SearchManager.sources"><code class="name">prop <span class="ident">sources</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sources(self):
    &#34;&#34;&#34;
    Access to the `sources` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__sources</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.sources" href="sources/index.html">pyaurorax.search.sources</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.search.SearchManager.util"><code class="name">prop <span class="ident">util</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def util(self):
    &#34;&#34;&#34;
    Access to the `util` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__util</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.util" href="util/index.html">pyaurorax.search.util</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.SpaceCriteriaBlock"><code class="flex name class">
<span>class <span class="ident">SpaceCriteriaBlock</span></span>
<span>(</span><span>programs: List[str] = [],<br>platforms: List[str] = [],<br>instrument_types: List[str] = [],<br>hemisphere: List[Literal['northern', 'southern']] = [],<br>metadata_filters: <a title="pyaurorax.search.metadata_filters.MetadataFilter" href="metadata_filters.html#pyaurorax.search.metadata_filters.MetadataFilter">MetadataFilter</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpaceCriteriaBlock:
    &#34;&#34;&#34;
    Representation of a space criteria block used for conjunction searches. 

    Attributes:
        programs (List[str]): 
            List of program strings to use in this criteria block. Optional, default is `[]`.
        
        platforms (List[str]): 
            List of platform strings to use in this criteria block. Optional, default is `[]`.

        instrument_types (List[str]): 
            List of instrument type strings to use in this criteria block. Optional, default is `[]`.

        hemisphere (List[str]): 
            List of hemisphere strings to use in this criteria block. Valid values are &#39;northern&#39; 
            or &#39;southern&#39;. Optional, default is `[]`.

        metadata_filters (MetadataFilter): 
            The metadata filters to use in this criteria block. Optional, default is None.
    &#34;&#34;&#34;

    def __init__(self,
                 programs: List[str] = [],
                 platforms: List[str] = [],
                 instrument_types: List[str] = [],
                 hemisphere: List[Literal[&#34;northern&#34;, &#34;southern&#34;]] = [],
                 metadata_filters: Optional[MetadataFilter] = None):
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.hemisphere = hemisphere
        self.metadata_filters = metadata_filters

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;SpaceCriteriaBlock(programs=%s, platforms=%s, instrument_types=%s, hemisphere=%s, metadata_filters=%s)&#34; % (
            self.programs,
            self.platforms,
            self.instrument_types,
            self.hemisphere,
            self.metadata_filters,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        max_len = 80
        metadata_filters_str = str(self.metadata_filters)
        if (len(metadata_filters_str) &gt; max_len):
            metadata_filters_str = &#34;%s...)&#34; % (metadata_filters_str[0:max_len])

        # print
        print(&#34;SpaceCriteriaBlock:&#34;)
        print(&#34;  %-18s: %s&#34; % (&#34;programs&#34;, self.programs))
        print(&#34;  %-18s: %s&#34; % (&#34;platforms&#34;, self.platforms))
        print(&#34;  %-18s: %s&#34; % (&#34;instrument_types&#34;, self.instrument_types))
        print(&#34;  %-18s: %s&#34; % (&#34;hemisphere&#34;, self.hemisphere))
        print(&#34;  %-18s: %s&#34; % (&#34;metadata_filters&#34;, metadata_filters_str))

    def to_search_query_dict(self):
        query_dict = self.__dict__
        query_dict[&#34;ephemeris_metadata_filters&#34;] = None if self.metadata_filters is None else self.metadata_filters.__dict__
        del query_dict[&#34;metadata_filters&#34;]
        return query_dict</code></pre>
</details>
<div class="desc"><p>Representation of a space criteria block used for conjunction searches. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of program strings to use in this criteria block. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>platforms</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of platform strings to use in this criteria block. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>instrument_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of instrument type strings to use in this criteria block. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>hemisphere</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of hemisphere strings to use in this criteria block. Valid values are 'northern'
or 'southern'. Optional, default is <code>[]</code>.</dd>
<dt><strong><code>metadata_filters</code></strong> :&ensp;<code><a title="pyaurorax.search.MetadataFilter" href="#pyaurorax.search.MetadataFilter">MetadataFilter</a></code></dt>
<dd>The metadata filters to use in this criteria block. Optional, default is None.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.SpaceCriteriaBlock.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    max_len = 80
    metadata_filters_str = str(self.metadata_filters)
    if (len(metadata_filters_str) &gt; max_len):
        metadata_filters_str = &#34;%s...)&#34; % (metadata_filters_str[0:max_len])

    # print
    print(&#34;SpaceCriteriaBlock:&#34;)
    print(&#34;  %-18s: %s&#34; % (&#34;programs&#34;, self.programs))
    print(&#34;  %-18s: %s&#34; % (&#34;platforms&#34;, self.platforms))
    print(&#34;  %-18s: %s&#34; % (&#34;instrument_types&#34;, self.instrument_types))
    print(&#34;  %-18s: %s&#34; % (&#34;hemisphere&#34;, self.hemisphere))
    print(&#34;  %-18s: %s&#34; % (&#34;metadata_filters&#34;, metadata_filters_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.SpaceCriteriaBlock.to_search_query_dict"><code class="name flex">
<span>def <span class="ident">to_search_query_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_search_query_dict(self):
    query_dict = self.__dict__
    query_dict[&#34;ephemeris_metadata_filters&#34;] = None if self.metadata_filters is None else self.metadata_filters.__dict__
    del query_dict[&#34;metadata_filters&#34;]
    return query_dict</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax" href="../index.html">pyaurorax</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyaurorax.search.api" href="api/index.html">pyaurorax.search.api</a></code></li>
<li><code><a title="pyaurorax.search.availability" href="availability/index.html">pyaurorax.search.availability</a></code></li>
<li><code><a title="pyaurorax.search.conjunctions" href="conjunctions/index.html">pyaurorax.search.conjunctions</a></code></li>
<li><code><a title="pyaurorax.search.data_products" href="data_products/index.html">pyaurorax.search.data_products</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris" href="ephemeris/index.html">pyaurorax.search.ephemeris</a></code></li>
<li><code><a title="pyaurorax.search.location" href="location.html">pyaurorax.search.location</a></code></li>
<li><code><a title="pyaurorax.search.metadata" href="metadata/index.html">pyaurorax.search.metadata</a></code></li>
<li><code><a title="pyaurorax.search.metadata_filters" href="metadata_filters.html">pyaurorax.search.metadata_filters</a></code></li>
<li><code><a title="pyaurorax.search.requests" href="requests/index.html">pyaurorax.search.requests</a></code></li>
<li><code><a title="pyaurorax.search.sources" href="sources/index.html">pyaurorax.search.sources</a></code></li>
<li><code><a title="pyaurorax.search.util" href="util/index.html">pyaurorax.search.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.search.AvailabilityResult" href="#pyaurorax.search.AvailabilityResult">AvailabilityResult</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.AvailabilityResult.available_data_products" href="#pyaurorax.search.AvailabilityResult.available_data_products">available_data_products</a></code></li>
<li><code><a title="pyaurorax.search.AvailabilityResult.available_ephemeris" href="#pyaurorax.search.AvailabilityResult.available_ephemeris">available_ephemeris</a></code></li>
<li><code><a title="pyaurorax.search.AvailabilityResult.data_source" href="#pyaurorax.search.AvailabilityResult.data_source">data_source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.Conjunction" href="#pyaurorax.search.Conjunction">Conjunction</a></code></h4>
</li>
<li>
<h4><code><a title="pyaurorax.search.ConjunctionSearch" href="#pyaurorax.search.ConjunctionSearch">ConjunctionSearch</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.ConjunctionSearch.cancel" href="#pyaurorax.search.ConjunctionSearch.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.check_criteria_block_count_validity" href="#pyaurorax.search.ConjunctionSearch.check_criteria_block_count_validity">check_criteria_block_count_validity</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.check_for_data" href="#pyaurorax.search.ConjunctionSearch.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.describe" href="#pyaurorax.search.ConjunctionSearch.describe">describe</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.distance" href="#pyaurorax.search.ConjunctionSearch.distance">distance</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.execute" href="#pyaurorax.search.ConjunctionSearch.execute">execute</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.get_advanced_distances_combos" href="#pyaurorax.search.ConjunctionSearch.get_advanced_distances_combos">get_advanced_distances_combos</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.get_data" href="#pyaurorax.search.ConjunctionSearch.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.pretty_print" href="#pyaurorax.search.ConjunctionSearch.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.query" href="#pyaurorax.search.ConjunctionSearch.query">query</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.update_status" href="#pyaurorax.search.ConjunctionSearch.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.wait" href="#pyaurorax.search.ConjunctionSearch.wait">wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.CustomLocationsCriteriaBlock" href="#pyaurorax.search.CustomLocationsCriteriaBlock">CustomLocationsCriteriaBlock</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.CustomLocationsCriteriaBlock.pretty_print" href="#pyaurorax.search.CustomLocationsCriteriaBlock.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.CustomLocationsCriteriaBlock.to_search_query_dict" href="#pyaurorax.search.CustomLocationsCriteriaBlock.to_search_query_dict">to_search_query_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.DataProductData" href="#pyaurorax.search.DataProductData">DataProductData</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.DataProductData.to_json_serializable" href="#pyaurorax.search.DataProductData.to_json_serializable">to_json_serializable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.DataProductSearch" href="#pyaurorax.search.DataProductSearch">DataProductSearch</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.search.DataProductSearch.cancel" href="#pyaurorax.search.DataProductSearch.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.check_for_data" href="#pyaurorax.search.DataProductSearch.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.describe" href="#pyaurorax.search.DataProductSearch.describe">describe</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.execute" href="#pyaurorax.search.DataProductSearch.execute">execute</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.get_data" href="#pyaurorax.search.DataProductSearch.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.pretty_print" href="#pyaurorax.search.DataProductSearch.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.query" href="#pyaurorax.search.DataProductSearch.query">query</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.update_status" href="#pyaurorax.search.DataProductSearch.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.wait" href="#pyaurorax.search.DataProductSearch.wait">wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.DataSource" href="#pyaurorax.search.DataSource">DataSource</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.DataSource.pretty_print" href="#pyaurorax.search.DataSource.pretty_print">pretty_print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.EphemerisData" href="#pyaurorax.search.EphemerisData">EphemerisData</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.EphemerisData.to_json_serializable" href="#pyaurorax.search.EphemerisData.to_json_serializable">to_json_serializable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.EphemerisSearch" href="#pyaurorax.search.EphemerisSearch">EphemerisSearch</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.search.EphemerisSearch.cancel" href="#pyaurorax.search.EphemerisSearch.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.check_for_data" href="#pyaurorax.search.EphemerisSearch.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.describe" href="#pyaurorax.search.EphemerisSearch.describe">describe</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.execute" href="#pyaurorax.search.EphemerisSearch.execute">execute</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.get_data" href="#pyaurorax.search.EphemerisSearch.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.pretty_print" href="#pyaurorax.search.EphemerisSearch.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.query" href="#pyaurorax.search.EphemerisSearch.query">query</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.update_status" href="#pyaurorax.search.EphemerisSearch.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.wait" href="#pyaurorax.search.EphemerisSearch.wait">wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.EventsCriteriaBlock" href="#pyaurorax.search.EventsCriteriaBlock">EventsCriteriaBlock</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.EventsCriteriaBlock.pretty_print" href="#pyaurorax.search.EventsCriteriaBlock.pretty_print">pretty_print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.GroundCriteriaBlock" href="#pyaurorax.search.GroundCriteriaBlock">GroundCriteriaBlock</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.GroundCriteriaBlock.pretty_print" href="#pyaurorax.search.GroundCriteriaBlock.pretty_print">pretty_print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.Location" href="#pyaurorax.search.Location">Location</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.Location.lat" href="#pyaurorax.search.Location.lat">lat</a></code></li>
<li><code><a title="pyaurorax.search.Location.lon" href="#pyaurorax.search.Location.lon">lon</a></code></li>
<li><code><a title="pyaurorax.search.Location.to_json_serializable" href="#pyaurorax.search.Location.to_json_serializable">to_json_serializable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.MetadataFilter" href="#pyaurorax.search.MetadataFilter">MetadataFilter</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.MetadataFilter.operator" href="#pyaurorax.search.MetadataFilter.operator">operator</a></code></li>
<li><code><a title="pyaurorax.search.MetadataFilter.pretty_print" href="#pyaurorax.search.MetadataFilter.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.MetadataFilter.to_query_dict" href="#pyaurorax.search.MetadataFilter.to_query_dict">to_query_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.MetadataFilterExpression" href="#pyaurorax.search.MetadataFilterExpression">MetadataFilterExpression</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.MetadataFilterExpression.operator" href="#pyaurorax.search.MetadataFilterExpression.operator">operator</a></code></li>
<li><code><a title="pyaurorax.search.MetadataFilterExpression.pretty_print" href="#pyaurorax.search.MetadataFilterExpression.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.MetadataFilterExpression.to_query_dict" href="#pyaurorax.search.MetadataFilterExpression.to_query_dict">to_query_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.SearchManager" href="#pyaurorax.search.SearchManager">SearchManager</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.search.SearchManager.api" href="#pyaurorax.search.SearchManager.api">api</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.availability" href="#pyaurorax.search.SearchManager.availability">availability</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.conjunctions" href="#pyaurorax.search.SearchManager.conjunctions">conjunctions</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.data_products" href="#pyaurorax.search.SearchManager.data_products">data_products</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.ephemeris" href="#pyaurorax.search.SearchManager.ephemeris">ephemeris</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.metadata" href="#pyaurorax.search.SearchManager.metadata">metadata</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.requests" href="#pyaurorax.search.SearchManager.requests">requests</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.sources" href="#pyaurorax.search.SearchManager.sources">sources</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.util" href="#pyaurorax.search.SearchManager.util">util</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.SpaceCriteriaBlock" href="#pyaurorax.search.SpaceCriteriaBlock">SpaceCriteriaBlock</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.SpaceCriteriaBlock.pretty_print" href="#pyaurorax.search.SpaceCriteriaBlock.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.SpaceCriteriaBlock.to_search_query_dict" href="#pyaurorax.search.SpaceCriteriaBlock.to_search_query_dict">to_search_query_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>

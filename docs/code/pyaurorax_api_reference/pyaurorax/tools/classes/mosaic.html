<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyaurorax.tools.classes.mosaic API documentation</title>
<meta name="description" content="Class representation for a mosaic." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.tools.classes.mosaic</code></h1>
</header>
<section id="section-intro">
<p>Class representation for a mosaic.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2024 University of Calgary
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34;
Class representation for a mosaic.
&#34;&#34;&#34;

import os
import datetime
import warnings
import pyproj
import aacgmv2
import matplotlib.colors
import numpy as np
import matplotlib.pyplot as plt
import cartopy.feature
import cartopy.crs
from copy import copy
from dataclasses import dataclass
from typing import List, Dict, Tuple, Sequence, Union, Optional, Any
from numpy import ndarray
from matplotlib.collections import PolyCollection
from cartopy.crs import Projection


@dataclass
class MosaicSkymap:
    &#34;&#34;&#34;
    Prepared skymap data for use by mosaic routines.

    Attributes:
        site_uid_list (List[str]): 
            List of site unique identifiers contained within this object.
        elevation (List[numpy.ndarray]): 
            List of elevation data, with each element corresponding to each site. Order 
            matches that of the `site_uid_list` attribute.
        polyfoll_lat (List[numpy.ndarray]): 
            List of latitude polygon data, with each element corresponding to each site. 
            Order matches that of the `site_uid_list` attribute. 
        polyfoll_lon (List[numpy.ndarray]): 
            List of longitude polygon data, with each element corresponding to each site. 
            Order matches that of the `site_uid_list` attribute. 
    &#34;&#34;&#34;

    site_uid_list: List[str]
    elevation: List[ndarray]
    polyfill_lat: List[ndarray]
    polyfill_lon: List[ndarray]

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        unique_polyfill_lat_dims = str(list(dict.fromkeys(fill_arr.shape
                                                          for fill_arr in self.polyfill_lat))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                        &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        unique_polyfill_lon_dims = str(list(dict.fromkeys(fill_arr.shape
                                                          for fill_arr in self.polyfill_lon))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                        &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        unique_elevation_dims = str(list(dict.fromkeys(el.shape for el in self.elevation))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)

        polyfill_lat_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lat_dims, self.polyfill_lat[0].dtype)
        polyfill_lon_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lon_dims, self.polyfill_lon[0].dtype)
        elevation_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_elevation_dims, self.elevation[0].dtype)

        return &#34;MosaicSkymap(polyfill_lat=%s, polyfill_lon=%s, elevation=%s, site_uid_list=%s)&#34; % (
            polyfill_lat_str,
            polyfill_lon_str,
            elevation_str,
            self.site_uid_list.__repr__(),
        )


@dataclass
class MosaicData:
    &#34;&#34;&#34;
    Prepared image data for use by mosaic routines.

    Attributes:
        site_uid_list (List[str]): 
            List of site unique identifiers contained within this object.
        timestamps (List[datetime.datetime]): 
            Timestamps of corresponding images.
        images (Dict[str, numpy.ndarray]): 
            Image data prepared into the necessary format; a dictionary. Keys are the site UID, 
            ndarray is the prepared data.
        images_dimensions (Dict[str, Tuple]): 
            The image dimensions.    
    &#34;&#34;&#34;

    site_uid_list: List[str]
    timestamps: List[datetime.datetime]
    images: Dict[str, ndarray]
    images_dimensions: Dict[str, Tuple]

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        unique_dimensions = str(list(dict.fromkeys(self.images_dimensions.values()))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        images_str = &#34;Dict[%d sites of array(dims=%s)]&#34; % (len(self.images.keys()), unique_dimensions)
        timestamps_str = &#34;[%d timestamps]&#34; % (len(self.timestamps))

        return &#34;MosaicData(images=%s, timestamps=%s, site_uid_list=%s)&#34; % (images_str, timestamps_str, self.site_uid_list.__repr__())


@dataclass
class Mosaic:
    &#34;&#34;&#34;
    Class representation for a generated mosaic.

    Attributes:
        polygon_data (matplotlib.collections.PolyCollection): 
            Generated polygons containing rendered data.
        cartopy_projection (cartopy.crs.Projection): 
            Cartopy projection to utilize.
        contour_data (Dict[str, List[Any]]): 
            Generated contour data.
    &#34;&#34;&#34;
    polygon_data: Union[PolyCollection, List[PolyCollection]]
    cartopy_projection: Projection
    contour_data: Optional[Dict[str, List[Any]]] = None

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        if isinstance(self.polygon_data, list):
            polycollection_str = &#34;[PolyCollection(...), ...]&#34;
        else:
            polycollection_str = &#34;PolyCollection(...)&#34;

        if self.contour_data is not None:
            return &#34;Mosaic(polygon_data=PolyCollection(...), cartopy_projection=Projection(%s), %s Contours)&#34; % (
                self.cartopy_projection.to_string(),
                len(self.contour_data.get(&#34;x&#34;, [])),
            )
        else:
            return &#34;Mosaic(polygon_data=&#34;+polycollection_str+&#34;, cartopy_projection=Projection(%s))&#34; % (self.cartopy_projection.to_string())

    def plot(self,
             map_extent: Sequence[Union[float, int]],
             figsize: Optional[Tuple[int, int]] = None,
             rayleighs: bool = False,
             max_rayleighs: int = 20000,
             title: Optional[str] = None,
             ocean_color: Optional[str] = None,
             land_color: str = &#34;gray&#34;,
             land_edgecolor: str = &#34;#8A8A8A&#34;,
             borders_color: str = &#34;#AEAEAE&#34;,
             borders_disable: bool = False,
             cbar_colormap: str = &#34;gray&#34;,
             returnfig: bool = False,
             savefig: bool = False,
             savefig_filename: Optional[str] = None,
             savefig_quality: Optional[int] = None) -&gt; Any:
        &#34;&#34;&#34;
        Generate a plot of the mosaic data. 
        
        Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
        return the matplotlib plot object for further usage (using the `returnfig` parameter).

        Args:
            map_extent (List[int]): 
                Latitude/longitude range to be visible on the rendered map. This is a list of 4 integers 
                and/or floats, in the order of [min_lon, max_lon, min_lat, max_lat].

            figsize (tuple): 
                The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

            rayleighs (bool): 
                Set to `True` if the data being plotted is in Rayleighs. Defaults to `False`.

            max_rayleighs (int): 
                Max intensity scale for Rayleighs. Defaults to `20000`.

            ocean_color (str): 
                Colour of the ocean. Default is cartopy&#39;s default shade of blue. Colours can be supplied
                as a word, or hexcode prefixed with a &#39;#&#39; character (ie. `#55AADD`).
            
            land_color (str): 
                Colour of the land. Default is `gray`. Colours can be supplied as a word, or hexcode 
                prefixed with a &#39;#&#39; character (ie. `#41BB87`).

            land_edgecolor (str): 
                Color of the land edges. Default is `#8A8A8A`. Colours can be supplied as a word, or
                hexcode prefixed with a &#39;#&#39; character.

            borders_color (str): 
                Color of the country borders. Default is `AEAEAE`. Colours can be supplied as a word, or
                hexcode prefixed with a &#39;#&#39; character.
            
            borders_disable (bool): 
                Disbale rendering of the borders. Default is `False`.

            cbar_colorcmap (str): 
                The matplotlib colormap to use for the plotted color bar. Default is `gray`.

                Commonly used colormaps are:

                - REGO: `gist_heat`
                - THEMIS ASI: `gray`
                - TREx Blue: `Blues_r`
                - TREx NIR: `gray`
                - TREx RGB: `None`

                A list of all available colormaps can be found on the 
                [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).

            returnfig (bool): 
                Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
                manipulation, for example, adding labels or a title in a different location than the default. 
                
                Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
                with it. This can be achieved by doing `plt.close(fig)`. 
                
                Note that this method cannot be used in combination with `savefig`.

            savefig (bool): 
                Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
                this parameter is set to True. Defaults to `False`.

            savefig_filename (str): 
                Filename to save the image to. Must be specified if the savefig parameter is set to True.

            savefig_quality (int): 
                Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
                is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

        Returns:
            The displayed montage, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
            set to True, the plotting variables `(fig, ax)` will be returned.

        Raises:
        &#34;&#34;&#34;
        # check return mode
        if (returnfig is True and savefig is True):
            raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
        if (returnfig is True and (savefig_filename is not None or savefig_quality is not None)):
            warnings.warn(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                          &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                          stacklevel=1)
        elif (savefig is False and (savefig_filename is not None or savefig_quality is not None)):
            warnings.warn(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                          &#34;savefig option parameters will be ignored.&#34;,
                          stacklevel=1)

        # initialize figure
        fig = plt.figure(figsize=figsize)
        ax = fig.add_axes((0, 0, 1, 1), projection=self.cartopy_projection)
        ax.set_extent(map_extent, crs=cartopy.crs.Geodetic())  # type: ignore

        # add ocean
        #
        # NOTE: we use the default ocean color
        if (ocean_color is not None):
            ax.add_feature(cartopy.feature.OCEAN, facecolor=ocean_color, zorder=0)  # type: ignore
        else:
            ax.add_feature(cartopy.feature.OCEAN, zorder=0)  # type: ignore

        # add land
        ax.add_feature(cartopy.feature.LAND, facecolor=land_color, edgecolor=land_edgecolor, zorder=0)  # type: ignore

        # add borders
        if (borders_disable is False):
            ax.add_feature(cartopy.feature.BORDERS, edgecolor=borders_color, zorder=0)  # type: ignore

        # add polygon data
        #
        # NOTE: it seems that when running this function a second time, the polygon
        # data is not too happy. So to handle this, we plot a copy of the polygon data
        if isinstance(self.polygon_data, list):
            for polygon_data in self.polygon_data:
                ax.add_collection(copy(polygon_data))
        else:
            ax.add_collection(copy(self.polygon_data))

        if self.contour_data is not None:
            for i in range(len(self.contour_data[&#34;x&#34;])):
                ax.plot(self.contour_data[&#34;x&#34;][i],
                        self.contour_data[&#34;y&#34;][i],
                        color=self.contour_data[&#34;color&#34;][i],
                        linewidth=self.contour_data[&#34;linewidth&#34;][i],
                        linestyle=self.contour_data[&#34;linestyle&#34;][i],
                        marker=self.contour_data[&#34;marker&#34;][i],
                        zorder=self.contour_data[&#34;zorder&#34;][i])

        # set title
        if (title is not None):
            ax.set_title(title)

        # add text
        if (rayleighs is True):
            if isinstance(self.polygon_data, list):
                raise ValueError(&#34;Rayleighs Keyword is currently not available for mosaics with multiple sets of data.&#34;)
            
            # Create a colorbar, in Rayleighs, that accounts for the scaling limit we applied
            cbar_ticks = [float(j) / 5. for j in range(0, 6)]
            cbar_ticknames = [str(int(max_rayleighs / 5) * j) for j in range(0, 6)]

            # Any pixels with the max Rayleigh value could be greater than it, so we include the plus sign
            cbar_ticknames[-1] += &#34;+&#34;
            self.polygon_data.set_cmap(cbar_colormap)
            cbar = plt.colorbar(self.polygon_data, shrink=0.5, ticks=cbar_ticks, ax=ax)
            cbar.ax.set_yticklabels(cbar_ticknames)
            plt.text(1.025,
                     0.5,
                     &#34;Intensity (Rayleighs)&#34;,
                     fontsize=14,
                     transform=ax.transAxes,
                     va=&#34;center&#34;,
                     rotation=&#34;vertical&#34;,
                     weight=&#34;bold&#34;,
                     style=&#34;oblique&#34;)

        # save figure or show it
        if (savefig is True):
            # check that filename has been set
            if (savefig_filename is None):
                raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

            # save the figure
            f_extension = os.path.splitext(savefig_filename)[-1].lower()
            if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
                # check quality setting
                if (savefig_quality is not None):
                    plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
                else:
                    plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
            else:
                if (savefig_quality is not None):
                    # quality specified, but output filename is not a JPG, so show a warning
                    warnings.warn(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                                  &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                                  stacklevel=1)
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

            # clean up by closing the figure
            plt.close(fig)
        elif (returnfig is True):
            # return the figure and axis objects
            return (fig, ax)
        else:
            # show the figure
            plt.show(fig)

            # cleanup by closing the figure
            plt.close(fig)

        # return
        return None

    def add_geo_contours(self,
                         lats: Optional[Union[ndarray, list]] = None,
                         lons: Optional[Union[ndarray, list]] = None,
                         constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         color: str = &#34;black&#34;,
                         linewidth: Union[float, int] = 1,
                         linestyle: str = &#34;solid&#34;,
                         marker: str = &#34;&#34;,
                         bring_to_front: bool = False):
        &#34;&#34;&#34;
        Add geographic contours to a mosaic.

        Args:
            lats (ndarray or list):
                Sequence of geographic latitudes defining a contour.
            
            lons (ndarray or list):
                Sequence of geographic longitudes defining a contour.

            constant_lats (float, int, or Sequence):
                Geographic Latitude(s) at which to add line(s) of constant latitude.
            
            constant_lons (float, int, or Sequence):
                Geographic Longitude(s) at which to add line(s) of constant longitude.

            color (str):
                The matplotlib color used for the contour(s).

            linewidth (float or int):
                The contour thickness.
            
            linestyle (str):
                The matplotlib linestyle used for the contour(s).

            marker (str):
                The matplotlib marker used for the contour(s).

        Returns:
            The object&#39;s contour_data parameter is populated appropriately.

        Raises:
            ValueError: issues encountered with supplied parameters.
        &#34;&#34;&#34;
        # Make sure some form of lat/lon is provided
        if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
            raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

        # If manually passing in lats &amp; lons, make sure both are provided
        if (lats is not None or lons is not None) and (lats is None or lons is None):
            raise (ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;))

        # Check that color exists in matplotlib
        if color not in matplotlib.colors.CSS4_COLORS:
            raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

        # Check that linestyle is valid
        if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
            raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

        # Check that linewidth is valid
        if linewidth &lt;= 0:
            raise ValueError(&#34;Linewidth must be greater than zero.&#34;)

        # Check that marker is valid
        if marker not in [&#34;&#34;, &#34;o&#34;, &#34;.&#34;, &#34;p&#34;, &#34;*&#34;, &#34;x&#34;, &#34;+&#34;, &#34;X&#34;]:
            raise ValueError(f&#34;Marker &#39;{marker}&#39; is not currently supported.&#34;)
        
        # Convert numerics to lists if necessary
        if constant_lats is not None:
            if isinstance(constant_lats, (float, int)):
                constant_lats = [constant_lats]
        if constant_lons is not None:
            if isinstance(constant_lons, (float, int)):
                constant_lons = [constant_lons]

        # Initialize contour data dict if it doesn&#39;t exist yet
        if self.contour_data is None:
            self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

        # Obtain the mosaic&#39;s projection
        source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
        mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
        transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

        # First handling manually supplied lat/lon arrays
        if (lats is not None) and (lons is not None):
            # Convert lists to ndarrays if necessary
            if isinstance(lats, list):
                lats = np.array(lats)
            if isinstance(lons, list):
                lons = np.array(lons)

            if len(lats) != len(lons):
                raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

            # Create specified contour from geographic coords
            x, y = transformer.transform(lons, lats)
            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(x)
            self.contour_data[&#34;y&#34;].append(y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Next handling lines of constant latitude
        if constant_lats is not None:
            # Generate longitudinal domain of the lat line (full globe)
            lon_domain = np.arange(-180, 180 + 0.2, 0.2)

            # Iterate through all lines of constant lat requested
            for lat in constant_lats:
                # Create line of constant lat
                const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
                sort_idx = np.argsort(const_lat_x)
                const_lat_y = const_lat_y[sort_idx]
                const_lat_x = const_lat_x[sort_idx]
                const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)
                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lat_x)
                self.contour_data[&#34;y&#34;].append(const_lat_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Now handling lines of constant longitude
        if constant_lons is not None:
            # Generate latitudinal domain of the lon line (full globe)
            lat_domain = np.arange(-90, 90 + 0.1, 0.1)

            # Iterate through all lines of constant lon requested
            for lon in constant_lons:
                # Create line of constant lon and add to dict
                const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
                sort_idx = np.argsort(const_lon_y)
                const_lon_x = const_lon_x[sort_idx]
                const_lon_y = const_lon_y[sort_idx]
                const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lon_x)
                self.contour_data[&#34;y&#34;].append(const_lon_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    def add_mag_contours(self,
                         timestamp: datetime.datetime,
                         constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         lats: Optional[Union[ndarray, list]] = None,
                         lons: Optional[Union[ndarray, list]] = None,
                         color: str = &#34;black&#34;,
                         linewidth: Union[float, int] = 1,
                         linestyle: str = &#34;solid&#34;,
                         marker: str = &#34;&#34;,
                         bring_to_front: bool = False):
        &#34;&#34;&#34;
        Add geomagnetic contours to a mosaic.

        Args:
            timestamp (datetime.datetime):
                The timestamp used in computing AACGM coordinates.

            lats (ndarray or list):
                Sequence of geomagnetic latitudes defining a contour.
            
            lons (ndarray or list):
                Sequence of geomagnetic longitudes defining a contour.

            constant_lats (float, int, Sequence):
                Geomagnetic latitude(s) at which to add contour(s) of constant latitude.
            
            constant_lons (float, int, Sequence):
                Geomagnetic longitude(s) at which to add contours(s) of constant longitude.

            color (str):
                The matplotlib color used for the contour(s).

            linewidth (float or int):
                The contour thickness.

            linestyle (str):
                The matplotlib linestyle used for the contour(s).

            marker (str):
                The matplotlib marker used for the contour(s).

        Returns:
            The object&#39;s contour_data parameter is populated appropriately.

        Raises:
            ValueError: issues encountered with supplied parameters.
        &#34;&#34;&#34;
        # Make sure some form of lat/lon is provided
        if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
            raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

        # If manually passing in lats &amp; lons, make sure both are provided
        if (lats is not None or lons is not None) and (lats is None or lons is None):
            raise (ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;))

        # Check that color exists in matplotlib
        if color not in matplotlib.colors.CSS4_COLORS:
            raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

        # Check that linestyle is valid
        if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
            raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

        # Check that linewidth is valid
        if linewidth &lt;= 0:
            raise ValueError(&#34;linewidth must be greater than zero.&#34;)

        # Convert numerics to lists if necessary
        if constant_lats is not None:
            if isinstance(constant_lats, (float, int)):
                constant_lats = [constant_lats]
        if constant_lons is not None:
            if isinstance(constant_lons, (float, int)):
                constant_lons = [constant_lons]

        # Initialize contour data dict if it doesn&#39;t exist yet
        if self.contour_data is None:
            self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

        # Obtain the mosaic&#39;s projection
        source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
        mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
        transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

        # First handling manually supplied lat/lon arrays
        if (lats is not None) and (lons is not None):
            # Convert lists to ndarrays if necessary
            if isinstance(lats, list):
                lats = np.array(lats)
            if isinstance(lons, list):
                lons = np.array(lons)

            if len(lats) != len(lons):
                raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

            # Create specified contour from magnetic coords
            y, x, alt = aacgmv2.convert_latlon_arr(lats, lons, lats * 0.0, timestamp, method_code=&#34;A2G&#34;)
            x, y = transformer.transform(x, y)
            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(x)
            self.contour_data[&#34;y&#34;].append(y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Next handling lines of constant latitude
        if constant_lats is not None:
            # Generate longitudinal domain of the lat line (full globe)
            lon_domain = np.arange(-180, 180 + 0.2, 0.2)

            # iterate through all lines of constant lat requested
            for lat in constant_lats:
                # Create line of constant lat from magnetic coords
                const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
                const_lat_y, const_lat_x, alt = aacgmv2.convert_latlon_arr(const_lat_y, const_lat_x, const_lat_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
                sort_idx = np.argsort(const_lat_x)
                const_lat_y = const_lat_y[sort_idx]
                const_lat_x = const_lat_x[sort_idx]
                const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lat_x)
                self.contour_data[&#34;y&#34;].append(const_lat_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Now handling lines of constant longitude
        if constant_lons is not None:
            # Generate latitudinal domain of the lon line (full globe)
            lat_domain = np.arange(-90, 90 + 0.1, 0.1)

            # iterate through all lines of constant lon requested
            for lon in constant_lons:
                # Create line of constant lon from magnetic coords
                const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
                const_lon_y, const_lon_x, alt = aacgmv2.convert_latlon_arr(const_lon_y, const_lon_x, const_lon_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
                sort_idx = np.argsort(const_lon_y)
                const_lon_x = const_lon_x[sort_idx]
                const_lon_y = const_lon_y[sort_idx]
                const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lon_x)
                self.contour_data[&#34;y&#34;].append(const_lon_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.tools.classes.mosaic.Mosaic"><code class="flex name class">
<span>class <span class="ident">Mosaic</span></span>
<span>(</span><span>polygon_data: Union[matplotlib.collections.PolyCollection, List[matplotlib.collections.PolyCollection]], cartopy_projection: cartopy.crs.Projection, contour_data: Optional[Dict[str, List[Any]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representation for a generated mosaic.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>polygon_data</code></strong> :&ensp;<code>matplotlib.collections.PolyCollection</code></dt>
<dd>Generated polygons containing rendered data.</dd>
<dt><strong><code>cartopy_projection</code></strong> :&ensp;<code>cartopy.crs.Projection</code></dt>
<dd>Cartopy projection to utilize.</dd>
<dt><strong><code>contour_data</code></strong> :&ensp;<code>Dict[str, List[Any]]</code></dt>
<dd>Generated contour data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Mosaic:
    &#34;&#34;&#34;
    Class representation for a generated mosaic.

    Attributes:
        polygon_data (matplotlib.collections.PolyCollection): 
            Generated polygons containing rendered data.
        cartopy_projection (cartopy.crs.Projection): 
            Cartopy projection to utilize.
        contour_data (Dict[str, List[Any]]): 
            Generated contour data.
    &#34;&#34;&#34;
    polygon_data: Union[PolyCollection, List[PolyCollection]]
    cartopy_projection: Projection
    contour_data: Optional[Dict[str, List[Any]]] = None

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        if isinstance(self.polygon_data, list):
            polycollection_str = &#34;[PolyCollection(...), ...]&#34;
        else:
            polycollection_str = &#34;PolyCollection(...)&#34;

        if self.contour_data is not None:
            return &#34;Mosaic(polygon_data=PolyCollection(...), cartopy_projection=Projection(%s), %s Contours)&#34; % (
                self.cartopy_projection.to_string(),
                len(self.contour_data.get(&#34;x&#34;, [])),
            )
        else:
            return &#34;Mosaic(polygon_data=&#34;+polycollection_str+&#34;, cartopy_projection=Projection(%s))&#34; % (self.cartopy_projection.to_string())

    def plot(self,
             map_extent: Sequence[Union[float, int]],
             figsize: Optional[Tuple[int, int]] = None,
             rayleighs: bool = False,
             max_rayleighs: int = 20000,
             title: Optional[str] = None,
             ocean_color: Optional[str] = None,
             land_color: str = &#34;gray&#34;,
             land_edgecolor: str = &#34;#8A8A8A&#34;,
             borders_color: str = &#34;#AEAEAE&#34;,
             borders_disable: bool = False,
             cbar_colormap: str = &#34;gray&#34;,
             returnfig: bool = False,
             savefig: bool = False,
             savefig_filename: Optional[str] = None,
             savefig_quality: Optional[int] = None) -&gt; Any:
        &#34;&#34;&#34;
        Generate a plot of the mosaic data. 
        
        Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
        return the matplotlib plot object for further usage (using the `returnfig` parameter).

        Args:
            map_extent (List[int]): 
                Latitude/longitude range to be visible on the rendered map. This is a list of 4 integers 
                and/or floats, in the order of [min_lon, max_lon, min_lat, max_lat].

            figsize (tuple): 
                The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

            rayleighs (bool): 
                Set to `True` if the data being plotted is in Rayleighs. Defaults to `False`.

            max_rayleighs (int): 
                Max intensity scale for Rayleighs. Defaults to `20000`.

            ocean_color (str): 
                Colour of the ocean. Default is cartopy&#39;s default shade of blue. Colours can be supplied
                as a word, or hexcode prefixed with a &#39;#&#39; character (ie. `#55AADD`).
            
            land_color (str): 
                Colour of the land. Default is `gray`. Colours can be supplied as a word, or hexcode 
                prefixed with a &#39;#&#39; character (ie. `#41BB87`).

            land_edgecolor (str): 
                Color of the land edges. Default is `#8A8A8A`. Colours can be supplied as a word, or
                hexcode prefixed with a &#39;#&#39; character.

            borders_color (str): 
                Color of the country borders. Default is `AEAEAE`. Colours can be supplied as a word, or
                hexcode prefixed with a &#39;#&#39; character.
            
            borders_disable (bool): 
                Disbale rendering of the borders. Default is `False`.

            cbar_colorcmap (str): 
                The matplotlib colormap to use for the plotted color bar. Default is `gray`.

                Commonly used colormaps are:

                - REGO: `gist_heat`
                - THEMIS ASI: `gray`
                - TREx Blue: `Blues_r`
                - TREx NIR: `gray`
                - TREx RGB: `None`

                A list of all available colormaps can be found on the 
                [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).

            returnfig (bool): 
                Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
                manipulation, for example, adding labels or a title in a different location than the default. 
                
                Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
                with it. This can be achieved by doing `plt.close(fig)`. 
                
                Note that this method cannot be used in combination with `savefig`.

            savefig (bool): 
                Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
                this parameter is set to True. Defaults to `False`.

            savefig_filename (str): 
                Filename to save the image to. Must be specified if the savefig parameter is set to True.

            savefig_quality (int): 
                Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
                is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

        Returns:
            The displayed montage, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
            set to True, the plotting variables `(fig, ax)` will be returned.

        Raises:
        &#34;&#34;&#34;
        # check return mode
        if (returnfig is True and savefig is True):
            raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
        if (returnfig is True and (savefig_filename is not None or savefig_quality is not None)):
            warnings.warn(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                          &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                          stacklevel=1)
        elif (savefig is False and (savefig_filename is not None or savefig_quality is not None)):
            warnings.warn(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                          &#34;savefig option parameters will be ignored.&#34;,
                          stacklevel=1)

        # initialize figure
        fig = plt.figure(figsize=figsize)
        ax = fig.add_axes((0, 0, 1, 1), projection=self.cartopy_projection)
        ax.set_extent(map_extent, crs=cartopy.crs.Geodetic())  # type: ignore

        # add ocean
        #
        # NOTE: we use the default ocean color
        if (ocean_color is not None):
            ax.add_feature(cartopy.feature.OCEAN, facecolor=ocean_color, zorder=0)  # type: ignore
        else:
            ax.add_feature(cartopy.feature.OCEAN, zorder=0)  # type: ignore

        # add land
        ax.add_feature(cartopy.feature.LAND, facecolor=land_color, edgecolor=land_edgecolor, zorder=0)  # type: ignore

        # add borders
        if (borders_disable is False):
            ax.add_feature(cartopy.feature.BORDERS, edgecolor=borders_color, zorder=0)  # type: ignore

        # add polygon data
        #
        # NOTE: it seems that when running this function a second time, the polygon
        # data is not too happy. So to handle this, we plot a copy of the polygon data
        if isinstance(self.polygon_data, list):
            for polygon_data in self.polygon_data:
                ax.add_collection(copy(polygon_data))
        else:
            ax.add_collection(copy(self.polygon_data))

        if self.contour_data is not None:
            for i in range(len(self.contour_data[&#34;x&#34;])):
                ax.plot(self.contour_data[&#34;x&#34;][i],
                        self.contour_data[&#34;y&#34;][i],
                        color=self.contour_data[&#34;color&#34;][i],
                        linewidth=self.contour_data[&#34;linewidth&#34;][i],
                        linestyle=self.contour_data[&#34;linestyle&#34;][i],
                        marker=self.contour_data[&#34;marker&#34;][i],
                        zorder=self.contour_data[&#34;zorder&#34;][i])

        # set title
        if (title is not None):
            ax.set_title(title)

        # add text
        if (rayleighs is True):
            if isinstance(self.polygon_data, list):
                raise ValueError(&#34;Rayleighs Keyword is currently not available for mosaics with multiple sets of data.&#34;)
            
            # Create a colorbar, in Rayleighs, that accounts for the scaling limit we applied
            cbar_ticks = [float(j) / 5. for j in range(0, 6)]
            cbar_ticknames = [str(int(max_rayleighs / 5) * j) for j in range(0, 6)]

            # Any pixels with the max Rayleigh value could be greater than it, so we include the plus sign
            cbar_ticknames[-1] += &#34;+&#34;
            self.polygon_data.set_cmap(cbar_colormap)
            cbar = plt.colorbar(self.polygon_data, shrink=0.5, ticks=cbar_ticks, ax=ax)
            cbar.ax.set_yticklabels(cbar_ticknames)
            plt.text(1.025,
                     0.5,
                     &#34;Intensity (Rayleighs)&#34;,
                     fontsize=14,
                     transform=ax.transAxes,
                     va=&#34;center&#34;,
                     rotation=&#34;vertical&#34;,
                     weight=&#34;bold&#34;,
                     style=&#34;oblique&#34;)

        # save figure or show it
        if (savefig is True):
            # check that filename has been set
            if (savefig_filename is None):
                raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

            # save the figure
            f_extension = os.path.splitext(savefig_filename)[-1].lower()
            if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
                # check quality setting
                if (savefig_quality is not None):
                    plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
                else:
                    plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
            else:
                if (savefig_quality is not None):
                    # quality specified, but output filename is not a JPG, so show a warning
                    warnings.warn(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                                  &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                                  stacklevel=1)
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

            # clean up by closing the figure
            plt.close(fig)
        elif (returnfig is True):
            # return the figure and axis objects
            return (fig, ax)
        else:
            # show the figure
            plt.show(fig)

            # cleanup by closing the figure
            plt.close(fig)

        # return
        return None

    def add_geo_contours(self,
                         lats: Optional[Union[ndarray, list]] = None,
                         lons: Optional[Union[ndarray, list]] = None,
                         constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         color: str = &#34;black&#34;,
                         linewidth: Union[float, int] = 1,
                         linestyle: str = &#34;solid&#34;,
                         marker: str = &#34;&#34;,
                         bring_to_front: bool = False):
        &#34;&#34;&#34;
        Add geographic contours to a mosaic.

        Args:
            lats (ndarray or list):
                Sequence of geographic latitudes defining a contour.
            
            lons (ndarray or list):
                Sequence of geographic longitudes defining a contour.

            constant_lats (float, int, or Sequence):
                Geographic Latitude(s) at which to add line(s) of constant latitude.
            
            constant_lons (float, int, or Sequence):
                Geographic Longitude(s) at which to add line(s) of constant longitude.

            color (str):
                The matplotlib color used for the contour(s).

            linewidth (float or int):
                The contour thickness.
            
            linestyle (str):
                The matplotlib linestyle used for the contour(s).

            marker (str):
                The matplotlib marker used for the contour(s).

        Returns:
            The object&#39;s contour_data parameter is populated appropriately.

        Raises:
            ValueError: issues encountered with supplied parameters.
        &#34;&#34;&#34;
        # Make sure some form of lat/lon is provided
        if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
            raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

        # If manually passing in lats &amp; lons, make sure both are provided
        if (lats is not None or lons is not None) and (lats is None or lons is None):
            raise (ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;))

        # Check that color exists in matplotlib
        if color not in matplotlib.colors.CSS4_COLORS:
            raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

        # Check that linestyle is valid
        if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
            raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

        # Check that linewidth is valid
        if linewidth &lt;= 0:
            raise ValueError(&#34;Linewidth must be greater than zero.&#34;)

        # Check that marker is valid
        if marker not in [&#34;&#34;, &#34;o&#34;, &#34;.&#34;, &#34;p&#34;, &#34;*&#34;, &#34;x&#34;, &#34;+&#34;, &#34;X&#34;]:
            raise ValueError(f&#34;Marker &#39;{marker}&#39; is not currently supported.&#34;)
        
        # Convert numerics to lists if necessary
        if constant_lats is not None:
            if isinstance(constant_lats, (float, int)):
                constant_lats = [constant_lats]
        if constant_lons is not None:
            if isinstance(constant_lons, (float, int)):
                constant_lons = [constant_lons]

        # Initialize contour data dict if it doesn&#39;t exist yet
        if self.contour_data is None:
            self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

        # Obtain the mosaic&#39;s projection
        source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
        mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
        transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

        # First handling manually supplied lat/lon arrays
        if (lats is not None) and (lons is not None):
            # Convert lists to ndarrays if necessary
            if isinstance(lats, list):
                lats = np.array(lats)
            if isinstance(lons, list):
                lons = np.array(lons)

            if len(lats) != len(lons):
                raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

            # Create specified contour from geographic coords
            x, y = transformer.transform(lons, lats)
            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(x)
            self.contour_data[&#34;y&#34;].append(y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Next handling lines of constant latitude
        if constant_lats is not None:
            # Generate longitudinal domain of the lat line (full globe)
            lon_domain = np.arange(-180, 180 + 0.2, 0.2)

            # Iterate through all lines of constant lat requested
            for lat in constant_lats:
                # Create line of constant lat
                const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
                sort_idx = np.argsort(const_lat_x)
                const_lat_y = const_lat_y[sort_idx]
                const_lat_x = const_lat_x[sort_idx]
                const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)
                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lat_x)
                self.contour_data[&#34;y&#34;].append(const_lat_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Now handling lines of constant longitude
        if constant_lons is not None:
            # Generate latitudinal domain of the lon line (full globe)
            lat_domain = np.arange(-90, 90 + 0.1, 0.1)

            # Iterate through all lines of constant lon requested
            for lon in constant_lons:
                # Create line of constant lon and add to dict
                const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
                sort_idx = np.argsort(const_lon_y)
                const_lon_x = const_lon_x[sort_idx]
                const_lon_y = const_lon_y[sort_idx]
                const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lon_x)
                self.contour_data[&#34;y&#34;].append(const_lon_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    def add_mag_contours(self,
                         timestamp: datetime.datetime,
                         constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         lats: Optional[Union[ndarray, list]] = None,
                         lons: Optional[Union[ndarray, list]] = None,
                         color: str = &#34;black&#34;,
                         linewidth: Union[float, int] = 1,
                         linestyle: str = &#34;solid&#34;,
                         marker: str = &#34;&#34;,
                         bring_to_front: bool = False):
        &#34;&#34;&#34;
        Add geomagnetic contours to a mosaic.

        Args:
            timestamp (datetime.datetime):
                The timestamp used in computing AACGM coordinates.

            lats (ndarray or list):
                Sequence of geomagnetic latitudes defining a contour.
            
            lons (ndarray or list):
                Sequence of geomagnetic longitudes defining a contour.

            constant_lats (float, int, Sequence):
                Geomagnetic latitude(s) at which to add contour(s) of constant latitude.
            
            constant_lons (float, int, Sequence):
                Geomagnetic longitude(s) at which to add contours(s) of constant longitude.

            color (str):
                The matplotlib color used for the contour(s).

            linewidth (float or int):
                The contour thickness.

            linestyle (str):
                The matplotlib linestyle used for the contour(s).

            marker (str):
                The matplotlib marker used for the contour(s).

        Returns:
            The object&#39;s contour_data parameter is populated appropriately.

        Raises:
            ValueError: issues encountered with supplied parameters.
        &#34;&#34;&#34;
        # Make sure some form of lat/lon is provided
        if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
            raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

        # If manually passing in lats &amp; lons, make sure both are provided
        if (lats is not None or lons is not None) and (lats is None or lons is None):
            raise (ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;))

        # Check that color exists in matplotlib
        if color not in matplotlib.colors.CSS4_COLORS:
            raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

        # Check that linestyle is valid
        if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
            raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

        # Check that linewidth is valid
        if linewidth &lt;= 0:
            raise ValueError(&#34;linewidth must be greater than zero.&#34;)

        # Convert numerics to lists if necessary
        if constant_lats is not None:
            if isinstance(constant_lats, (float, int)):
                constant_lats = [constant_lats]
        if constant_lons is not None:
            if isinstance(constant_lons, (float, int)):
                constant_lons = [constant_lons]

        # Initialize contour data dict if it doesn&#39;t exist yet
        if self.contour_data is None:
            self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

        # Obtain the mosaic&#39;s projection
        source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
        mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
        transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

        # First handling manually supplied lat/lon arrays
        if (lats is not None) and (lons is not None):
            # Convert lists to ndarrays if necessary
            if isinstance(lats, list):
                lats = np.array(lats)
            if isinstance(lons, list):
                lons = np.array(lons)

            if len(lats) != len(lons):
                raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

            # Create specified contour from magnetic coords
            y, x, alt = aacgmv2.convert_latlon_arr(lats, lons, lats * 0.0, timestamp, method_code=&#34;A2G&#34;)
            x, y = transformer.transform(x, y)
            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(x)
            self.contour_data[&#34;y&#34;].append(y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Next handling lines of constant latitude
        if constant_lats is not None:
            # Generate longitudinal domain of the lat line (full globe)
            lon_domain = np.arange(-180, 180 + 0.2, 0.2)

            # iterate through all lines of constant lat requested
            for lat in constant_lats:
                # Create line of constant lat from magnetic coords
                const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
                const_lat_y, const_lat_x, alt = aacgmv2.convert_latlon_arr(const_lat_y, const_lat_x, const_lat_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
                sort_idx = np.argsort(const_lat_x)
                const_lat_y = const_lat_y[sort_idx]
                const_lat_x = const_lat_x[sort_idx]
                const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lat_x)
                self.contour_data[&#34;y&#34;].append(const_lat_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Now handling lines of constant longitude
        if constant_lons is not None:
            # Generate latitudinal domain of the lon line (full globe)
            lat_domain = np.arange(-90, 90 + 0.1, 0.1)

            # iterate through all lines of constant lon requested
            for lon in constant_lons:
                # Create line of constant lon from magnetic coords
                const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
                const_lon_y, const_lon_x, alt = aacgmv2.convert_latlon_arr(const_lon_y, const_lon_x, const_lon_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
                sort_idx = np.argsort(const_lon_y)
                const_lon_x = const_lon_x[sort_idx]
                const_lon_y = const_lon_y[sort_idx]
                const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lon_x)
                self.contour_data[&#34;y&#34;].append(const_lon_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.tools.classes.mosaic.Mosaic.cartopy_projection"><code class="name">var <span class="ident">cartopy_projection</span> : cartopy.crs.Projection</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.Mosaic.contour_data"><code class="name">var <span class="ident">contour_data</span> : Optional[Dict[str, List[Any]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.Mosaic.polygon_data"><code class="name">var <span class="ident">polygon_data</span> : Union[matplotlib.collections.PolyCollection, List[matplotlib.collections.PolyCollection]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.tools.classes.mosaic.Mosaic.add_geo_contours"><code class="name flex">
<span>def <span class="ident">add_geo_contours</span></span>(<span>self, lats: Union[numpy.ndarray, list, ForwardRef(None)] = None, lons: Union[numpy.ndarray, list, ForwardRef(None)] = None, constant_lats: Union[float, int, Sequence[Union[float, int]], numpy.ndarray, ForwardRef(None)] = None, constant_lons: Union[float, int, Sequence[Union[float, int]], numpy.ndarray, ForwardRef(None)] = None, color: str = 'black', linewidth: Union[float, int] = 1, linestyle: str = 'solid', marker: str = '', bring_to_front: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add geographic contours to a mosaic.</p>
<h2 id="args">Args</h2>
<p>lats (ndarray or list):
Sequence of geographic latitudes defining a contour.</p>
<p>lons (ndarray or list):
Sequence of geographic longitudes defining a contour.</p>
<p>constant_lats (float, int, or Sequence):
Geographic Latitude(s) at which to add line(s) of constant latitude.</p>
<p>constant_lons (float, int, or Sequence):
Geographic Longitude(s) at which to add line(s) of constant longitude.</p>
<p>color (str):
The matplotlib color used for the contour(s).</p>
<p>linewidth (float or int):
The contour thickness.</p>
<p>linestyle (str):
The matplotlib linestyle used for the contour(s).</p>
<p>marker (str):
The matplotlib marker used for the contour(s).</p>
<h2 id="returns">Returns</h2>
<p>The object's contour_data parameter is populated appropriately.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues encountered with supplied parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_geo_contours(self,
                     lats: Optional[Union[ndarray, list]] = None,
                     lons: Optional[Union[ndarray, list]] = None,
                     constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                     constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                     color: str = &#34;black&#34;,
                     linewidth: Union[float, int] = 1,
                     linestyle: str = &#34;solid&#34;,
                     marker: str = &#34;&#34;,
                     bring_to_front: bool = False):
    &#34;&#34;&#34;
    Add geographic contours to a mosaic.

    Args:
        lats (ndarray or list):
            Sequence of geographic latitudes defining a contour.
        
        lons (ndarray or list):
            Sequence of geographic longitudes defining a contour.

        constant_lats (float, int, or Sequence):
            Geographic Latitude(s) at which to add line(s) of constant latitude.
        
        constant_lons (float, int, or Sequence):
            Geographic Longitude(s) at which to add line(s) of constant longitude.

        color (str):
            The matplotlib color used for the contour(s).

        linewidth (float or int):
            The contour thickness.
        
        linestyle (str):
            The matplotlib linestyle used for the contour(s).

        marker (str):
            The matplotlib marker used for the contour(s).

    Returns:
        The object&#39;s contour_data parameter is populated appropriately.

    Raises:
        ValueError: issues encountered with supplied parameters.
    &#34;&#34;&#34;
    # Make sure some form of lat/lon is provided
    if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
        raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

    # If manually passing in lats &amp; lons, make sure both are provided
    if (lats is not None or lons is not None) and (lats is None or lons is None):
        raise (ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;))

    # Check that color exists in matplotlib
    if color not in matplotlib.colors.CSS4_COLORS:
        raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

    # Check that linestyle is valid
    if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
        raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

    # Check that linewidth is valid
    if linewidth &lt;= 0:
        raise ValueError(&#34;Linewidth must be greater than zero.&#34;)

    # Check that marker is valid
    if marker not in [&#34;&#34;, &#34;o&#34;, &#34;.&#34;, &#34;p&#34;, &#34;*&#34;, &#34;x&#34;, &#34;+&#34;, &#34;X&#34;]:
        raise ValueError(f&#34;Marker &#39;{marker}&#39; is not currently supported.&#34;)
    
    # Convert numerics to lists if necessary
    if constant_lats is not None:
        if isinstance(constant_lats, (float, int)):
            constant_lats = [constant_lats]
    if constant_lons is not None:
        if isinstance(constant_lons, (float, int)):
            constant_lons = [constant_lons]

    # Initialize contour data dict if it doesn&#39;t exist yet
    if self.contour_data is None:
        self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

    # Obtain the mosaic&#39;s projection
    source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
    mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
    transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

    # First handling manually supplied lat/lon arrays
    if (lats is not None) and (lons is not None):
        # Convert lists to ndarrays if necessary
        if isinstance(lats, list):
            lats = np.array(lats)
        if isinstance(lons, list):
            lons = np.array(lons)

        if len(lats) != len(lons):
            raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

        # Create specified contour from geographic coords
        x, y = transformer.transform(lons, lats)
        # Add contour to dict, along with color and linewidth
        self.contour_data[&#34;x&#34;].append(x)
        self.contour_data[&#34;y&#34;].append(y)
        self.contour_data[&#34;color&#34;].append(color)
        self.contour_data[&#34;linewidth&#34;].append(linewidth)
        self.contour_data[&#34;linestyle&#34;].append(linestyle)
        self.contour_data[&#34;marker&#34;].append(marker)
        self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    # Next handling lines of constant latitude
    if constant_lats is not None:
        # Generate longitudinal domain of the lat line (full globe)
        lon_domain = np.arange(-180, 180 + 0.2, 0.2)

        # Iterate through all lines of constant lat requested
        for lat in constant_lats:
            # Create line of constant lat
            const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
            sort_idx = np.argsort(const_lat_x)
            const_lat_y = const_lat_y[sort_idx]
            const_lat_x = const_lat_x[sort_idx]
            const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)
            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(const_lat_x)
            self.contour_data[&#34;y&#34;].append(const_lat_y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    # Now handling lines of constant longitude
    if constant_lons is not None:
        # Generate latitudinal domain of the lon line (full globe)
        lat_domain = np.arange(-90, 90 + 0.1, 0.1)

        # Iterate through all lines of constant lon requested
        for lon in constant_lons:
            # Create line of constant lon and add to dict
            const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
            sort_idx = np.argsort(const_lon_y)
            const_lon_x = const_lon_x[sort_idx]
            const_lon_y = const_lon_y[sort_idx]
            const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(const_lon_x)
            self.contour_data[&#34;y&#34;].append(const_lon_y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))</code></pre>
</details>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.Mosaic.add_mag_contours"><code class="name flex">
<span>def <span class="ident">add_mag_contours</span></span>(<span>self, timestamp: datetime.datetime, constant_lats: Union[float, int, Sequence[Union[float, int]], numpy.ndarray, ForwardRef(None)] = None, constant_lons: Union[float, int, Sequence[Union[float, int]], numpy.ndarray, ForwardRef(None)] = None, lats: Union[numpy.ndarray, list, ForwardRef(None)] = None, lons: Union[numpy.ndarray, list, ForwardRef(None)] = None, color: str = 'black', linewidth: Union[float, int] = 1, linestyle: str = 'solid', marker: str = '', bring_to_front: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add geomagnetic contours to a mosaic.</p>
<h2 id="args">Args</h2>
<p>timestamp (datetime.datetime):
The timestamp used in computing AACGM coordinates.</p>
<p>lats (ndarray or list):
Sequence of geomagnetic latitudes defining a contour.</p>
<p>lons (ndarray or list):
Sequence of geomagnetic longitudes defining a contour.</p>
<p>constant_lats (float, int, Sequence):
Geomagnetic latitude(s) at which to add contour(s) of constant latitude.</p>
<p>constant_lons (float, int, Sequence):
Geomagnetic longitude(s) at which to add contours(s) of constant longitude.</p>
<p>color (str):
The matplotlib color used for the contour(s).</p>
<p>linewidth (float or int):
The contour thickness.</p>
<p>linestyle (str):
The matplotlib linestyle used for the contour(s).</p>
<p>marker (str):
The matplotlib marker used for the contour(s).</p>
<h2 id="returns">Returns</h2>
<p>The object's contour_data parameter is populated appropriately.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues encountered with supplied parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_mag_contours(self,
                     timestamp: datetime.datetime,
                     constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                     constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                     lats: Optional[Union[ndarray, list]] = None,
                     lons: Optional[Union[ndarray, list]] = None,
                     color: str = &#34;black&#34;,
                     linewidth: Union[float, int] = 1,
                     linestyle: str = &#34;solid&#34;,
                     marker: str = &#34;&#34;,
                     bring_to_front: bool = False):
    &#34;&#34;&#34;
    Add geomagnetic contours to a mosaic.

    Args:
        timestamp (datetime.datetime):
            The timestamp used in computing AACGM coordinates.

        lats (ndarray or list):
            Sequence of geomagnetic latitudes defining a contour.
        
        lons (ndarray or list):
            Sequence of geomagnetic longitudes defining a contour.

        constant_lats (float, int, Sequence):
            Geomagnetic latitude(s) at which to add contour(s) of constant latitude.
        
        constant_lons (float, int, Sequence):
            Geomagnetic longitude(s) at which to add contours(s) of constant longitude.

        color (str):
            The matplotlib color used for the contour(s).

        linewidth (float or int):
            The contour thickness.

        linestyle (str):
            The matplotlib linestyle used for the contour(s).

        marker (str):
            The matplotlib marker used for the contour(s).

    Returns:
        The object&#39;s contour_data parameter is populated appropriately.

    Raises:
        ValueError: issues encountered with supplied parameters.
    &#34;&#34;&#34;
    # Make sure some form of lat/lon is provided
    if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
        raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

    # If manually passing in lats &amp; lons, make sure both are provided
    if (lats is not None or lons is not None) and (lats is None or lons is None):
        raise (ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;))

    # Check that color exists in matplotlib
    if color not in matplotlib.colors.CSS4_COLORS:
        raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

    # Check that linestyle is valid
    if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
        raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

    # Check that linewidth is valid
    if linewidth &lt;= 0:
        raise ValueError(&#34;linewidth must be greater than zero.&#34;)

    # Convert numerics to lists if necessary
    if constant_lats is not None:
        if isinstance(constant_lats, (float, int)):
            constant_lats = [constant_lats]
    if constant_lons is not None:
        if isinstance(constant_lons, (float, int)):
            constant_lons = [constant_lons]

    # Initialize contour data dict if it doesn&#39;t exist yet
    if self.contour_data is None:
        self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

    # Obtain the mosaic&#39;s projection
    source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
    mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
    transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

    # First handling manually supplied lat/lon arrays
    if (lats is not None) and (lons is not None):
        # Convert lists to ndarrays if necessary
        if isinstance(lats, list):
            lats = np.array(lats)
        if isinstance(lons, list):
            lons = np.array(lons)

        if len(lats) != len(lons):
            raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

        # Create specified contour from magnetic coords
        y, x, alt = aacgmv2.convert_latlon_arr(lats, lons, lats * 0.0, timestamp, method_code=&#34;A2G&#34;)
        x, y = transformer.transform(x, y)
        # Add contour to dict, along with color and linewidth
        self.contour_data[&#34;x&#34;].append(x)
        self.contour_data[&#34;y&#34;].append(y)
        self.contour_data[&#34;color&#34;].append(color)
        self.contour_data[&#34;linewidth&#34;].append(linewidth)
        self.contour_data[&#34;linestyle&#34;].append(linestyle)
        self.contour_data[&#34;marker&#34;].append(marker)
        self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    # Next handling lines of constant latitude
    if constant_lats is not None:
        # Generate longitudinal domain of the lat line (full globe)
        lon_domain = np.arange(-180, 180 + 0.2, 0.2)

        # iterate through all lines of constant lat requested
        for lat in constant_lats:
            # Create line of constant lat from magnetic coords
            const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
            const_lat_y, const_lat_x, alt = aacgmv2.convert_latlon_arr(const_lat_y, const_lat_x, const_lat_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
            sort_idx = np.argsort(const_lat_x)
            const_lat_y = const_lat_y[sort_idx]
            const_lat_x = const_lat_x[sort_idx]
            const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)

            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(const_lat_x)
            self.contour_data[&#34;y&#34;].append(const_lat_y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    # Now handling lines of constant longitude
    if constant_lons is not None:
        # Generate latitudinal domain of the lon line (full globe)
        lat_domain = np.arange(-90, 90 + 0.1, 0.1)

        # iterate through all lines of constant lon requested
        for lon in constant_lons:
            # Create line of constant lon from magnetic coords
            const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
            const_lon_y, const_lon_x, alt = aacgmv2.convert_latlon_arr(const_lon_y, const_lon_x, const_lon_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
            sort_idx = np.argsort(const_lon_y)
            const_lon_x = const_lon_x[sort_idx]
            const_lon_y = const_lon_y[sort_idx]
            const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(const_lon_x)
            self.contour_data[&#34;y&#34;].append(const_lon_y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))</code></pre>
</details>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.Mosaic.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, map_extent: Sequence[Union[float, int]], figsize: Optional[Tuple[int, int]] = None, rayleighs: bool = False, max_rayleighs: int = 20000, title: Optional[str] = None, ocean_color: Optional[str] = None, land_color: str = 'gray', land_edgecolor: str = '#8A8A8A', borders_color: str = '#AEAEAE', borders_disable: bool = False, cbar_colormap: str = 'gray', returnfig: bool = False, savefig: bool = False, savefig_filename: Optional[str] = None, savefig_quality: Optional[int] = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a plot of the mosaic data. </p>
<p>Either display it (default behaviour), save it to disk (using the <code>savefig</code> parameter), or
return the matplotlib plot object for further usage (using the <code>returnfig</code> parameter).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>map_extent</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>Latitude/longitude range to be visible on the rendered map. This is a list of 4 integers
and/or floats, in the order of [min_lon, max_lon, min_lat, max_lat].</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The matplotlib figure size to use when plotting. For example <code>figsize=(14,4)</code>.</dd>
<dt><strong><code>rayleighs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to <code>True</code> if the data being plotted is in Rayleighs. Defaults to <code>False</code>.</dd>
<dt><strong><code>max_rayleighs</code></strong> :&ensp;<code>int</code></dt>
<dd>Max intensity scale for Rayleighs. Defaults to <code>20000</code>.</dd>
<dt><strong><code>ocean_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Colour of the ocean. Default is cartopy's default shade of blue. Colours can be supplied
as a word, or hexcode prefixed with a '#' character (ie. <code>#55AADD</code>).</dd>
<dt><strong><code>land_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Colour of the land. Default is <code>gray</code>. Colours can be supplied as a word, or hexcode
prefixed with a '#' character (ie. <code>#41BB87</code>).</dd>
<dt><strong><code>land_edgecolor</code></strong> :&ensp;<code>str</code></dt>
<dd>Color of the land edges. Default is <code>#8A8A8A</code>. Colours can be supplied as a word, or
hexcode prefixed with a '#' character.</dd>
<dt><strong><code>borders_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Color of the country borders. Default is <code>AEAEAE</code>. Colours can be supplied as a word, or
hexcode prefixed with a '#' character.</dd>
<dt><strong><code>borders_disable</code></strong> :&ensp;<code>bool</code></dt>
<dd>Disbale rendering of the borders. Default is <code>False</code>.</dd>
<dt><strong><code>cbar_colorcmap</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The matplotlib colormap to use for the plotted color bar. Default is <code>gray</code>.</p>
<p>Commonly used colormaps are:</p>
<ul>
<li>REGO: <code>gist_heat</code></li>
<li>THEMIS ASI: <code>gray</code></li>
<li>TREx Blue: <code>Blues_r</code></li>
<li>TREx NIR: <code>gray</code></li>
<li>TREx RGB: <code>None</code></li>
</ul>
<p>A list of all available colormaps can be found on the
<a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">matplotlib documentation</a>.</p>
</dd>
<dt><strong><code>returnfig</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Instead of displaying the image, return the matplotlib figure object. This allows for further plot
manipulation, for example, adding labels or a title in a different location than the default. </p>
<p>Remember - if this parameter is supplied, be sure that you close your plot after finishing work
with it. This can be achieved by doing <code>plt.close(fig)</code>. </p>
<p>Note that this method cannot be used in combination with <code>savefig</code>.</p>
</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if
this parameter is set to True. Defaults to <code>False</code>.</dd>
<dt><strong><code>savefig_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save the image to. Must be specified if the savefig parameter is set to True.</dd>
<dt><strong><code>savefig_quality</code></strong> :&ensp;<code>int</code></dt>
<dd>Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow's default of 75%.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The displayed montage, by default. If <code>savefig</code> is set to True, nothing will be returned. If <code>returnfig</code> is
set to True, the plotting variables <code>(fig, ax)</code> will be returned.
Raises:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         map_extent: Sequence[Union[float, int]],
         figsize: Optional[Tuple[int, int]] = None,
         rayleighs: bool = False,
         max_rayleighs: int = 20000,
         title: Optional[str] = None,
         ocean_color: Optional[str] = None,
         land_color: str = &#34;gray&#34;,
         land_edgecolor: str = &#34;#8A8A8A&#34;,
         borders_color: str = &#34;#AEAEAE&#34;,
         borders_disable: bool = False,
         cbar_colormap: str = &#34;gray&#34;,
         returnfig: bool = False,
         savefig: bool = False,
         savefig_filename: Optional[str] = None,
         savefig_quality: Optional[int] = None) -&gt; Any:
    &#34;&#34;&#34;
    Generate a plot of the mosaic data. 
    
    Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
    return the matplotlib plot object for further usage (using the `returnfig` parameter).

    Args:
        map_extent (List[int]): 
            Latitude/longitude range to be visible on the rendered map. This is a list of 4 integers 
            and/or floats, in the order of [min_lon, max_lon, min_lat, max_lat].

        figsize (tuple): 
            The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

        rayleighs (bool): 
            Set to `True` if the data being plotted is in Rayleighs. Defaults to `False`.

        max_rayleighs (int): 
            Max intensity scale for Rayleighs. Defaults to `20000`.

        ocean_color (str): 
            Colour of the ocean. Default is cartopy&#39;s default shade of blue. Colours can be supplied
            as a word, or hexcode prefixed with a &#39;#&#39; character (ie. `#55AADD`).
        
        land_color (str): 
            Colour of the land. Default is `gray`. Colours can be supplied as a word, or hexcode 
            prefixed with a &#39;#&#39; character (ie. `#41BB87`).

        land_edgecolor (str): 
            Color of the land edges. Default is `#8A8A8A`. Colours can be supplied as a word, or
            hexcode prefixed with a &#39;#&#39; character.

        borders_color (str): 
            Color of the country borders. Default is `AEAEAE`. Colours can be supplied as a word, or
            hexcode prefixed with a &#39;#&#39; character.
        
        borders_disable (bool): 
            Disbale rendering of the borders. Default is `False`.

        cbar_colorcmap (str): 
            The matplotlib colormap to use for the plotted color bar. Default is `gray`.

            Commonly used colormaps are:

            - REGO: `gist_heat`
            - THEMIS ASI: `gray`
            - TREx Blue: `Blues_r`
            - TREx NIR: `gray`
            - TREx RGB: `None`

            A list of all available colormaps can be found on the 
            [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).

        returnfig (bool): 
            Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
            manipulation, for example, adding labels or a title in a different location than the default. 
            
            Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
            with it. This can be achieved by doing `plt.close(fig)`. 
            
            Note that this method cannot be used in combination with `savefig`.

        savefig (bool): 
            Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
            this parameter is set to True. Defaults to `False`.

        savefig_filename (str): 
            Filename to save the image to. Must be specified if the savefig parameter is set to True.

        savefig_quality (int): 
            Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
            is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

    Returns:
        The displayed montage, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
        set to True, the plotting variables `(fig, ax)` will be returned.

    Raises:
    &#34;&#34;&#34;
    # check return mode
    if (returnfig is True and savefig is True):
        raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
    if (returnfig is True and (savefig_filename is not None or savefig_quality is not None)):
        warnings.warn(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                      &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                      stacklevel=1)
    elif (savefig is False and (savefig_filename is not None or savefig_quality is not None)):
        warnings.warn(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                      &#34;savefig option parameters will be ignored.&#34;,
                      stacklevel=1)

    # initialize figure
    fig = plt.figure(figsize=figsize)
    ax = fig.add_axes((0, 0, 1, 1), projection=self.cartopy_projection)
    ax.set_extent(map_extent, crs=cartopy.crs.Geodetic())  # type: ignore

    # add ocean
    #
    # NOTE: we use the default ocean color
    if (ocean_color is not None):
        ax.add_feature(cartopy.feature.OCEAN, facecolor=ocean_color, zorder=0)  # type: ignore
    else:
        ax.add_feature(cartopy.feature.OCEAN, zorder=0)  # type: ignore

    # add land
    ax.add_feature(cartopy.feature.LAND, facecolor=land_color, edgecolor=land_edgecolor, zorder=0)  # type: ignore

    # add borders
    if (borders_disable is False):
        ax.add_feature(cartopy.feature.BORDERS, edgecolor=borders_color, zorder=0)  # type: ignore

    # add polygon data
    #
    # NOTE: it seems that when running this function a second time, the polygon
    # data is not too happy. So to handle this, we plot a copy of the polygon data
    if isinstance(self.polygon_data, list):
        for polygon_data in self.polygon_data:
            ax.add_collection(copy(polygon_data))
    else:
        ax.add_collection(copy(self.polygon_data))

    if self.contour_data is not None:
        for i in range(len(self.contour_data[&#34;x&#34;])):
            ax.plot(self.contour_data[&#34;x&#34;][i],
                    self.contour_data[&#34;y&#34;][i],
                    color=self.contour_data[&#34;color&#34;][i],
                    linewidth=self.contour_data[&#34;linewidth&#34;][i],
                    linestyle=self.contour_data[&#34;linestyle&#34;][i],
                    marker=self.contour_data[&#34;marker&#34;][i],
                    zorder=self.contour_data[&#34;zorder&#34;][i])

    # set title
    if (title is not None):
        ax.set_title(title)

    # add text
    if (rayleighs is True):
        if isinstance(self.polygon_data, list):
            raise ValueError(&#34;Rayleighs Keyword is currently not available for mosaics with multiple sets of data.&#34;)
        
        # Create a colorbar, in Rayleighs, that accounts for the scaling limit we applied
        cbar_ticks = [float(j) / 5. for j in range(0, 6)]
        cbar_ticknames = [str(int(max_rayleighs / 5) * j) for j in range(0, 6)]

        # Any pixels with the max Rayleigh value could be greater than it, so we include the plus sign
        cbar_ticknames[-1] += &#34;+&#34;
        self.polygon_data.set_cmap(cbar_colormap)
        cbar = plt.colorbar(self.polygon_data, shrink=0.5, ticks=cbar_ticks, ax=ax)
        cbar.ax.set_yticklabels(cbar_ticknames)
        plt.text(1.025,
                 0.5,
                 &#34;Intensity (Rayleighs)&#34;,
                 fontsize=14,
                 transform=ax.transAxes,
                 va=&#34;center&#34;,
                 rotation=&#34;vertical&#34;,
                 weight=&#34;bold&#34;,
                 style=&#34;oblique&#34;)

    # save figure or show it
    if (savefig is True):
        # check that filename has been set
        if (savefig_filename is None):
            raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

        # save the figure
        f_extension = os.path.splitext(savefig_filename)[-1].lower()
        if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
            # check quality setting
            if (savefig_quality is not None):
                plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
            else:
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
        else:
            if (savefig_quality is not None):
                # quality specified, but output filename is not a JPG, so show a warning
                warnings.warn(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                              &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                              stacklevel=1)
            plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

        # clean up by closing the figure
        plt.close(fig)
    elif (returnfig is True):
        # return the figure and axis objects
        return (fig, ax)
    else:
        # show the figure
        plt.show(fig)

        # cleanup by closing the figure
        plt.close(fig)

    # return
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.MosaicData"><code class="flex name class">
<span>class <span class="ident">MosaicData</span></span>
<span>(</span><span>site_uid_list: List[str], timestamps: List[datetime.datetime], images: Dict[str, numpy.ndarray], images_dimensions: Dict[str, Tuple])</span>
</code></dt>
<dd>
<div class="desc"><p>Prepared image data for use by mosaic routines.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>site_uid_list</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of site unique identifiers contained within this object.</dd>
<dt><strong><code>timestamps</code></strong> :&ensp;<code>List[datetime.datetime]</code></dt>
<dd>Timestamps of corresponding images.</dd>
<dt><strong><code>images</code></strong> :&ensp;<code>Dict[str, numpy.ndarray]</code></dt>
<dd>Image data prepared into the necessary format; a dictionary. Keys are the site UID,
ndarray is the prepared data.</dd>
<dt><strong><code>images_dimensions</code></strong> :&ensp;<code>Dict[str, Tuple]</code></dt>
<dd>The image dimensions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class MosaicData:
    &#34;&#34;&#34;
    Prepared image data for use by mosaic routines.

    Attributes:
        site_uid_list (List[str]): 
            List of site unique identifiers contained within this object.
        timestamps (List[datetime.datetime]): 
            Timestamps of corresponding images.
        images (Dict[str, numpy.ndarray]): 
            Image data prepared into the necessary format; a dictionary. Keys are the site UID, 
            ndarray is the prepared data.
        images_dimensions (Dict[str, Tuple]): 
            The image dimensions.    
    &#34;&#34;&#34;

    site_uid_list: List[str]
    timestamps: List[datetime.datetime]
    images: Dict[str, ndarray]
    images_dimensions: Dict[str, Tuple]

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        unique_dimensions = str(list(dict.fromkeys(self.images_dimensions.values()))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        images_str = &#34;Dict[%d sites of array(dims=%s)]&#34; % (len(self.images.keys()), unique_dimensions)
        timestamps_str = &#34;[%d timestamps]&#34; % (len(self.timestamps))

        return &#34;MosaicData(images=%s, timestamps=%s, site_uid_list=%s)&#34; % (images_str, timestamps_str, self.site_uid_list.__repr__())</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.tools.classes.mosaic.MosaicData.images"><code class="name">var <span class="ident">images</span> : Dict[str, numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.MosaicData.images_dimensions"><code class="name">var <span class="ident">images_dimensions</span> : Dict[str, Tuple]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.MosaicData.site_uid_list"><code class="name">var <span class="ident">site_uid_list</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.MosaicData.timestamps"><code class="name">var <span class="ident">timestamps</span> : List[datetime.datetime]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.MosaicSkymap"><code class="flex name class">
<span>class <span class="ident">MosaicSkymap</span></span>
<span>(</span><span>site_uid_list: List[str], elevation: List[numpy.ndarray], polyfill_lat: List[numpy.ndarray], polyfill_lon: List[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Prepared skymap data for use by mosaic routines.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>site_uid_list</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of site unique identifiers contained within this object.</dd>
<dt><strong><code>elevation</code></strong> :&ensp;<code>List[numpy.ndarray]</code></dt>
<dd>List of elevation data, with each element corresponding to each site. Order
matches that of the <code>site_uid_list</code> attribute.</dd>
<dt><strong><code>polyfoll_lat</code></strong> :&ensp;<code>List[numpy.ndarray]</code></dt>
<dd>List of latitude polygon data, with each element corresponding to each site.
Order matches that of the <code>site_uid_list</code> attribute. </dd>
<dt><strong><code>polyfoll_lon</code></strong> :&ensp;<code>List[numpy.ndarray]</code></dt>
<dd>List of longitude polygon data, with each element corresponding to each site.
Order matches that of the <code>site_uid_list</code> attribute.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class MosaicSkymap:
    &#34;&#34;&#34;
    Prepared skymap data for use by mosaic routines.

    Attributes:
        site_uid_list (List[str]): 
            List of site unique identifiers contained within this object.
        elevation (List[numpy.ndarray]): 
            List of elevation data, with each element corresponding to each site. Order 
            matches that of the `site_uid_list` attribute.
        polyfoll_lat (List[numpy.ndarray]): 
            List of latitude polygon data, with each element corresponding to each site. 
            Order matches that of the `site_uid_list` attribute. 
        polyfoll_lon (List[numpy.ndarray]): 
            List of longitude polygon data, with each element corresponding to each site. 
            Order matches that of the `site_uid_list` attribute. 
    &#34;&#34;&#34;

    site_uid_list: List[str]
    elevation: List[ndarray]
    polyfill_lat: List[ndarray]
    polyfill_lon: List[ndarray]

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        unique_polyfill_lat_dims = str(list(dict.fromkeys(fill_arr.shape
                                                          for fill_arr in self.polyfill_lat))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                        &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        unique_polyfill_lon_dims = str(list(dict.fromkeys(fill_arr.shape
                                                          for fill_arr in self.polyfill_lon))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                        &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        unique_elevation_dims = str(list(dict.fromkeys(el.shape for el in self.elevation))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)

        polyfill_lat_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lat_dims, self.polyfill_lat[0].dtype)
        polyfill_lon_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lon_dims, self.polyfill_lon[0].dtype)
        elevation_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_elevation_dims, self.elevation[0].dtype)

        return &#34;MosaicSkymap(polyfill_lat=%s, polyfill_lon=%s, elevation=%s, site_uid_list=%s)&#34; % (
            polyfill_lat_str,
            polyfill_lon_str,
            elevation_str,
            self.site_uid_list.__repr__(),
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.tools.classes.mosaic.MosaicSkymap.elevation"><code class="name">var <span class="ident">elevation</span> : List[numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.MosaicSkymap.polyfill_lat"><code class="name">var <span class="ident">polyfill_lat</span> : List[numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.MosaicSkymap.polyfill_lon"><code class="name">var <span class="ident">polyfill_lon</span> : List[numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.classes.mosaic.MosaicSkymap.site_uid_list"><code class="name">var <span class="ident">site_uid_list</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax.tools.classes" href="index.html">pyaurorax.tools.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.tools.classes.mosaic.Mosaic" href="#pyaurorax.tools.classes.mosaic.Mosaic">Mosaic</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.tools.classes.mosaic.Mosaic.add_geo_contours" href="#pyaurorax.tools.classes.mosaic.Mosaic.add_geo_contours">add_geo_contours</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.Mosaic.add_mag_contours" href="#pyaurorax.tools.classes.mosaic.Mosaic.add_mag_contours">add_mag_contours</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.Mosaic.cartopy_projection" href="#pyaurorax.tools.classes.mosaic.Mosaic.cartopy_projection">cartopy_projection</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.Mosaic.contour_data" href="#pyaurorax.tools.classes.mosaic.Mosaic.contour_data">contour_data</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.Mosaic.plot" href="#pyaurorax.tools.classes.mosaic.Mosaic.plot">plot</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.Mosaic.polygon_data" href="#pyaurorax.tools.classes.mosaic.Mosaic.polygon_data">polygon_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.tools.classes.mosaic.MosaicData" href="#pyaurorax.tools.classes.mosaic.MosaicData">MosaicData</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.tools.classes.mosaic.MosaicData.images" href="#pyaurorax.tools.classes.mosaic.MosaicData.images">images</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.MosaicData.images_dimensions" href="#pyaurorax.tools.classes.mosaic.MosaicData.images_dimensions">images_dimensions</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.MosaicData.site_uid_list" href="#pyaurorax.tools.classes.mosaic.MosaicData.site_uid_list">site_uid_list</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.MosaicData.timestamps" href="#pyaurorax.tools.classes.mosaic.MosaicData.timestamps">timestamps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.tools.classes.mosaic.MosaicSkymap" href="#pyaurorax.tools.classes.mosaic.MosaicSkymap">MosaicSkymap</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.tools.classes.mosaic.MosaicSkymap.elevation" href="#pyaurorax.tools.classes.mosaic.MosaicSkymap.elevation">elevation</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.MosaicSkymap.polyfill_lat" href="#pyaurorax.tools.classes.mosaic.MosaicSkymap.polyfill_lat">polyfill_lat</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.MosaicSkymap.polyfill_lon" href="#pyaurorax.tools.classes.mosaic.MosaicSkymap.polyfill_lon">polyfill_lon</a></code></li>
<li><code><a title="pyaurorax.tools.classes.mosaic.MosaicSkymap.site_uid_list" href="#pyaurorax.tools.classes.mosaic.MosaicSkymap.site_uid_list">site_uid_list</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
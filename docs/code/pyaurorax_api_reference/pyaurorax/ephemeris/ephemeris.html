<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyaurorax.ephemeris.ephemeris API documentation</title>
<meta name="description" content="Functions for performing ephemeris searches" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.ephemeris.ephemeris</code></h1>
</header>
<section id="section-intro">
<p>Functions for performing ephemeris searches</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Functions for performing ephemeris searches
&#34;&#34;&#34;

import datetime
import humanize
from typing import Dict, List, Optional
from .classes.ephemeris import Ephemeris
from .classes.search import Search
from ..sources import (DataSource,
                       list as sources_list)
from ..exceptions import (AuroraXSearchException,
                          AuroraXValidationException,
                          AuroraXUploadException,
                          AuroraXBadParametersException)
from ..requests import STANDARD_POLLING_SLEEP_TIME
from ..api import (AuroraXRequest, urls)

# pdoc init
__pdoc__: Dict = {}


def __validate_data_source(identifier: int,
                           records: List[Ephemeris]) -&gt; Optional[Ephemeris]:
    # get all current sources
    sources = {source.identifier: source for source in sources_list()}
    if identifier not in sources.keys():
        raise AuroraXValidationException(f&#34;Data source with unique identifier &#34;
                                         &#34;{identifier} could not be found&#34;)

    # process each record to make sure the program/platform/instrument_type matches
    # the identifier found for the data source
    for record in records:
        # check the identifier, program name, platform name, and instrument type
        try:
            reference = sources[record.data_source.identifier]
        except KeyError:
            raise AuroraXValidationException(f&#34;Data source with unique identifier &#34;
                                             &#34;{record.data_source.identifier} could &#34;
                                             &#34;not be found&#34;)

        # check if it&#39;s a bad record
        if not (record.data_source.program == reference.program
                and record.data_source.platform == reference.platform
                and record.data_source.instrument_type == reference.instrument_type):
            return record

    # found no bad records
    return None


def search(start: datetime.datetime,
           end: datetime.datetime,
           programs: Optional[List[str]] = None,
           platforms: Optional[List[str]] = None,
           instrument_types: Optional[List[str]] = None,
           metadata_filters: Optional[List[Dict]] = None,
           metadata_filters_logical_operator: Optional[str] = None,
           response_format: Optional[Dict] = None,
           poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
           return_immediately: Optional[bool] = False,
           verbose: Optional[bool] = False) -&gt; Search:
    &#34;&#34;&#34;
    Search for ephemeris records

    By default, this function will block and wait until the request completes and
    all data is downloaded. If you don&#39;t want to wait, set the &#39;return_immediately`
    value to True. The Search object will be returned right after the search has been
    started, and you can use the helper functions as part of that object to get the
    data when it&#39;s done.

    Note: At least one search criteria from programs, platforms, or
    instrument_types, must be specified.

    Args:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of programs to search through, defaults to None
        platforms: list of platforms to search through, defaults to None
        instrument_types: list of instrument types to search through, defaults to None
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            Example:

                [{
                    &#34;key&#34;: &#34;nbtrace_region&#34;,
                    &#34;operator&#34;: &#34;in&#34;,
                    &#34;values&#34;: [&#34;north polar cap&#34;]
                }]
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format
        poll_interval: time in seconds to wait between polling attempts, defaults
            to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
        return_immediately: initiate the search and return without waiting for data to
            be received, defaults to False
        verbose: output poll times and other progress messages, defaults to False

    Returns:
        A pyaurorax.ephemeris.Search object

    Raises:
        pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
    &#34;&#34;&#34;
    # create a Search() object
    s = Search(start,
               end,
               programs=programs,
               platforms=platforms,
               instrument_types=instrument_types,
               metadata_filters=metadata_filters,
               metadata_filters_logical_operator=metadata_filters_logical_operator,
               response_format=response_format)
    if (verbose is True):
        print(&#34;[%s] Search object created&#34; % (datetime.datetime.now()))

    # execute the search
    s.execute()
    if (verbose is True):
        print(&#34;[%s] Request submitted&#34; % (datetime.datetime.now()))
        print(&#34;[%s] Request ID: %s&#34; % (datetime.datetime.now(), s.request_id))
        print(&#34;[%s] Request details available at: %s&#34; % (datetime.datetime.now(),
                                                         s.request_url))

    # return immediately if we wanted to
    if (return_immediately is True):
        return s

    # wait for data
    if (verbose is True):
        print(&#34;[%s] Waiting for data ...&#34; % (datetime.datetime.now()))
    s.wait(poll_interval=poll_interval, verbose=verbose)

    # check if error condition encountered
    if (s.status[&#34;search_result&#34;][&#34;error_condition&#34;] is True):
        # error encountered
        raise AuroraXSearchException(s.logs[-1][&#34;summary&#34;])

    # get the data
    if (verbose is True):
        print(&#34;[%s] Retrieving data ...&#34; % (datetime.datetime.now()))
    s.get_data()

    # return response with the data
    if (verbose is True):
        print(&#34;[%s] Retrieved %s of data containing %d records&#34; % (datetime.datetime.now(),
                                                                   humanize.filesize.naturalsize(
                                                                       s.status[&#34;search_result&#34;][&#34;file_size&#34;]),
                                                                   s.status[&#34;search_result&#34;][&#34;result_count&#34;]))
    return s


def upload(identifier: int,
           records: List[Ephemeris],
           validate_source: Optional[bool] = False) -&gt; int:
    &#34;&#34;&#34;
    Upload ephemeris records to AuroraX

    Args:
        identifier: AuroraX data source ID
        records: ephemeris records to upload
        validate_source: validate all records before uploading, defaults to False

    Returns:
        0 for success, raises exception on error

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected content error
        pyaurorax.exceptions.AuroraXUploadException: upload error
        pyaurorax.exceptions.AuroraXValidationException: data source validation error
    &#34;&#34;&#34;
    # validate record sources if the flag is set
    if validate_source:
        validation_error = __validate_data_source(identifier, records)
        if validation_error:
            raise AuroraXValidationException(&#34;Unable to validate data source found &#34;
                                             &#34;in record: {}&#34;.format(validation_error))

    # translate each ephemeris record to a request-friendly
    # dict (ie. convert datetimes to strings, etc.)
    for i, _ in enumerate(records):
        if (type(records[i]) is Ephemeris):
            records[i] = records[i].to_json_serializable()  # type: ignore

    # make request
    url = urls.ephemeris_upload_url.format(identifier)
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=url,
                         body=records,
                         null_response=True)
    res = req.execute()

    # evaluate response
    if (res.status_code == 400):
        raise AuroraXUploadException(&#34;%s - %s&#34; % (res.data[&#34;error_code&#34;],
                                                  res.data[&#34;error_message&#34;]))

    # return
    return 0


def delete(data_source: DataSource,
           start: datetime.datetime,
           end: datetime.datetime) -&gt; int:
    &#34;&#34;&#34;
    Delete ephemeris records between a timeframe.

    The API processes this request asynchronously, so this method will return
    immediately whether or not the data has already been deleted.

    Args:
        data_source: data source associated with the data product records (note that
            identifier, program, platform, and instrument_type are required)
        start: timestamp marking beginning of range to delete records for, inclusive
        end: timestamp marking end of range to delete records for, inclusive

    Returns:
        0 on success

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
        pyaurorax.exceptions.AuroraXNotFoundException: source not found
        pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
        pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
    &#34;&#34;&#34;
    # check to make sure the identifier, program, platform, and instrument type are all set in the data source
    if not all([data_source.identifier, data_source.program, data_source.platform, data_source.instrument_type]):
        raise AuroraXBadParametersException(&#34;One or more required data source parameters &#34;
                                            &#34;are missing, delete operation aborted&#34;)

    # do request
    url = urls.ephemeris_upload_url.format(data_source.identifier)
    params = {
        &#34;program&#34;: data_source.program,
        &#34;platform&#34;: data_source.platform,
        &#34;instrument_type&#34;: data_source.instrument_type,
        &#34;start&#34;: start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;)
    }
    delete_req = AuroraXRequest(method=&#34;delete&#34;,
                                url=url,
                                body=params,
                                null_response=True)
    res = delete_req.execute()

    # evaluate response
    if (res.status_code == 400):
        if type(res.data) is list:
            raise AuroraXBadParametersException(&#34;%s - %s&#34; % (res.status_code,
                                                             res.data[0][&#34;message&#34;]))
        raise AuroraXBadParametersException(&#34;%s - %s&#34; % (res.data[&#34;error_code&#34;],
                                                         res.data[&#34;error_message&#34;]))

    # return
    return 0


def describe(search_obj: Search) -&gt; str:
    &#34;&#34;&#34;
    Describe an ephemeris search as a &#34;SQL-like&#34; string

    Args:
        search_obj: the ephemeris search object to describe

    Returns:
        the &#34;SQL-like&#34; string describing the ephemeris search object
    &#34;&#34;&#34;
    # make request
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=urls.describe_ephemeris_query_url,
                         body=search_obj.query)
    res = req.execute()

    # return
    return res.data


def get_request_url(request_id: str) -&gt; str:
    &#34;&#34;&#34;
    Get the ephemeris search request URL for a given
    request ID. This URL can be used for subsequent
    pyaurorax.requests function calls. Primarily this method
    facilitates delving into details about a set of already-submitted
    ephemeris searches.

    Args:
        request_id: the request identifier

    Returns:
        the request URL
    &#34;&#34;&#34;
    url = urls.ephemeris_request_url.format(request_id)
    return url</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyaurorax.ephemeris.ephemeris.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>data_source:Â <a title="pyaurorax.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.sources.classes.data_source.DataSource">DataSource</a>, start:Â datetime.datetime, end:Â datetime.datetime) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete ephemeris records between a timeframe.</p>
<p>The API processes this request asynchronously, so this method will return
immediately whether or not the data has already been deleted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_source</code></strong></dt>
<dd>data source associated with the data product records (note that
identifier, program, platform, and instrument_type are required)</dd>
<dt><strong><code>start</code></strong></dt>
<dd>timestamp marking beginning of range to delete records for, inclusive</dd>
<dt><strong><code>end</code></strong></dt>
<dd>timestamp marking end of range to delete records for, inclusive</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXMaxRetriesException" href="../exceptions.html#pyaurorax.exceptions.AuroraXMaxRetriesException">AuroraXMaxRetriesException</a></code></dt>
<dd>max retry error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXNotFoundException" href="../exceptions.html#pyaurorax.exceptions.AuroraXNotFoundException">AuroraXNotFoundException</a></code></dt>
<dd>source not found</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedException">AuroraXUnauthorizedException</a></code></dt>
<dd>invalid API key for this operation</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>missing parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(data_source: DataSource,
           start: datetime.datetime,
           end: datetime.datetime) -&gt; int:
    &#34;&#34;&#34;
    Delete ephemeris records between a timeframe.

    The API processes this request asynchronously, so this method will return
    immediately whether or not the data has already been deleted.

    Args:
        data_source: data source associated with the data product records (note that
            identifier, program, platform, and instrument_type are required)
        start: timestamp marking beginning of range to delete records for, inclusive
        end: timestamp marking end of range to delete records for, inclusive

    Returns:
        0 on success

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
        pyaurorax.exceptions.AuroraXNotFoundException: source not found
        pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
        pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
    &#34;&#34;&#34;
    # check to make sure the identifier, program, platform, and instrument type are all set in the data source
    if not all([data_source.identifier, data_source.program, data_source.platform, data_source.instrument_type]):
        raise AuroraXBadParametersException(&#34;One or more required data source parameters &#34;
                                            &#34;are missing, delete operation aborted&#34;)

    # do request
    url = urls.ephemeris_upload_url.format(data_source.identifier)
    params = {
        &#34;program&#34;: data_source.program,
        &#34;platform&#34;: data_source.platform,
        &#34;instrument_type&#34;: data_source.instrument_type,
        &#34;start&#34;: start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;)
    }
    delete_req = AuroraXRequest(method=&#34;delete&#34;,
                                url=url,
                                body=params,
                                null_response=True)
    res = delete_req.execute()

    # evaluate response
    if (res.status_code == 400):
        if type(res.data) is list:
            raise AuroraXBadParametersException(&#34;%s - %s&#34; % (res.status_code,
                                                             res.data[0][&#34;message&#34;]))
        raise AuroraXBadParametersException(&#34;%s - %s&#34; % (res.data[&#34;error_code&#34;],
                                                         res.data[&#34;error_message&#34;]))

    # return
    return 0</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.ephemeris.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>search_obj:Â <a title="pyaurorax.ephemeris.classes.search.Search" href="classes/search.html#pyaurorax.ephemeris.classes.search.Search">Search</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Describe an ephemeris search as a "SQL-like" string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>search_obj</code></strong></dt>
<dd>the ephemeris search object to describe</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the "SQL-like" string describing the ephemeris search object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(search_obj: Search) -&gt; str:
    &#34;&#34;&#34;
    Describe an ephemeris search as a &#34;SQL-like&#34; string

    Args:
        search_obj: the ephemeris search object to describe

    Returns:
        the &#34;SQL-like&#34; string describing the ephemeris search object
    &#34;&#34;&#34;
    # make request
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=urls.describe_ephemeris_query_url,
                         body=search_obj.query)
    res = req.execute()

    # return
    return res.data</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.ephemeris.get_request_url"><code class="name flex">
<span>def <span class="ident">get_request_url</span></span>(<span>request_id:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the ephemeris search request URL for a given
request ID. This URL can be used for subsequent
pyaurorax.requests function calls. Primarily this method
facilitates delving into details about a set of already-submitted
ephemeris searches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_id</code></strong></dt>
<dd>the request identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the request URL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_request_url(request_id: str) -&gt; str:
    &#34;&#34;&#34;
    Get the ephemeris search request URL for a given
    request ID. This URL can be used for subsequent
    pyaurorax.requests function calls. Primarily this method
    facilitates delving into details about a set of already-submitted
    ephemeris searches.

    Args:
        request_id: the request identifier

    Returns:
        the request URL
    &#34;&#34;&#34;
    url = urls.ephemeris_request_url.format(request_id)
    return url</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.ephemeris.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>start:Â datetime.datetime, end:Â datetime.datetime, programs:Â Optional[List[str]]Â =Â None, platforms:Â Optional[List[str]]Â =Â None, instrument_types:Â Optional[List[str]]Â =Â None, metadata_filters:Â Optional[List[Dict[~KT,Â ~VT]]]Â =Â None, metadata_filters_logical_operator:Â Optional[str]Â =Â None, response_format:Â Optional[Dict[~KT,Â ~VT]]Â =Â None, poll_interval:Â Optional[float]Â =Â 1.0, return_immediately:Â Optional[bool]Â =Â False, verbose:Â Optional[bool]Â =Â False) â€‘>Â <a title="pyaurorax.ephemeris.classes.search.Search" href="classes/search.html#pyaurorax.ephemeris.classes.search.Search">Search</a></span>
</code></dt>
<dd>
<div class="desc"><p>Search for ephemeris records</p>
<p>By default, this function will block and wait until the request completes and
all data is downloaded. If you don't want to wait, set the 'return_immediately`
value to True. The Search object will be returned right after the search has been
started, and you can use the helper functions as part of that object to get the
data when it's done.</p>
<p>Note: At least one search criteria from programs, platforms, or
instrument_types, must be specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong></dt>
<dd>list of programs to search through, defaults to None</dd>
<dt><strong><code>platforms</code></strong></dt>
<dd>list of platforms to search through, defaults to None</dd>
<dt><strong><code>instrument_types</code></strong></dt>
<dd>list of instrument types to search through, defaults to None</dd>
<dt><strong><code>metadata_filters</code></strong></dt>
<dd>
<p>list of dictionaries describing metadata keys and
values to filter on, defaults to None</p>
<p>Example:</p>
<pre><code>[{
    "key": "nbtrace_region",
    "operator": "in",
    "values": ["north polar cap"]
}]
</code></pre>
</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong></dt>
<dd>the logical operator to use when
evaluating metadata filters (either 'AND' or 'OR'), defaults
to "AND"</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts, defaults
to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>return_immediately</code></strong></dt>
<dd>initiate the search and return without waiting for data to
be received, defaults to False</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A pyaurorax.ephemeris.Search object</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>missing parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(start: datetime.datetime,
           end: datetime.datetime,
           programs: Optional[List[str]] = None,
           platforms: Optional[List[str]] = None,
           instrument_types: Optional[List[str]] = None,
           metadata_filters: Optional[List[Dict]] = None,
           metadata_filters_logical_operator: Optional[str] = None,
           response_format: Optional[Dict] = None,
           poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
           return_immediately: Optional[bool] = False,
           verbose: Optional[bool] = False) -&gt; Search:
    &#34;&#34;&#34;
    Search for ephemeris records

    By default, this function will block and wait until the request completes and
    all data is downloaded. If you don&#39;t want to wait, set the &#39;return_immediately`
    value to True. The Search object will be returned right after the search has been
    started, and you can use the helper functions as part of that object to get the
    data when it&#39;s done.

    Note: At least one search criteria from programs, platforms, or
    instrument_types, must be specified.

    Args:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of programs to search through, defaults to None
        platforms: list of platforms to search through, defaults to None
        instrument_types: list of instrument types to search through, defaults to None
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            Example:

                [{
                    &#34;key&#34;: &#34;nbtrace_region&#34;,
                    &#34;operator&#34;: &#34;in&#34;,
                    &#34;values&#34;: [&#34;north polar cap&#34;]
                }]
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format
        poll_interval: time in seconds to wait between polling attempts, defaults
            to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
        return_immediately: initiate the search and return without waiting for data to
            be received, defaults to False
        verbose: output poll times and other progress messages, defaults to False

    Returns:
        A pyaurorax.ephemeris.Search object

    Raises:
        pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
    &#34;&#34;&#34;
    # create a Search() object
    s = Search(start,
               end,
               programs=programs,
               platforms=platforms,
               instrument_types=instrument_types,
               metadata_filters=metadata_filters,
               metadata_filters_logical_operator=metadata_filters_logical_operator,
               response_format=response_format)
    if (verbose is True):
        print(&#34;[%s] Search object created&#34; % (datetime.datetime.now()))

    # execute the search
    s.execute()
    if (verbose is True):
        print(&#34;[%s] Request submitted&#34; % (datetime.datetime.now()))
        print(&#34;[%s] Request ID: %s&#34; % (datetime.datetime.now(), s.request_id))
        print(&#34;[%s] Request details available at: %s&#34; % (datetime.datetime.now(),
                                                         s.request_url))

    # return immediately if we wanted to
    if (return_immediately is True):
        return s

    # wait for data
    if (verbose is True):
        print(&#34;[%s] Waiting for data ...&#34; % (datetime.datetime.now()))
    s.wait(poll_interval=poll_interval, verbose=verbose)

    # check if error condition encountered
    if (s.status[&#34;search_result&#34;][&#34;error_condition&#34;] is True):
        # error encountered
        raise AuroraXSearchException(s.logs[-1][&#34;summary&#34;])

    # get the data
    if (verbose is True):
        print(&#34;[%s] Retrieving data ...&#34; % (datetime.datetime.now()))
    s.get_data()

    # return response with the data
    if (verbose is True):
        print(&#34;[%s] Retrieved %s of data containing %d records&#34; % (datetime.datetime.now(),
                                                                   humanize.filesize.naturalsize(
                                                                       s.status[&#34;search_result&#34;][&#34;file_size&#34;]),
                                                                   s.status[&#34;search_result&#34;][&#34;result_count&#34;]))
    return s</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.ephemeris.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>identifier:Â int, records:Â List[<a title="pyaurorax.ephemeris.classes.ephemeris.Ephemeris" href="classes/ephemeris.html#pyaurorax.ephemeris.classes.ephemeris.Ephemeris">Ephemeris</a>], validate_source:Â Optional[bool]Â =Â False) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Upload ephemeris records to AuroraX</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifier</code></strong></dt>
<dd>AuroraX data source ID</dd>
<dt><strong><code>records</code></strong></dt>
<dd>ephemeris records to upload</dd>
<dt><strong><code>validate_source</code></strong></dt>
<dd>validate all records before uploading, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 for success, raises exception on error</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXMaxRetriesException" href="../exceptions.html#pyaurorax.exceptions.AuroraXMaxRetriesException">AuroraXMaxRetriesException</a></code></dt>
<dd>max retry error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected content error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUploadException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUploadException">AuroraXUploadException</a></code></dt>
<dd>upload error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXValidationException" href="../exceptions.html#pyaurorax.exceptions.AuroraXValidationException">AuroraXValidationException</a></code></dt>
<dd>data source validation error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(identifier: int,
           records: List[Ephemeris],
           validate_source: Optional[bool] = False) -&gt; int:
    &#34;&#34;&#34;
    Upload ephemeris records to AuroraX

    Args:
        identifier: AuroraX data source ID
        records: ephemeris records to upload
        validate_source: validate all records before uploading, defaults to False

    Returns:
        0 for success, raises exception on error

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected content error
        pyaurorax.exceptions.AuroraXUploadException: upload error
        pyaurorax.exceptions.AuroraXValidationException: data source validation error
    &#34;&#34;&#34;
    # validate record sources if the flag is set
    if validate_source:
        validation_error = __validate_data_source(identifier, records)
        if validation_error:
            raise AuroraXValidationException(&#34;Unable to validate data source found &#34;
                                             &#34;in record: {}&#34;.format(validation_error))

    # translate each ephemeris record to a request-friendly
    # dict (ie. convert datetimes to strings, etc.)
    for i, _ in enumerate(records):
        if (type(records[i]) is Ephemeris):
            records[i] = records[i].to_json_serializable()  # type: ignore

    # make request
    url = urls.ephemeris_upload_url.format(identifier)
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=url,
                         body=records,
                         null_response=True)
    res = req.execute()

    # evaluate response
    if (res.status_code == 400):
        raise AuroraXUploadException(&#34;%s - %s&#34; % (res.data[&#34;error_code&#34;],
                                                  res.data[&#34;error_message&#34;]))

    # return
    return 0</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax.ephemeris" href="index.html">pyaurorax.ephemeris</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyaurorax.ephemeris.ephemeris.delete" href="#pyaurorax.ephemeris.ephemeris.delete">delete</a></code></li>
<li><code><a title="pyaurorax.ephemeris.ephemeris.describe" href="#pyaurorax.ephemeris.ephemeris.describe">describe</a></code></li>
<li><code><a title="pyaurorax.ephemeris.ephemeris.get_request_url" href="#pyaurorax.ephemeris.ephemeris.get_request_url">get_request_url</a></code></li>
<li><code><a title="pyaurorax.ephemeris.ephemeris.search" href="#pyaurorax.ephemeris.ephemeris.search">search</a></code></li>
<li><code><a title="pyaurorax.ephemeris.ephemeris.upload" href="#pyaurorax.ephemeris.ephemeris.upload">upload</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
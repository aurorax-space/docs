<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyaurorax.ephemeris API documentation</title>
<meta name="description" content="The ephemeris module is used to search and upload ephemeris records
within AuroraX …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.ephemeris</code></h1>
</header>
<section id="section-intro">
<p>The ephemeris module is used to search and upload ephemeris records
within AuroraX.</p>
<p>Note that all functions and classes from submodules are all imported
at this level of the ephemeris module. They can be referenced from
here instead of digging in deeper to the submodules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The ephemeris module is used to search and upload ephemeris records
within AuroraX.

Note that all functions and classes from submodules are all imported
at this level of the ephemeris module. They can be referenced from
here instead of digging in deeper to the submodules.
&#34;&#34;&#34;

# function and class imports
from .ephemeris import (search_async,
                        search,
                        upload,
                        delete,
                        describe,
                        get_request_url)
from .classes.ephemeris import Ephemeris
from .classes.search import Search

# pdoc imports and exports
from .ephemeris import __pdoc__ as __ephemeris_pdoc__
from .classes.ephemeris import __pdoc__ as __classes_ephemeris_pdoc__
from .classes.search import __pdoc__ as __classes_search_pdoc__
__pdoc__ = __ephemeris_pdoc__
__pdoc__ = dict(__pdoc__, **__classes_ephemeris_pdoc__)
__pdoc__ = dict(__pdoc__, **__classes_search_pdoc__)
__all__ = [
    &#34;search_async&#34;,
    &#34;search&#34;,
    &#34;upload&#34;,
    &#34;delete&#34;,
    &#34;describe&#34;,
    &#34;get_request_url&#34;,
    &#34;Ephemeris&#34;,
    &#34;Search&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyaurorax.ephemeris.classes" href="classes/index.html">pyaurorax.ephemeris.classes</a></code></dt>
<dd>
<div class="desc"><p>Separted classes and functions used by the ephemeris module …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.ephemeris.ephemeris" href="ephemeris.html">pyaurorax.ephemeris.ephemeris</a></code></dt>
<dd>
<div class="desc"><p>Functions for performing ephemeris searches</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyaurorax.ephemeris.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>data_source: <a title="pyaurorax.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.sources.classes.data_source.DataSource">DataSource</a>, start: datetime.datetime, end: datetime.datetime) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete ephemeris records between a timeframe.</p>
<p>The API processes this request asynchronously, so this method will return
immediately whether or not the data has already been deleted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_source</code></strong></dt>
<dd>data source associated with the data product records (note that
identifier, program, platform, and instrument_type are required)</dd>
<dt><strong><code>start</code></strong></dt>
<dd>timestamp marking beginning of range to delete records for, inclusive</dd>
<dt><strong><code>end</code></strong></dt>
<dd>timestamp marking end of range to delete records for, inclusive</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXMaxRetriesException" href="../exceptions.html#pyaurorax.exceptions.AuroraXMaxRetriesException">AuroraXMaxRetriesException</a></code></dt>
<dd>max retry error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXNotFoundException" href="../exceptions.html#pyaurorax.exceptions.AuroraXNotFoundException">AuroraXNotFoundException</a></code></dt>
<dd>source not found</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedException">AuroraXUnauthorizedException</a></code></dt>
<dd>invalid API key for this operation</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>missing parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(data_source: DataSource,
           start: datetime.datetime,
           end: datetime.datetime) -&gt; int:
    &#34;&#34;&#34;
    Delete ephemeris records between a timeframe.

    The API processes this request asynchronously, so this method will return
    immediately whether or not the data has already been deleted.

    Args:
        data_source: data source associated with the data product records (note that
            identifier, program, platform, and instrument_type are required)
        start: timestamp marking beginning of range to delete records for, inclusive
        end: timestamp marking end of range to delete records for, inclusive

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
        pyaurorax.exceptions.AuroraXNotFoundException: source not found
        pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
        pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
    &#34;&#34;&#34;
    # check to make sure the identifier, program, platform, and instrument type are all set in the data source
    if not all([data_source.identifier, data_source.program, data_source.platform, data_source.instrument_type]):
        raise AuroraXBadParametersException(&#34;One or more required data source parameters &#34;
                                            &#34;are missing, delete operation aborted&#34;)

    # do request
    url = urls.ephemeris_upload_url.format(data_source.identifier)
    params = {
        &#34;program&#34;: data_source.program,
        &#34;platform&#34;: data_source.platform,
        &#34;instrument_type&#34;: data_source.instrument_type,
        &#34;start&#34;: start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;)
    }
    delete_req = AuroraXRequest(method=&#34;delete&#34;,
                                url=url,
                                body=params,
                                null_response=True)
    res = delete_req.execute()

    # evaluate response
    if (res.status_code == 400):
        if type(res.data) is list:
            raise AuroraXBadParametersException(&#34;%s - %s&#34; % (res.status_code,
                                                             res.data[0][&#34;message&#34;]))
        raise AuroraXBadParametersException(&#34;%s - %s&#34; % (res.data[&#34;error_code&#34;],
                                                         res.data[&#34;error_message&#34;]))

    # return
    return 1</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>search_obj: <a title="pyaurorax.ephemeris.classes.search.Search" href="classes/search.html#pyaurorax.ephemeris.classes.search.Search">Search</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Describe an ephemeris search as a "SQL-like" string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>search_obj</code></strong></dt>
<dd>the ephemeris search object to describe</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the "SQL-like" string describing the ephemeris search object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(search_obj: Search) -&gt; str:
    &#34;&#34;&#34;
    Describe an ephemeris search as a &#34;SQL-like&#34; string

    Args:
        search_obj: the ephemeris search object to describe

    Returns:
        the &#34;SQL-like&#34; string describing the ephemeris search object
    &#34;&#34;&#34;
    # make request
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=urls.describe_ephemeris_query,
                         body=search_obj.query)
    res = req.execute()

    # return
    return res.data</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.get_request_url"><code class="name flex">
<span>def <span class="ident">get_request_url</span></span>(<span>request_id: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the ephemeris search request URL for a given
request ID. This URL can be used for subsequent
pyaurorax.requests function calls. Primarily this method
facilitates delving into details about a set of already-submitted
ephemeris searches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_id</code></strong></dt>
<dd>the request identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the request URL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_request_url(request_id: str) -&gt; str:
    &#34;&#34;&#34;
    Get the ephemeris search request URL for a given
    request ID. This URL can be used for subsequent
    pyaurorax.requests function calls. Primarily this method
    facilitates delving into details about a set of already-submitted
    ephemeris searches.

    Args:
        request_id: the request identifier

    Returns:
        the request URL
    &#34;&#34;&#34;
    url = urls.ephemeris_request_url.format(request_id)
    return url</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>start: datetime.datetime, end: datetime.datetime, programs: Optional[List[str]] = None, platforms: Optional[List[str]] = None, instrument_types: Optional[List[str]] = None, metadata_filters: Optional[List[Dict[~KT, ~VT]]] = None, metadata_filters_logical_operator: Optional[str] = None, response_format: Optional[Dict[~KT, ~VT]] = None, poll_interval: Optional[float] = 1.0, return_immediately: Optional[bool] = False, verbose: Optional[bool] = False) ‑> <a title="pyaurorax.ephemeris.classes.search.Search" href="classes/search.html#pyaurorax.ephemeris.classes.search.Search">Search</a></span>
</code></dt>
<dd>
<div class="desc"><p>Search for ephemeris records</p>
<p>By default, this function will block and wait until the request completes and
all data is downloaded. If you don't want to wait, set the 'return_immediately`
value to True. The Search object will be returned right after the search has been
started, and you can use the helper functions as part of that object to get the
data when it's done.</p>
<p>Note: At least one search criteria from programs, platforms, or
instrument_types, must be specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong></dt>
<dd>list of programs to search through, defaults to None</dd>
<dt><strong><code>platforms</code></strong></dt>
<dd>list of platforms to search through, defaults to None</dd>
<dt><strong><code>instrument_types</code></strong></dt>
<dd>list of instrument types to search through, defaults to None</dd>
<dt><strong><code>metadata_filters</code></strong></dt>
<dd>
<p>list of dictionaries describing metadata keys and
values to filter on, defaults to None</p>
<p>Example:</p>
<pre><code>[{
    "key": "nbtrace_region",
    "operator": "in",
    "values": ["north polar cap"]
}]
</code></pre>
</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong></dt>
<dd>the logical operator to use when
evaluating metadata filters (either 'AND' or 'OR'), defaults
to "AND"</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts, defaults
to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>return_immediately</code></strong></dt>
<dd>initiate the search and return without waiting for data to
be received, defaults to False</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A pyaurorax.ephemeris.Search object</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>missing parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(start: datetime.datetime,
           end: datetime.datetime,
           programs: Optional[List[str]] = None,
           platforms: Optional[List[str]] = None,
           instrument_types: Optional[List[str]] = None,
           metadata_filters: Optional[List[Dict]] = None,
           metadata_filters_logical_operator: Optional[str] = None,
           response_format: Optional[Dict] = None,
           poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
           return_immediately: Optional[bool] = False,
           verbose: Optional[bool] = False) -&gt; Search:
    &#34;&#34;&#34;
    Search for ephemeris records

    By default, this function will block and wait until the request completes and
    all data is downloaded. If you don&#39;t want to wait, set the &#39;return_immediately`
    value to True. The Search object will be returned right after the search has been
    started, and you can use the helper functions as part of that object to get the
    data when it&#39;s done.

    Note: At least one search criteria from programs, platforms, or
    instrument_types, must be specified.

    Args:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of programs to search through, defaults to None
        platforms: list of platforms to search through, defaults to None
        instrument_types: list of instrument types to search through, defaults to None
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            Example:

                [{
                    &#34;key&#34;: &#34;nbtrace_region&#34;,
                    &#34;operator&#34;: &#34;in&#34;,
                    &#34;values&#34;: [&#34;north polar cap&#34;]
                }]
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format
        poll_interval: time in seconds to wait between polling attempts, defaults
            to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
        return_immediately: initiate the search and return without waiting for data to
            be received, defaults to False
        verbose: output poll times and other progress messages, defaults to False

    Returns:
        A pyaurorax.ephemeris.Search object

    Raises:
        pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
    &#34;&#34;&#34;
    # create a Search() object
    s = Search(start,
               end,
               programs=programs,
               platforms=platforms,
               instrument_types=instrument_types,
               metadata_filters=metadata_filters,
               metadata_filters_logical_operator=metadata_filters_logical_operator,
               response_format=response_format)
    if (verbose is True):
        print(&#34;[%s] Search object created&#34; % (datetime.datetime.now()))

    # execute the search
    s.execute()
    if (verbose is True):
        print(&#34;[%s] Request submitted&#34; % (datetime.datetime.now()))
        print(&#34;[%s] Request ID: %s&#34; % (datetime.datetime.now(), s.request_id))
        print(&#34;[%s] Request details available at: %s&#34; % (datetime.datetime.now(),
                                                         s.request_url))

    # return immediately if we wanted to
    if (return_immediately is True):
        return s

    # wait for data
    if (verbose is True):
        print(&#34;[%s] Waiting for data ...&#34; % (datetime.datetime.now()))
    s.wait(poll_interval=poll_interval, verbose=verbose)

    # get the data
    if (verbose is True):
        print(&#34;[%s] Retrieving data ...&#34; % (datetime.datetime.now()))
    s.get_data()

    # return response with the data
    if (verbose is True):
        print(&#34;[%s] Retrieved %s of data containing %d records&#34; % (datetime.datetime.now(),
                                                                   humanize.filesize.naturalsize(
                                                                       s.status[&#34;search_result&#34;][&#34;file_size&#34;]),
                                                                   s.status[&#34;search_result&#34;][&#34;result_count&#34;]))
    return s</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.search_async"><code class="name flex">
<span>def <span class="ident">search_async</span></span>(<span>start: datetime.datetime, end: datetime.datetime, programs: Optional[List[str]] = None, platforms: Optional[List[str]] = None, instrument_types: Optional[List[str]] = None, metadata_filters: Optional[List[Dict[~KT, ~VT]]] = None, metadata_filters_logical_operator: Optional[str] = None, response_format: Optional[Dict[~KT, ~VT]] = None) ‑> <a title="pyaurorax.ephemeris.classes.search.Search" href="classes/search.html#pyaurorax.ephemeris.classes.search.Search">Search</a></span>
</code></dt>
<dd>
<div class="desc"><p>Submit a request for a ephemeris search, return immediately.</p>
<p>The request will be done asynchronously by the API. Use the helper functions
as part of the Search object returned to check for data and/or download it.
If you don't want the search to return immediately and rather block until
all data is downloaded, please use the 'search' function instead.</p>
<p>Note: At least one search criteria from programs, platforms, or
instrument_types, must be specified.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated</p>
<p>This function is deprecated as of 0.9.0. Please use the 'search' function
with the 'return_immediately' flag set to True to get the same behaviour.
This function will be removed in a future release.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong></dt>
<dd>list of programs to search through, defaults to None</dd>
<dt><strong><code>platforms</code></strong></dt>
<dd>list of platforms to search through, defaults to None</dd>
<dt><strong><code>instrument_types</code></strong></dt>
<dd>list of instrument types to search through, defaults to None</dd>
<dt><strong><code>metadata_filters</code></strong></dt>
<dd>
<p>list of dictionaries describing metadata keys and
values to filter on, defaults to None</p>
<p>Example:</p>
<pre><code>[{
    "key": "nbtrace_region",
    "operator": "in",
    "values": ["north polar cap"]
}]
</code></pre>
</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong></dt>
<dd>the logical operator to use when
evaluating metadata filters (either 'AND' or 'OR'), defaults
to "AND"</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A pyaurorax.ephemeris.Search object</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>missing parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_async(start: datetime.datetime,
                 end: datetime.datetime,
                 programs: Optional[List[str]] = None,
                 platforms: Optional[List[str]] = None,
                 instrument_types: Optional[List[str]] = None,
                 metadata_filters: Optional[List[Dict]] = None,
                 metadata_filters_logical_operator: Optional[str] = None,
                 response_format: Optional[Dict] = None) -&gt; Search:
    &#34;&#34;&#34;
    Submit a request for a ephemeris search, return immediately.

    The request will be done asynchronously by the API. Use the helper functions
    as part of the Search object returned to check for data and/or download it.
    If you don&#39;t want the search to return immediately and rather block until
    all data is downloaded, please use the &#39;search&#39; function instead.

    Note: At least one search criteria from programs, platforms, or
    instrument_types, must be specified.

    .. deprecated::
        This function is deprecated as of 0.9.0. Please use the &#39;search&#39; function
        with the &#39;return_immediately&#39; flag set to True to get the same behaviour.
        This function will be removed in a future release.

    Args:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of programs to search through, defaults to None
        platforms: list of platforms to search through, defaults to None
        instrument_types: list of instrument types to search through, defaults to None
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            Example:

                [{
                    &#34;key&#34;: &#34;nbtrace_region&#34;,
                    &#34;operator&#34;: &#34;in&#34;,
                    &#34;values&#34;: [&#34;north polar cap&#34;]
                }]
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format

    Returns:
        A pyaurorax.ephemeris.Search object

    Raises:
        pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
    &#34;&#34;&#34;
    warnings.warn(&#34;This function is deprecated and will be removed in a future release. Please &#34;
                  &#34;use the &#39;search&#39; function with the &#39;return_immediately&#39; flag to produce the &#34;
                  &#34;same behaviour.&#34;, DeprecationWarning, stacklevel=2)
    s = Search(start,
               end,
               programs=programs,
               platforms=platforms,
               instrument_types=instrument_types,
               metadata_filters=metadata_filters,
               metadata_filters_logical_operator=metadata_filters_logical_operator,
               response_format=response_format)
    s.execute()
    return s</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>identifier: int, records: List[<a title="pyaurorax.ephemeris.classes.ephemeris.Ephemeris" href="classes/ephemeris.html#pyaurorax.ephemeris.classes.ephemeris.Ephemeris">Ephemeris</a>], validate_source: Optional[bool] = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Upload ephemeris records to AuroraX</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifier</code></strong></dt>
<dd>AuroraX data source ID</dd>
<dt><strong><code>records</code></strong></dt>
<dd>ephemeris records to upload</dd>
<dt><strong><code>validate_source</code></strong></dt>
<dd>validate all records before uploading, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 for success, raises exception on error</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXMaxRetriesException" href="../exceptions.html#pyaurorax.exceptions.AuroraXMaxRetriesException">AuroraXMaxRetriesException</a></code></dt>
<dd>max retry error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected content error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUploadException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUploadException">AuroraXUploadException</a></code></dt>
<dd>upload error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXValidationException" href="../exceptions.html#pyaurorax.exceptions.AuroraXValidationException">AuroraXValidationException</a></code></dt>
<dd>data source validation error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(identifier: int,
           records: List[Ephemeris],
           validate_source: Optional[bool] = False) -&gt; int:
    &#34;&#34;&#34;
    Upload ephemeris records to AuroraX

    Args:
        identifier: AuroraX data source ID
        records: ephemeris records to upload
        validate_source: validate all records before uploading, defaults to False

    Returns:
        1 for success, raises exception on error

    Raises:
        pyaurorax.exceptions.AuroraXMaxRetriesException: max retry error
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected content error
        pyaurorax.exceptions.AuroraXUploadException: upload error
        pyaurorax.exceptions.AuroraXValidationException: data source validation error
    &#34;&#34;&#34;
    # validate record sources if the flag is set
    if validate_source:
        validation_error = __validate_data_source(identifier, records)
        if validation_error:
            raise AuroraXValidationException(&#34;Unable to validate data source found &#34;
                                             &#34;in record: {}&#34;.format(validation_error))

    # translate each ephemeris record to a request-friendly
    # dict (ie. convert datetimes to strings, etc.)
    for i, _ in enumerate(records):
        if (type(records[i]) is Ephemeris):
            records[i] = records[i].to_json_serializable()  # type: ignore

    # make request
    url = urls.ephemeris_upload_url.format(identifier)
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=url,
                         body=records,
                         null_response=True)
    res = req.execute()

    # evaluate response
    if (res.status_code == 400):
        raise AuroraXUploadException(&#34;%s - %s&#34; % (res.data[&#34;error_code&#34;],
                                                  res.data[&#34;error_message&#34;]))

    # return
    return 1</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.ephemeris.Ephemeris"><code class="flex name class">
<span>class <span class="ident">Ephemeris</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Ephemeris object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_source</code></strong></dt>
<dd>data source that the ephemeris record is associated with</dd>
<dt><strong><code>epoch</code></strong></dt>
<dd>timestamp for the record (assumed it is in UTC)</dd>
<dt><strong><code>location_geo</code></strong></dt>
<dd>Location object containing geographic latitude and longitude</dd>
<dt><strong><code>location_gsm</code></strong></dt>
<dd>Location object containing GSM latitude and longitude (leave
empty for data sources with a type of 'ground')</dd>
<dt><strong><code>nbtrace</code></strong></dt>
<dd>Location object with north B-trace geographic latitude and longitude</dd>
<dt><strong><code>sbtrace</code></strong></dt>
<dd>Location object with south B-trace geographic latitude and longitude</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata for this record (arbitrary keys and values)</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ephemeris(BaseModel):
    &#34;&#34;&#34;
    Ephemeris object

    Attributes:
        data_source: data source that the ephemeris record is associated with
        epoch: timestamp for the record (assumed it is in UTC)
        location_geo: Location object containing geographic latitude and longitude
        location_gsm: Location object containing GSM latitude and longitude (leave
            empty for data sources with a type of &#39;ground&#39;)
        nbtrace: Location object with north B-trace geographic latitude and longitude
        sbtrace: Location object with south B-trace geographic latitude and longitude
        metadata: metadata for this record (arbitrary keys and values)
    &#34;&#34;&#34;
    data_source: DataSource
    epoch: datetime.datetime
    location_geo: Location
    location_gsm: Optional[Location] = Location(lat=None, lon=None)
    nbtrace: Location
    sbtrace: Location
    metadata: Optional[Dict] = None

    def to_json_serializable(self) -&gt; Dict:
        &#34;&#34;&#34;
        Convert object to a JSON-serializable object (ie. translate
        datetime objects to strings)

        Returns:
            a dictionary object that is JSON-serializable
        &#34;&#34;&#34;
        # init
        d = self.__dict__

        # format epoch as str
        if (type(d[&#34;epoch&#34;]) is datetime.datetime):
            d[&#34;epoch&#34;] = d[&#34;epoch&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000Z&#34;)

        # format location
        if (type(d[&#34;location_geo&#34;]) is Location):
            d[&#34;location_geo&#34;] = d[&#34;location_geo&#34;].__dict__
        if (type(d[&#34;location_gsm&#34;]) is Location):
            d[&#34;location_gsm&#34;] = d[&#34;location_gsm&#34;].__dict__
        if (type(d[&#34;nbtrace&#34;]) is Location):
            d[&#34;nbtrace&#34;] = d[&#34;nbtrace&#34;].__dict__
        if (type(d[&#34;sbtrace&#34;]) is Location):
            d[&#34;sbtrace&#34;] = d[&#34;sbtrace&#34;].__dict__

        # format metadata
        if (type(self.metadata) is dict):
            for key, value in self.metadata.items():
                if (type(value) is datetime.datetime or type(value) is datetime.date):
                    self.metadata[key] = self.metadata[key].strftime(&#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
        if (type(self.metadata) is list):
            self.metadata = {}

        # format data source fields for query
        d[&#34;program&#34;] = self.data_source.program
        d[&#34;platform&#34;] = self.data_source.platform
        d[&#34;instrument_type&#34;] = self.data_source.instrument_type
        del d[&#34;data_source&#34;]

        # return
        return d

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        String method

        Returns:
            string format of Ephemeris
        &#34;&#34;&#34;
        return self.__repr__()

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Object representation

        Returns:
            object representation of Ephemeris
        &#34;&#34;&#34;
        # shorten the metadata
        max_len = 20
        attr_metadata = f&#34;{self.metadata}&#34;
        if (len(attr_metadata) &gt; max_len):
            attr_metadata = attr_metadata[0:max_len] + &#34;...}&#34;

        # return formatted representation
        return f&#34;Ephemeris(data_source={repr(self.data_source)}, epoch={repr(self.epoch)}, &#34; \
            f&#34;location_geo={repr(self.location_geo)}, location_gsm={repr(self.location_gsm)}, &#34; \
            f&#34;nbtrace={repr(self.nbtrace)}, nbtrace={repr(self.nbtrace)}, &#34; \
            f&#34;metadata={attr_metadata})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.ephemeris.Ephemeris.data_source"><code class="name">var <span class="ident">data_source</span> : <a title="pyaurorax.sources.classes.data_source.DataSource" href="../sources/classes/data_source.html#pyaurorax.sources.classes.data_source.DataSource">DataSource</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.ephemeris.Ephemeris.epoch"><code class="name">var <span class="ident">epoch</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.ephemeris.Ephemeris.location_geo"><code class="name">var <span class="ident">location_geo</span> : <a title="pyaurorax.location.Location" href="../location.html#pyaurorax.location.Location">Location</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.ephemeris.Ephemeris.location_gsm"><code class="name">var <span class="ident">location_gsm</span> : Optional[<a title="pyaurorax.location.Location" href="../location.html#pyaurorax.location.Location">Location</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.ephemeris.Ephemeris.metadata"><code class="name">var <span class="ident">metadata</span> : Optional[Dict[~KT, ~VT]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.ephemeris.Ephemeris.nbtrace"><code class="name">var <span class="ident">nbtrace</span> : <a title="pyaurorax.location.Location" href="../location.html#pyaurorax.location.Location">Location</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.ephemeris.Ephemeris.sbtrace"><code class="name">var <span class="ident">sbtrace</span> : <a title="pyaurorax.location.Location" href="../location.html#pyaurorax.location.Location">Location</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.ephemeris.Ephemeris.to_json_serializable"><code class="name flex">
<span>def <span class="ident">to_json_serializable</span></span>(<span>self) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert object to a JSON-serializable object (ie. translate
datetime objects to strings)</p>
<h2 id="returns">Returns</h2>
<p>a dictionary object that is JSON-serializable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json_serializable(self) -&gt; Dict:
    &#34;&#34;&#34;
    Convert object to a JSON-serializable object (ie. translate
    datetime objects to strings)

    Returns:
        a dictionary object that is JSON-serializable
    &#34;&#34;&#34;
    # init
    d = self.__dict__

    # format epoch as str
    if (type(d[&#34;epoch&#34;]) is datetime.datetime):
        d[&#34;epoch&#34;] = d[&#34;epoch&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000Z&#34;)

    # format location
    if (type(d[&#34;location_geo&#34;]) is Location):
        d[&#34;location_geo&#34;] = d[&#34;location_geo&#34;].__dict__
    if (type(d[&#34;location_gsm&#34;]) is Location):
        d[&#34;location_gsm&#34;] = d[&#34;location_gsm&#34;].__dict__
    if (type(d[&#34;nbtrace&#34;]) is Location):
        d[&#34;nbtrace&#34;] = d[&#34;nbtrace&#34;].__dict__
    if (type(d[&#34;sbtrace&#34;]) is Location):
        d[&#34;sbtrace&#34;] = d[&#34;sbtrace&#34;].__dict__

    # format metadata
    if (type(self.metadata) is dict):
        for key, value in self.metadata.items():
            if (type(value) is datetime.datetime or type(value) is datetime.date):
                self.metadata[key] = self.metadata[key].strftime(&#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
    if (type(self.metadata) is list):
        self.metadata = {}

    # format data source fields for query
    d[&#34;program&#34;] = self.data_source.program
    d[&#34;platform&#34;] = self.data_source.platform
    d[&#34;instrument_type&#34;] = self.data_source.instrument_type
    del d[&#34;data_source&#34;]

    # return
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyaurorax.ephemeris.Search"><code class="flex name class">
<span>class <span class="ident">Search</span></span>
<span>(</span><span>start: datetime.datetime, end: datetime.datetime, programs: Optional[List[str]] = None, platforms: Optional[List[str]] = None, instrument_types: Optional[List[str]] = None, metadata_filters: Optional[List[Dict[~KT, ~VT]]] = None, metadata_filters_logical_operator: Optional[str] = 'AND', response_format: Optional[Dict[~KT, ~VT]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing an ephemeris search</p>
<p>Note: At least one search criteria from programs, platforms, or instrument_types
must be specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong></dt>
<dd>list of programs to search through, defaults to None</dd>
<dt><strong><code>platforms</code></strong></dt>
<dd>list of platforms to search through, defaults to None</dd>
<dt><strong><code>instrument_types</code></strong></dt>
<dd>list of instrument types to search through, defaults to None</dd>
<dt><strong><code>metadata_filters</code></strong></dt>
<dd>
<p>list of dictionaries describing metadata keys and
values to filter on, defaults to None</p>
<p>e.g. {
"key": "string",
"operator": "=",
"values": [
"string"
]
}</p>
</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong></dt>
<dd>the logical operator to use when
evaluating metadata filters (either 'AND' or 'OR'), defaults
to "AND"</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong></dt>
<dd>unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong></dt>
<dd>unique URL assigned to the request by the AuroraX API</dd>
<dt><strong><code>executed</code></strong></dt>
<dd>indicates if the search has been executed/started</dd>
<dt><strong><code>completed</code></strong></dt>
<dd>indicates if the search has finished</dd>
<dt><strong><code>data_url</code></strong></dt>
<dd>the URL where data is accessed</dd>
<dt><strong><code>query</code></strong></dt>
<dd>the query for this request as JSON</dd>
<dt><strong><code>status</code></strong></dt>
<dd>the status of the query</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the ephemeris records found</dd>
<dt><strong><code>logs</code></strong></dt>
<dd>all log messages outputted by the AuroraX API for this request</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Search():
    &#34;&#34;&#34;
    Class representing an ephemeris search

    Note: At least one search criteria from programs, platforms, or instrument_types
    must be specified.

    Args:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of programs to search through, defaults to None
        platforms: list of platforms to search through, defaults to None
        instrument_types: list of instrument types to search through, defaults to None
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            e.g. {
                &#34;key&#34;: &#34;string&#34;,
                &#34;operator&#34;: &#34;=&#34;,
                &#34;values&#34;: [
                    &#34;string&#34;
                ]
            }
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format
        request: AuroraXResponse object returned when the search is executed
        request_id: unique ID assigned to the request by the AuroraX API
        request_url: unique URL assigned to the request by the AuroraX API
        executed: indicates if the search has been executed/started
        completed: indicates if the search has finished
        data_url: the URL where data is accessed
        query: the query for this request as JSON
        status: the status of the query
        data: the ephemeris records found
        logs: all log messages outputted by the AuroraX API for this request
    &#34;&#34;&#34;

    def __init__(self,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 programs: Optional[List[str]] = None,
                 platforms: Optional[List[str]] = None,
                 instrument_types: Optional[List[str]] = None,
                 metadata_filters: Optional[List[Dict]] = None,
                 metadata_filters_logical_operator: Optional[str] = &#34;AND&#34;,
                 response_format: Optional[Dict] = None) -&gt; None:

        # set variables using passed in args
        self.start = start
        self.end = end
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.metadata_filters = metadata_filters
        self.metadata_filters_logical_operator = metadata_filters_logical_operator
        self.response_format = response_format

        # initialize additional variables
        self.request: AuroraXResponse = None
        self.request_id: str = &#34;&#34;
        self.request_url: str = &#34;&#34;
        self.executed: bool = False
        self.completed: bool = False
        self.data_url: str = &#34;&#34;
        self.query: Dict = {}
        self.status: Dict = {}
        self.data: List[Union[Ephemeris, Dict]] = []
        self.logs: List[Dict] = []

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        String method

        Returns:
            string format of Ephemeris Search object
        &#34;&#34;&#34;
        return self.__repr__()

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Object representation

        Returns:
            object representation of Ephemeris Search object
        &#34;&#34;&#34;
        return f&#34;EphemerisSearch(executed={self.executed}, &#34; \
            f&#34;completed={self.completed}, request_id=&#39;{self.request_id}&#39;)&#34;

    @property
    def query(self):
        &#34;&#34;&#34;
        Property for the query value
        &#34;&#34;&#34;
        self._query = {
            &#34;data_sources&#34;: {
                &#34;programs&#34;: [] if not self.programs else self.programs,
                &#34;platforms&#34;: [] if not self.platforms else self.platforms,
                &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
                &#34;ephemeris_metadata_filters&#34;: {} if not self.metadata_filters
                else {
                    &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
                    &#34;expressions&#34;: self.metadata_filters
                },
            },
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        }
        return self._query

    @query.setter
    def query(self, query):
        self._query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate ephemeris search request

        Raises:
            pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
        &#34;&#34;&#34;
        # check for at least one filter criteria
        if not (self.programs or self.platforms or self.instrument_types or self.metadata_filters):
            raise AuroraXBadParametersException(&#34;At least one filter criteria parameter &#34;
                                                &#34;besides &#39;start&#39; and &#39;end&#39; must be specified&#34;)

        # do request
        url = urls.ephemeris_search_url
        req = AuroraXRequest(method=&#34;post&#34;,
                             url=url,
                             body=self.query,
                             null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if (res.status_code == 202):
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set the request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this ephemeris search request

        Args:
            status: the previously-retrieved status of this request (include
                to avoid requesting it from the API again), defaults to None
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.request_url)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s%s&#34; % (urls.base_url,
                                      status[&#34;search_result&#34;][&#34;data_uri&#34;])

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this ephemeris
        search request

        Returns:
            True if data is available, else False
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this ephemeris search
        request
        &#34;&#34;&#34;
        # check if completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.data_url, response_format=self.response_format)

        # set data variable
        if self.response_format is not None:
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_source&#34;] = ds

            # cast ephemeris objects
            self.data = [Ephemeris(**e) for e in raw_data]

    def wait(self,
             poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
             verbose: Optional[bool] = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait for the request to complete and data is
        available for retrieval

        Args:
            poll_interval: time in seconds to wait between polling attempts,
                defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
            verbose: output poll times and other progress messages, defaults
                to False
        &#34;&#34;&#34;
        url = urls.ephemeris_request_url.format(self.request_id)
        self.update_status(requests_wait_for_data(url,
                                                  poll_interval=poll_interval,
                                                  verbose=verbose))

    def cancel(self,
               wait: Optional[bool] = False,
               poll_interval: float = STANDARD_POLLING_SLEEP_TIME,
               verbose: Optional[bool] = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the ephemeris search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait: wait until the cancellation request has been
                completed (may wait for several minutes)
            poll_interval: seconds to wait between polling
                calls, defaults to STANDARD_POLLING_SLEEP_TIME.
            verbose: output poll times and other progress messages, defaults
                to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
            pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
        &#34;&#34;&#34;
        url = urls.ephemeris_request_url.format(self.request_id)
        return requests_cancel(url, wait=wait, poll_interval=poll_interval, verbose=verbose)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.ephemeris.Search.query"><code class="name">var <span class="ident">query</span></code></dt>
<dd>
<div class="desc"><p>Property for the query value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self):
    &#34;&#34;&#34;
    Property for the query value
    &#34;&#34;&#34;
    self._query = {
        &#34;data_sources&#34;: {
            &#34;programs&#34;: [] if not self.programs else self.programs,
            &#34;platforms&#34;: [] if not self.platforms else self.platforms,
            &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
            &#34;ephemeris_metadata_filters&#34;: {} if not self.metadata_filters
            else {
                &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
                &#34;expressions&#34;: self.metadata_filters
            },
        },
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
    }
    return self._query</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.ephemeris.Search.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: Optional[bool] = False, poll_interval: float = 1.0, verbose: Optional[bool] = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel the ephemeris search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong></dt>
<dd>wait until the cancellation request has been
completed (may wait for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>seconds to wait between polling
calls, defaults to STANDARD_POLLING_SLEEP_TIME.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnexpectedContentTypeException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnexpectedContentTypeException">AuroraXUnexpectedContentTypeException</a></code></dt>
<dd>unexpected error</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedException" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedException">AuroraXUnauthorizedException</a></code></dt>
<dd>invalid API key for this operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self,
           wait: Optional[bool] = False,
           poll_interval: float = STANDARD_POLLING_SLEEP_TIME,
           verbose: Optional[bool] = False) -&gt; int:
    &#34;&#34;&#34;
    Cancel the ephemeris search request

    This method returns immediately by default since the API processes
    this request asynchronously. If you would prefer to wait for it
    to be completed, set the &#39;wait&#39; parameter to True. You can adjust
    the polling time using the &#39;poll_interval&#39; parameter.

    Args:
        wait: wait until the cancellation request has been
            completed (may wait for several minutes)
        poll_interval: seconds to wait between polling
            calls, defaults to STANDARD_POLLING_SLEEP_TIME.
        verbose: output poll times and other progress messages, defaults
            to False

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXUnexpectedContentTypeException: unexpected error
        pyaurorax.exceptions.AuroraXUnauthorizedException: invalid API key for this operation
    &#34;&#34;&#34;
    url = urls.ephemeris_request_url.format(self.request_id)
    return requests_cancel(url, wait=wait, poll_interval=poll_interval, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.Search.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to see if data is available for this ephemeris
search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Check to see if data is available for this ephemeris
    search request

    Returns:
        True if data is available, else False
    &#34;&#34;&#34;
    self.update_status()
    return self.completed</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.Search.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate ephemeris search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXBadParametersException" href="../exceptions.html#pyaurorax.exceptions.AuroraXBadParametersException">AuroraXBadParametersException</a></code></dt>
<dd>missing parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; None:
    &#34;&#34;&#34;
    Initiate ephemeris search request

    Raises:
        pyaurorax.exceptions.AuroraXBadParametersException: missing parameters
    &#34;&#34;&#34;
    # check for at least one filter criteria
    if not (self.programs or self.platforms or self.instrument_types or self.metadata_filters):
        raise AuroraXBadParametersException(&#34;At least one filter criteria parameter &#34;
                                            &#34;besides &#39;start&#39; and &#39;end&#39; must be specified&#34;)

    # do request
    url = urls.ephemeris_search_url
    req = AuroraXRequest(method=&#34;post&#34;,
                         url=url,
                         body=self.query,
                         null_response=True)
    res = req.execute()

    # set request ID, request_url, executed
    self.executed = True
    if (res.status_code == 202):
        # request successfully dispatched
        self.executed = True
        self.request_url = res.request.headers[&#34;location&#34;]
        self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

    # set the request variable
    self.request = res</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.Search.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the data available for this ephemeris search
request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; None:
    &#34;&#34;&#34;
    Retrieve the data available for this ephemeris search
    request
    &#34;&#34;&#34;
    # check if completed yet
    if (self.completed is False):
        print(&#34;No data available, update status or check for data first&#34;)
        return

    # get data
    raw_data = requests_get_data(self.data_url, response_format=self.response_format)

    # set data variable
    if self.response_format is not None:
        self.data = raw_data
    else:
        # cast data source objects
        for i in range(0, len(raw_data)):
            ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
            raw_data[i][&#34;data_source&#34;] = ds

        # cast ephemeris objects
        self.data = [Ephemeris(**e) for e in raw_data]</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.Search.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict[~KT, ~VT]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of this ephemeris search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong></dt>
<dd>the previously-retrieved status of this request (include
to avoid requesting it from the API again), defaults to None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self, status: Optional[Dict] = None) -&gt; None:
    &#34;&#34;&#34;
    Update the status of this ephemeris search request

    Args:
        status: the previously-retrieved status of this request (include
            to avoid requesting it from the API again), defaults to None
    &#34;&#34;&#34;
    # get the status if it isn&#39;t passed in
    if (status is None):
        status = requests_get_status(self.request_url)

    # update request status by checking if data URI is set
    if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
        self.completed = True
        self.data_url = &#34;%s%s&#34; % (urls.base_url,
                                  status[&#34;search_result&#34;][&#34;data_uri&#34;])

    # set class variable &#34;status&#34; and &#34;logs&#34;
    self.status = status
    self.logs = status[&#34;logs&#34;]</code></pre>
</details>
</dd>
<dt id="pyaurorax.ephemeris.Search.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: Optional[float] = 1.0, verbose: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Block and wait for the request to complete and data is
available for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts,
defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self,
         poll_interval: Optional[float] = STANDARD_POLLING_SLEEP_TIME,
         verbose: Optional[bool] = False) -&gt; None:
    &#34;&#34;&#34;
    Block and wait for the request to complete and data is
    available for retrieval

    Args:
        poll_interval: time in seconds to wait between polling attempts,
            defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
        verbose: output poll times and other progress messages, defaults
            to False
    &#34;&#34;&#34;
    url = urls.ephemeris_request_url.format(self.request_id)
    self.update_status(requests_wait_for_data(url,
                                              poll_interval=poll_interval,
                                              verbose=verbose))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax" href="../index.html">pyaurorax</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyaurorax.ephemeris.classes" href="classes/index.html">pyaurorax.ephemeris.classes</a></code></li>
<li><code><a title="pyaurorax.ephemeris.ephemeris" href="ephemeris.html">pyaurorax.ephemeris.ephemeris</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pyaurorax.ephemeris.delete" href="#pyaurorax.ephemeris.delete">delete</a></code></li>
<li><code><a title="pyaurorax.ephemeris.describe" href="#pyaurorax.ephemeris.describe">describe</a></code></li>
<li><code><a title="pyaurorax.ephemeris.get_request_url" href="#pyaurorax.ephemeris.get_request_url">get_request_url</a></code></li>
<li><code><a title="pyaurorax.ephemeris.search" href="#pyaurorax.ephemeris.search">search</a></code></li>
<li><code><a title="pyaurorax.ephemeris.search_async" href="#pyaurorax.ephemeris.search_async">search_async</a></code></li>
<li><code><a title="pyaurorax.ephemeris.upload" href="#pyaurorax.ephemeris.upload">upload</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.ephemeris.Ephemeris" href="#pyaurorax.ephemeris.Ephemeris">Ephemeris</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.ephemeris.Ephemeris.data_source" href="#pyaurorax.ephemeris.Ephemeris.data_source">data_source</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Ephemeris.epoch" href="#pyaurorax.ephemeris.Ephemeris.epoch">epoch</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Ephemeris.location_geo" href="#pyaurorax.ephemeris.Ephemeris.location_geo">location_geo</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Ephemeris.location_gsm" href="#pyaurorax.ephemeris.Ephemeris.location_gsm">location_gsm</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Ephemeris.metadata" href="#pyaurorax.ephemeris.Ephemeris.metadata">metadata</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Ephemeris.nbtrace" href="#pyaurorax.ephemeris.Ephemeris.nbtrace">nbtrace</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Ephemeris.sbtrace" href="#pyaurorax.ephemeris.Ephemeris.sbtrace">sbtrace</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Ephemeris.to_json_serializable" href="#pyaurorax.ephemeris.Ephemeris.to_json_serializable">to_json_serializable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.ephemeris.Search" href="#pyaurorax.ephemeris.Search">Search</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.ephemeris.Search.cancel" href="#pyaurorax.ephemeris.Search.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Search.check_for_data" href="#pyaurorax.ephemeris.Search.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Search.execute" href="#pyaurorax.ephemeris.Search.execute">execute</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Search.get_data" href="#pyaurorax.ephemeris.Search.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Search.query" href="#pyaurorax.ephemeris.Search.query">query</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Search.update_status" href="#pyaurorax.ephemeris.Search.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.ephemeris.Search.wait" href="#pyaurorax.ephemeris.Search.wait">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>